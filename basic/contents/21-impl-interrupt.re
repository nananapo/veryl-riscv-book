= M-modeの実装 (2. 割り込みの実装)

== 概要

=== 割り込みとは何か？

アプリケーションを記述するとき、キーボードやマウスの入力、時間の経過のようなイベントに起因して何らかのプログラムを実行したいことがあります。
例えばキーボードから入力を得たいとき、ポーリング(Polling)、または割り込み(Interrupt)という手法が利用されます。

TODO図

ポーリングとは、定期的に問い合わせを行う方式のことです。
例えばキーボード入力の場合、定期的にキーボードデバイスにアクセスして入力があるかどうかを確かめます。
1秒くらいかかる処理Aを繰り返すとして、繰り返しごとに入力の有無を確認する場合、最大1秒の遅延が発生します(TODO 図)。
待ち時間減らすために処理Aを分割すると遅延は減少しますが、
長時間キーボード入力が無い場合、
入力の有無の確認頻度が上がる分だけ何も入力が無いデバイスに対する確認処理が実行されることになります。
この問題は、CPUからデバイスに問い合わせをする方式では解決できません。

入力の理想的な確認タイミングは入力が確認できるようになってすぐであるため、
入力があったタイミングでデバイス側からCPUにイベントを通知すればいいです。
これを実現するのが割り込みです。

TODO 図

割り込みとは、何らかのイベントの通知によって実行中のプログラムを中断して通知内容を処理する方式のことです。
割り込みを使うと、ポーリングのように無駄にデバイスにアクセスをすることなく、入力の処理が必要な時にだけ実行できます(TODO 図)。

=={riscv-interrupts} RISC-Vの割り込み

RISC-Vでは割り込み機能がCSRによって提供されます。
割り込みが発生するとトラップが発生します。
割り込みを発生させるようなイベントは外部割り込み、ソフトウェア割り込み、タイマ割り込みの3つに大別されます。

 : 外部割り込み (External Interrupt)
    コア外部のデバイスによって発生する割り込み。
    複数の外部デバイスの割り込みは割り込みコントローラ(@<chapref>{25-impl-plic})などによって調停(制御)されます。

 : ソフトウェア割り込み (Software Interrupt)
    CPUで動くソフトウェアが発生させる割り込み。
    CSR、もしくはメモリにマップされたレジスタ値の変更によって発生します。

 : タイマ割り込み
    タイマ回路(デバイス)によって引き起こされる割り込み。
    タイマの設定と時間経過によって発生します。

@<b>{M-modeだけ}が実装されたRISC-VのCPUでは、次にような順序で割り込みが提供されます。
他に実装されている特権レベルがある場合については@<secref>{22-umode-csr|umode-int}、@<secref>{23-smode-csr|delegating-trap}で解説します。

 1. 割り込みを発生させるようなイベントがデバイスで発生する
 1. 割り込み原因に対応したmipレジスタのビットが@<code>{0}から@<code>{1}になる
 1. 割り込み原因に対応したmieレジスタのビットが@<code>{1}であることを確認する (@<code>{0}なら割り込みは発生しない)
 1. mstatus.MIEが@<code>{1}であることを確認する (@<code>{0}なら割り込みは発生しない)
 1. (割り込み(トラップ)開始)
 1. mstatus.MPIEにmstatus.MIEを格納する
 1. mstatus.MIEに@<code>{0}を格納する
 1. mtvecレジスタの値(トラップベクタ)にジャンプする

TODO mipとmieの図

mip(Machine Interrupt Pending)レジスタは割り込みの発生を待っている(待機)状態を示すMXLENビットのCSRです(TODO 図)。
mie(Machine Interrupt Enable)レジスタは割り込みを許可するかを原因ごとに管理する制御するMXLENビットのCSRです(TODO 図)。
mstatus.MIEはすべての割り込みを許可するかどうかを制御する1ビットのフィールドです。
mieとmstatus.MIEのことを割り込みイネーブル(許可)レジスタと呼び、
特にmstatus.MIEのようなすべての割り込みを制御するレジスタのことをグローバル割り込みイネーブルビットと呼びます

割り込みの発生時にmstatus.MIEを0にすることで、割り込みの処理中に割り込みが発生することを防いでいます。
また、トラップから戻る(MRET命令を実行する)とき、mstatus.MPIEの値をmstatus.MIEに書き戻すことで割り込みの許可状態を戻します。

=== 割り込みの優先順位

RISC-Vには外部割り込み、ソフトウェア割り込み、タイマ割り込みがそれぞれM-mode、S-mode向けに用意されています。
それぞれの割り込みにはテーブルTODOのような優先順位が定義されていて、
複数の割り込みを発生させられるときは優先順位が高い割り込みを発生させます。

TODOテーブル

=== 割り込みの原因(cause)

それぞれの割り込みには原因を区別するための値(cause)が割り当てられています。
割り込みのcauseのMSBは1です。

@<code>{CsrCause}型に割り込みのcauseを追加してください
()。

//list[][]{
//}

=== ACLINT (Advanced Core Local Interruptor)

RISC-Vにはソフトウェア割り込みとタイマ割り込みを実現するデバイスの仕様であるACLINTが用意されています。
ACLINTは、SiFive社が開発したCLINT(Core-Local Interruptor)デバイスが基になった仕様です。

ACLINTにはMTIMER、MSWI、SSWIの3つのデバイスが定義されています。
それぞれタイマ割り込み、ソフトウェア割り込み、ソフトウェア割り込み向けのデバイスで、
mipレジスタのMTIP、MSIP、SSIPビットに状態を通知します。

本書ではACLINTを図TODOのようなメモリマップで実装します。
本章ではMTIMER、MSWIデバイスを実装し、@<secref>{23-smode-csr|impl-sswi}でSSWIデバイスを実装します。
デバイスのの具体的な仕様については後で解説します。

メモリマップ用の定数をeeiパッケージに記述してください
()。

//list[][]{
//}

== ACLINTモジュールの作成

まず、ACLINTとcoreモジュールを接続するためのインターフェースを作成します。
@<code>{src/aclint_if.veryl}を作成し、次のように記述します
()。
インターフェースの中身はデバイスの実装時に実装します。

//list[][]{
//}

topモジュールでaclint_ifインターフェースをインスタンス化しておきます
()。

//list[][]{
//}

ACLINTを実装するモジュールを作成します。
@<code>{src/aclint_memory.veryl}を作成し、次のように記述します
()。
まだ何のレジスタも実装していません。

//list[][]{
//}

aclint_memoryモジュールをインスタンス化し、mmio_controllerモジュールを接続します
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

coreモジュール内のcsrunitモジュールとaclint_memoryモジュールを接続します
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

== ソフトウェア割り込みの実装 (MSWI)

MSWIデバイスはソフトウェア割り込み(machine software interrupt)を提供するためのデバイスです。
MSWIデバイスにはハードウェアスレッド毎に4バイトのMSIPレジスタが用意されています(TODO テーブル)。
MSIPレジスタの上位31ビットは読み込み専用の@<code>{0}であり、最下位ビットのみ変更できます。
各MSIPレジスタは、それに対応するハードウェアスレッドのmip.MSIPと接続されています。

TODOテーブル (最大4095個)

仕様上はmhartidとACLINTのレジスタのhartIDが一致する必要はありませんが、
本書ではmhartidとhartIDが同じになるように実装します。

=== MSIPレジスタを実装する

ACLINTモジュールにMSIPレジスタを実装します。
今のところCPUにはmhartidが0のハードウェアスレッドしか存在しないため、MSIP0のみ実装します。

@<code>{msip0}レジスタを作成し、読み書きできるようにします
()。

//list[][]{
//}

//list[][]{
//}

aclint_ifインターフェースに@<code>{msip}を作成し、@<code>{msip0}レジスタと接続します
()。

//list[][]{
//}

//list[][]{
//}

=== mip、mieレジスタを実装する

mipレジスタのMSIPビット、MIEレジスタのMSIEビットを実装します。
mie.MSIEはMSIPビットによる割り込み待機を許可するかを制御するビットです。
mip.MSIPとmie.MSIEは同じ位置のビットに配置されています。
mip.MSIPに書き込むことはできません。

csrunitモジュールにmip、mieレジスタを作成します
()。
mieレジスタはMSIPビットだけ書き込めるように実装し、
mipレジスタはMSIEビットを接続した値として実装します。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

=== mstatusのMIE、MPIEビットを実装する

mstatus.MIE、MPIEを変更できるようにします
()。

//list[][]{
//}

//list[][]{
//}

=== 割り込み処理の実装

必要なレジスタを実装できたので、割り込みを起こす処理を実装します。
割り込みはmip、mieの両方のビット、mstatus.MIEビットが立っているときに発生します。

割り込みを起こすべきかを判定する変数、cause、トラップベクタを示す変数を作成します
()。

//list[][]{
//}

トラップ情報についての変数に割り込みの変数を割り当てます
()。
割り込みよりも例外を優先します。

//list[][]{
//}

トラップが発生するとき、mstatus.MPIEにmstatus.MIE、mstatus.MIEに@<code>{0}を設定します
()。
また、例外が発生したときにのみmtvalレジスタに例外の原因を書き込むようにします。

//list[][]{
//}

=== MRET命令の実装

トラップから戻る(trap return)とき、
mstatus.MIEにmstatus.MPIE、mstatus.MPIEに@<code>{0}を書き込みます
()。
これにより、トラップによって変更されていたmstatus.MIEを元に戻されます。

//list[][]{
//}

=== mtvecのVectoredモードの実装

mtvecレジスタにはMODEフィールドがあり、
割り込みが発生するときのトラップベクタの決定方法を制御できます。

MODEがDirect(@<code>{2'b00})のとき、@<code>{mtvec.BASE << 2}のアドレスにトラップします。
Vectored(@<code>{2'b01})のとき、@<code>{(mtvec.BASE << 2) + 4 * cause}のアドレスにトラップします。
ここでcauseは割り込みのcauseのMSBを除いた値です。
例えばmachine software interruptの場合、@<code>{(mtvec.BASE << 2) + 4 * 3}がトラップベクタになります。

mtvec.MODEにVectoredを書き込めるようにします
()。

//list[][]{
//}

MODEとcauseに応じて割り込みのトラップベクタを変更します
()。

//list[][]{
//}

=== ソフトウェア割り込みをテストする

ソフトウェア割り込みが正しく動くことを確認します。

@<code>{test/aclint_msi.c}を作成し、次のように記述します
()。

//list[][]{
//}

プログラムでは、
mtvecにinterrupt_handler関数のアドレスを書き込み、
mstatus.MIE、mie.MSIEを@<code>{1}に設定して割り込みを許可してから
MSIP0レジスタに1を書き込んでいます。

プログラムをコンパイルして実行すると、TODOリストのように表示されます。
main関数からinterrupt_handler関数にトラップしていることが分かります。

//list[][]{
//}

ソフトウェア割り込みが発生していることを確認できました。

== タイマ割り込みの実装 (MTIMER)

=== タイマ割り込みの仕組み

MTIMERデバイスは、タイマ割り込み(machine timer interrupt)を提供するためのデバイスです。
MTIMERデバイスには1つの8バイトのMTIMEレジスタ、
ハードウェアスレッド毎に8バイトのMTIMECMPレジスタが用意されています(TODOテーブル)。
本書ではMTIMECMPの後ろにMTIMEを配置します。

TODO テーブル (MTIME)
TODO テーブル (MTIMECMP 最大4095個)

MTIMEレジスタは、固定された周波数でのサイクル数をカウントするレジスタです。
リセット時に@<code>{0}になります。

MTIMERデバイスは、それに対応するハードウェアスレッドのmip.MTIPと接続されており、
MTIMEがMTIMECMPを上回ったときmip.MTIPを@<code>{1}にします。
これにより、指定した時間に割り込みを発生させることが可能になります。

=== MTIME、MTIMECMPレジスタを実装する

ACLINTモジュールにMTIME、MTIMECMPレジスタを実装します。
今のところmhartidが@<code>{0}のハードウェアスレッドしか存在しないため、MTIMECMP0のみ実装します。

@<code>{mtime}、@<code>{mtimecmp0}レジスタを作成し、読み書きできるようにします
()。
@<code>{mtime}に値が書き込まれないとき、クロック毎にインクリメントします。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

aclint_ifインターフェースに@<code>{mtip}を作成し、タイマ割り込みが発生する条件を設定します
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

=== 割り込み原因を設定する

TODO memunitを止められていない -> 割り込めるのは最初の1クロックだけ

割り込み原因を優先順位に応じて設定します。
タイマ割り込みはソフトウェア割り込みよりも優先順位が低いため、
ソフトウェア割り込みの下で原因を設定します
()。

//list[][]{
//}

=== タイマ割り込みをテストする

タイマ割り込みが正しく動くことを確認します。

@<code>{test/aclint_mti.c}を作成し、次のように記述します
()。

//list[][]{
//}

プログラムでは、mtimecmpをmtimeに@<code>{1000}を足した値に設定し、
mtvecにinterrupt_handler関数のアドレスを書き込んだ後、
mstatus.MIE、mie.MTIEを@<code>{1}に設定して割り込みを許可しています。

プログラムをコンパイルして実行すると、TODOリストのように表示されます。
時間経過によってmain関数からinterrupt_handler関数にトラップしていることが分かります。

//list[][]{
//}

タイマ割り込みが発生していることを確認できました。

== WFI命令の実装

WFI命令は割り込みが発生するまで、CPUをストールさせる命令です。
ただし、グローバル割り込みイネーブルビットは考慮せず、
ある割り込みの待機(pending)ビットと許可(enable)ビットの両方が立っているときに実行を再開します。
また、それ以外の自由な理由で実行を再開させてもいいです。
WFI命令で割り込みが発生するとき、WFI命令の次のアドレスの命令で割り込みが起こったことにします。

本書ではWFI命令でCPUをストールさせるように実装します。

inst_decoderモジュールでWFI命令をデコードできるようにします
()。

//list[][]{
//}

csrunitモジュールに@<code>{stall}フラグを実装し、WFI命令の時にビットを立てるようにします
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

WFI命令で割り込みが発生するとき、mepcレジスタに@<code>{pc + 4}を書き込むようにします
()。

//list[][]{
//}

coreモジュールでcsrunitモジュールの@<code>{stall}フラグによってMEM(CSR)ステージをストールさせます
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

== time、instret、cycleレジスタの実装

RISC-Vにはtime、instret、cycleという読み込み専用のCSRが定義されており、
それぞれmtime、minstret、mcycleレジスタと同じ値をとります@<fn>{hpmcounter}。

//footnote[hpmcounter][mhpmcounterレジスタと同じ値をとるhpmcounterレジスタもありますが、mhpmcounterレジスタを実装していないので実装しません。]

@<code>{CsrAddr}型にレジスタのアドレスを追加します
()。

//list[][]{
//}

mtimeレジスタの値をACLINTモジュールからcsrunitに渡します
()。

//list[][]{
//}

//list[][]{
//}

time、instret、cycleレジスタを読み込めるようにします。

//list[][]{
//}
