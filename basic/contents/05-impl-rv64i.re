= RV64Iの実装

前章ではRISC-Vの32bit環境であるRV32IのCPUを実装しました。
RISC-Vには64bit環境の基本整数命令セットとしてRV64Iが用意されています。
本章ではRV32IのCPUをRV64Iにアップグレードします。

では、具体的にRV32IとRV64Iは何が違うのでしょうか?
RV64Iでは、レジスタの幅が32bitから64bitに変わり、各種演算命令の演算の幅も64ビットになります。

それに伴い、次の命令が追加で定義されます。

これらの命令は32ビット幅での演算を行うものか、64ビット幅でロードストアする命令です。

本章では、ロードストア命令を実装した後、それ以外の命令を実装します。

命令を実装したら、riscv-testsを実行することで、rv32ui-p-が正常に動くことを検証してください。
64ビット向けのテストはrv64i-p-から始まるテストです。
命令を実装するたびにテストを実行することで、命令が正しく実行できていることを確認してください。

== メモリの幅を広げる

ロードストア命令を実装するにあたって、メモリの幅を広げます。
現在のメモリの幅は32ビットですが、このままだと64ビットでロードストアを行う場合に最低2回のメモリアクセスが必要になってしまいます。
これを1回のメモリアクセスで済ませるために、メモリ幅を32ビットから64ビットに広げます。

プログラム

命令フェッチ部では、64ビットの読み出しデータの上位32ビット, 下位32ビットをPCの下位3ビットで選択します。
PC[2:0]が0のときは下位32ビット、4のときは上位32ビットになります。

プログラム

メモリ命令を処理する部分では、LW命令に新たにrdataの選択処理を追加します。
LB[U], LH[U]については上位32ビットの場合について追加します。
ストア命令では、マスクを変更し、アドレスに合わせてwdataを変更します。

プログラム

== LW, LWU, LD命令の実装

LW命令は、符号拡張するように変更します。
LWU命令は、LHU, LBU命令と同様に0拡張すればよいです。
LD命令は、メモリのrdataをそのまま結果に格納します。

== SD命令の実装

SD命令は、マスクをすべて1で埋めて、wdataをレジスタの値をそのままにします。

== LUI, AUIPC命令の実装

なんか変わったっけ？？？

== ADDW, ADDIW, SUBW命令の実装

32ビット単位で足し算、引き算をする命令が追加されています。
これに対応するためにALUを変更します。

結果は符号拡張する必要があります。

== シフト命令の実装

SLLIW, SRLIW, SRAIW, SLL, SRL, SRA, SLLW, SRLW, SRAW

32ビット単位に対してシフトする命令が追加されています。
これに対応するためにALUを変更します。

== riscv-tests

RV64Iのテストがすべて正常に実行できることを確認してください。