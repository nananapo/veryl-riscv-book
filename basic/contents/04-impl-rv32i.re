= RV32Iの実装

本章ではRISC-Vの基本整数命令セットであるRV32Iを実装します。
基本整数命令であるから、整数の足し算やビット演算、シフト命令などの最低限の命令しか実装されていません。
RV32Iには32bit幅のレジスタが32個用意されていて、0番目のレジスタの値は常に0です。

本書ではCPUの高速化のことは考えず、マルチサイクルで同時に一つの命令のみを実行するCPUを実装します。

== プロジェクトの作成

まず、Verylのプロジェクトを作成します。
Verylには、verylupというtoolchainが用意されており、これを利用することでverylをインストールすることができます。

//terminal[verylup-install][verylupのインストール]{
$ @<userinput>{cargo install verylup} @<balloon>{verylupのインストール}
$ @<userinput>{verylup setup} @<balloon>{verylupのセットアップ}
[INFO ]  downloading toolchain: latest
[INFO ]   installing toolchain: latest
[INFO ]     creating hardlink: veryl
[INFO ]     creating hardlink: veryl-ls
//}

Verylをインストールできたらプロジェクトを作成します。
ここでは適当にcoreという名前にしています。

//terminal[veryl-new][新規プロジェクトの作成]{
$ @<userinput>{veryl new core}
[INFO ]      Created "core" project
//}

すると、プロジェクト名のフォルダと、その中にVeryl.tomlが作成されています。

//list[Veryl.toml.first][作成されたVeryl.toml]{
TODO 極性の設定とかについて書く
//}

Verylのプログラムを格納するために、srcフォルダを作成しておいてください。
//terminal[][]{
$ @<userinput>{mkdir src}
//}

== 定数の定義

いよいよプログラムを記述していきます。
まず、CPU内で何度も使用する定数や型をパッケージに定義します。

@<code>{src/eei.veryl}を作成し、次のように記述します。

//list[eei.veryl][eei.veryl]{

//}

EEIとは、RISC-V execution environment interfaceの略です。
RISC-Vのプログラムの実行環境とインターフェースという広い意味があり、
ISAの定義もEEIに含まれているため名前を使用しています。

XLENは、レジスタの長さを示す数字です。
RV32Iのレジスタの長さは32ビットであるため、値を32にしています。

== メモリ

=== メモリのインターフェースの定義

CPUはメモリに格納されたプログラムを実行します。よって、CPUの実装のためにはメモリの実装が必要です。
メモリの定義をするために、次の定数を@<code>{eei}パッケージに定義します。

//list[eei.veryl.memory][定数の定義]{

//}

ILENは、実装がサポートする命令の最大の幅を示す値です。
RISC-Vの命令の幅は、後の章で説明する圧縮命令を除けばすべて32ビットです。
そのため、値を32をにしています。

また、何度も使用することになる型に名前を付けています。
UIntXは幅がXLENの符号なし整数、Instは命令を格納するための型、Addrはメモリアドレスを格納するための型です。

メモリの読み書きの単位を32ビットとします。

メモリモジュールを定義するにあたって、次のようなポートが必要になります。

表

これらのポートを一つ一つ接続するのは面倒になるため、先にinterfaceを定義しておきます。

//list[memif.veryl][インターフェースの定義(memif.veryl)]{
//}

interfaceを利用することで、ポートの相互接続を簡潔にすることができます。

=== メモリの定義

メモリを作る準備が整いました。
@<code>{src/memory.veryl}を作成し、その中にメモリモジュールを記述します。

//list[memory.veryl][memory.veryl]{

//}

memoryモジュールには次のパラメータが定義されています。

表

memoryモジュールのポートは次の通りです。

表

memoryモジュールは@<code>{addr}ポートで受け取ったアドレスのデータを読み出し、
次のクロックでデータを@<code>{rdata}レジスタに出力します。

メモリの初期値を$readmemhシステムタスクでファイルに記述された値に設定します。
ファイルには、次のアセンブリを示す、次の値を格納してください。

//list[asm][あ]{
//}

//list[asm2][あ]{
//}

== topモジュールの作成

次に、最上位のモジュールを定義します。

//list[top.veryl.all][top.veryl]{
//}

topモジュールには次のポートが定義されています。

表
clock, reset

先ほど作ったmemoryモジュールをインスタンス化しています。
memoryモジュールのポートに接続するためのmemifインターフェースもインスタンス化しています。

== 命令フェッチ

=== 命令フェッチの実装

CPUのメイン部分を作成していきます。

@<code>{src/core.veryl}を作成し、次のように記述してください。

//list[core.veryl.all][core.veryl]{
//}

@<code>{var pc : Addr = 0;}は、現在実行している命令のアドレスを示すレジスタの定義です。
このようなレジスタのことをプログラムカウンタ(PC)と呼びます。
単位はバイトで、初期値を0として定義しています。

coreモジュールは、メモリにアドレスがPCのデータを要求します。
メモリが要求を受け入れたらPCを4インクリメントします。
また、次のクロック以降に返答がvalidになるのを待ち、validになったらまたPCのアドレスのデータを要求します。

次に、topモジュールでcoreモジュールをインスタンス化し、memifインターフェースを接続します。
これによって、メモリとCPUが接続されました。

=== 動作の確認

ここまでのプログラムが正しく動くか検証しましょう。

Verylのプログラムは、次のようにビルドすることができます。
//terminal[veryl-build][プログラムのビルド / フォーマット]{
$ @<userinput>{veryl fmt} @<balloon>{プログラムのフォーマット}
$ @<userinput>{veryl build} @<balloon>{ビルド}
//}

ここでビルドとは@<code>{veryl}ファイルをSystemVerilogに変換することを指します。
ビルドすると、@<code>{ファイル名.sv}と@<code>{ファイル名.sv.map}、@<code>{ファイルリストのやつ}が生成されます。

プログラムを実行(シミュレーション)するために、verilatorを利用します。
//terminal[verilator][verilator]{
$ @<userinput>{verilator にゃ}
//}

生成されたシミュレータを実行します。
//terminal[check-memory][命令フェッチの動作チェック]{
//}

メモリファイルのデータが1行ずつ読み込まれていることが確認できます。
これらのビルド、シミュレータのビルドを一つのコマンドで済ますために、Makefileを作成しておきましょう。

//list[Makefile][Makefile]{
//}

== 命令のデコードと即値の生成

次に各命令がどのような意味を持つのかを、命令のビットをチェックすることで取得します。

RV32Iでは、次の形の命令フォーマットが定義されています。
ここに各形式の簡単な説明。

デコード処理を書く前に、デコードの結果生成する列挙子と構造体を@<code>{src/ctrl.veryl}に定義します。

まず、形式を示すenumを作成します。

次に、命令がどのような操作を行うかを示す構造体を作成します。

追加で、構造体を引数にとって、それがどのような命令であるかを判別する関数を作成しておきます。

それでは、命令のデコード処理を書きます。
デコーダとして、@<code>{src/decode.veryl}を定義します。

decodeモジュールでは、受け取った命令のOPビットを確認し、その値によってInstType, InstCtrl, 即値を設定しています。
処理の振り分けにはcase文を使用しています。

decodeモジュールをcoreモジュールでインスタンス化します。
命令のデコード結果を表示し、次のように表示されているか確認してください。

== レジスタの定義と読み込み

最初に説明した通り、RV32Iでは32ビット幅のレジスタが32個用意されています。
0番目のレジスタの値は常に0です。

coreモジュールに、レジスタを定義します。
初期値を0に設定しておきます。

RV32Iの命令は、最大で2個のレジスタの値を同時に読み出します。
命令の中のレジスタのアドレスを示すビットの場所は共通で、rs1, rs2, rdで示されています。
このうち、rs1, rs2はソースレジスタ、rdはディスティネーションレジスタ(結果の書き込み先)です。

簡単のために、命令がレジスタを使用するか否かにかかわらず、常にレジスタの値を読み出すことにします。
0番目のレジスタが指定されたときは、レジスタを読み込まずに0を読み込んでいます。

== ALU

ALUとは、Arithmetic Logic Unitの略で、CPUの計算を行う部分です。
ALUは足し算や引き算、シフト命令などの計算を行います。
ALUでどの計算を行うかは、funct3, funct5によって判別します。

@<code>{alu.veryl}を作成し、次のように記述します。

プログラム

ポート定義

coreモジュールでaluモジュールをインスタンス化します。

== ロード、ストア命令

=== LW, SW命令
RISC-Vにはメモリのデータを読み込む/書き込む命令として次の命令があります。

表

これらの命令で指定するメモリのアドレスは足し算です。
先ほど作ったALUは、ALUを使用する命令ではない場合は常に足し算を行うため、ALUの結果をアドレスとして利用できます。

まず32ビット単位で読み書きを行うLW, SW命令を実装します。

メモリ操作を行うモジュールを@<code>{memunit.veryl}に定義します。

プログラム

memunitモジュールでは、命令がメモリ命令の時、ALUから受け取ったアドレスをメモリに渡して操作を実行します。
書き込み命令の時は、書き込む値をmemif.wdataに設定し、memif.wenを1に設定します。

memunitモジュールをcoreモジュールにインスタンス化します。
ここで、memunitモジュールとメモリの接続は、命令フェッチ用のインターフェースとは別にしなくてはいけません。
そのため、coreモジュールに新しくmemif_dataを定義し、これをmemunitモジュールと接続します。

これでtopモジュールにはロードストア命令と命令フェッチのインターフェースが2つ存在します。
しかし、メモリは同時に1つの読み込みまたは書き込みしかできないため、これを調停する必要があります。

topモジュールに、ロードストアと命令フェッチが同時に要求した場合は、ロードストアを優先するプログラムを記述します。

ロードストアには複数クロックかかるため、これが完了していないことを示すワイヤがあります。
これを見て、coreは処理を進めます。

アラインの例外について注記を入れる

=== LH[U], LB[U], SH, SB命令

ロード、ストア命令には、2バイト単位, 1バイト単位での読み書きを行う命令も存在します。

まずロード命令を実装します。
ロード命令は32bit単位での読み込みをしたものの一部を切り取ってあげればよさそうです。

プログラム

次に、ストア命令を実装します。
ここで32ビット単位で読み込んだ後に一部を書き換えて書き込んであげる方法、
またはメモリモジュール側で一部のみを書き込む操作をサポートする方法が考えられます。
本書では後者を採用します。

memifインターフェースに、どこの書き込みを行うかをバイト単位で示すワイヤを追加します。

プログラム

これを利用して、読み込みして加工して書き込みという操作をサポートさせます。

プログラム

== レジスタに値を書き込む

CPUはレジスタから値を読み込み、これを計算して、レジスタに結果の値を書き戻します。
レジスタに値を書き戻すことを、ライトバックと言います。

=== ライトバックの実装

計算やメモリアクセスが終わったら、その結果をレジスタに書き込みます。
書き込む対象のレジスタはrd番目のレジスタです。
書き込むかどうかはInstCtrl.reg_wenで表されます。

プログラム

=== ライトバックのテスト

ここで、プログラムをテストしましょう。

メモリに格納されている命令は～なので、結果が～になることを確認できます。

== 分岐, ジャンプ

まだ、重要な命令を実装できていません。
分岐命令とジャンプ命令を実装します。

=== JAL, JALR命令

JAL(Jump And Link)命令は相対アドレスでジャンプ先を指定し、ジャンプします。
ジャンプ命令である場合はPCの次の値をPC + 即値に設定するようにします。
Linkとあるように、rdレジスタに現在のPC+4を格納します。

プログラム

JALR(Jump And Link Register)命令は、レジスタに格納されたジャンプ先にジャンプします。
レジスタの値と即値を加算し、次のPCに設定します。
JAL命令と同様に、rdレジスタに現在のPC+4を格納します。

プログラム

=== 分岐命令

分岐命令には次の種類があります。
全ての分岐命令は相対アドレスで分岐先を指定します。

分岐するかどうかの判定を行うモジュールを作成します。

プログラム

alubrモジュールの＊が1かつ、分岐命令である場合、PCをPC+即値に指定します。
分岐しない場合はそのままです。

== riscv-testsでテストする

古いのをappendixにする。

riscv-testsは、RISC-VのCPUが正しく動くかどうかを検証するためのテストセットです。
これを実行することでCPUが正しく動いていることを確認します。

riscv-testsのビルド方法については付録を参考にしてください。

=== 最小限のCSR命令の実装

riscv-testsを実行するためには、いくつかの制御用のレジスタ(CSR)と、それを読み書きする命令(CSR命令)が必要になります。
それぞれの命令やレジスタについて、本章では深く立ち入りません。

==== mtvec

==== ecall命令

==== mret命令

=== 終了検知

riscv-testsが終了したことを検知し、それが成功か失敗かどうかを報告する必要があります。

riscv-testsは終了したことを示すためにメモリのあああ番地に値を書き込みます。
この値が1のとき、riscv-testsが正常に終了したことを示します。
それ以外の時は、riscv-testsが失敗したことを示します。

riscv-testsの終了の検知処理をtopモジュールに記述します。

プログラム

=== テストの実行

試しにaddのテストを実行してみましょう。
add命令のテストはrv32ui-p-add.bin.hexに格納されています。
これを、メモリのreadmemhで読み込むファイルに指定します。

プログラム

ビルドして実行し、正常に動くことを確認します。

==== 複数のテストを自動で実行する

add以外の命令もテストしたいですが、そのためにreadmemhを書き換えるのは大変です。
これを簡単にするために、readmemhにはマクロで指定する定数を渡します。

プログラム

自動でテストを実行し、その結果を報告するプログラムを作成します。

プログラム

このPythonプログラムは、riscv-testsフォルダにあるhexファイルについてテストを実行し、結果を報告します。
引数に対象としたいプログラムの名前の一部を指定することができます。

今回はRV32Iのテストを実行したいので、riscv-testsのRV32I向けのテストの接頭辞であるrv32ui-p-引数に指定すると、次のように表示されます。
