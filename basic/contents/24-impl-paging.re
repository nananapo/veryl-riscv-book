= S-modeの実装 (2. 仮想記憶システム)

== 概要

=== 仮想記憶システム

TODO 図

仮想記憶(Virtual Memory)とは、メモリを管理する手法の一種です。
論理的なアドレス(logical address、論理アドレス)を物理的なアドレス(physical address、物理アドレス)に変換することにより、
実際のアドレス(real address、実アドレス)空間とは異なる仮想的なアドレス(virtual address、仮想アドレス)空間を提供することができます。

仮想記憶を利用すると、次のような動作を実現できます。

 1. 連続していない物理アドレス空間を仮想的に連続したアドレス空間として扱う。
 1. 特定のアドレスにしか配置できない(特定のアドレスで動くことを前提としている)プログラムを、そのアドレスとは異なる物理アドレスに配置して実行する。
 1. アプリケーションごとにアドレス空間を分離する。

一般的に仮想記憶システムはハードウェアによって提供されます。
メモリアクセスを処理するハードウェア部品のことをメモリ管理ユニット(Memory Management Unit, MMU)と呼びます。

=== ページング方式

図

仮想記憶システムを実現する方式の1つにページング方式(Paging)があります。
ページング方式は、物理アドレス空間の一部をページ(Page)という単位に割り当て、
ページテーブル(Page Table)にページを参照するための情報を格納します。
ページテーブルに格納する情報の単位のことをページテーブルエントリ(Page Table Entry)と呼びます。
論理アドレスから物理アドレスへの変換はページテーブルにあるページテーブルエントリを参照して行います。
これ以降、ページテーブルエントリのことをPTEと呼びます。

RISC-Vの仮想記憶システムはページング方式を採用しており、
RV32I向けにはSv32、RV64I向けにはSv39、Sv48、Sv57が定義されています。

TODO 図

本章で実装するSv39のアドレス変換を簡単に説明します。

(a) satpレジスタのPPNフィールドと論理アドレスのフィールドからPTEの物理アドレスを作る。
(b) PTEを読み込む。PTEが有効なものか確認する。
(c) PTEがページを指しているとき、PTEに書かれている権限を確認してから最終的な物理アドレスを作る。
(d) PTEが次のPTEを指しているとき、PTEのフィールドと論理アドレスのフィールドから次のPTEの物理アドレスを作る。(b)に戻る。

satpレジスタは仮想記憶システムを制御するためのCSRです。
一番最初に参照するPTEのことをroot PTEと呼びます。
また、PTEがページを指しているとき、そのPTEのことをleaf PTEと呼びます。

TODO 図

このようにsatpレジスタと論理アドレス、PTEを使って多段階のメモリアクセスを行って論理アドレスを物理アドレスに変換します。
Sv39の場合、何段階で物理アドレスに変換できるかによってページサイズは4KiB、2MiB、1GiBと異なります。
これ以降、MMU内のページング方式を実現する部品のことをPTW(Page Table Walker)と呼びます@<fn>{ptw}。

//footnote[ptw][ページテーブルをたどってアドレスを変換するのでPage Table Walkerと呼びます。アドレスを変換することをPage Table Walkと呼ぶこともあります。]

=== satpレジスタ、アドレス変換プロセス

==== satpレジスタ

TODO satp

RISC-Vの仮想記憶システムはsatpレジスタによって制御します。

MODEは仮想アドレスの変換方式を指定するフィールドです。
方式と値はTODOテーブルのように対応しています。
MODEがBare(@<code>{0})のときはアドレス変換を行いません(仮想アドレス=物理アドレス)。

TODO テーブル

ASID(Address Space IDentifier)は仮想アドレスが属するアドレス空間のIDです。
動かすアプリケーションによってIDを変えることでMMUにアドレス変換の高速化のヒントを与えることができます
本章ではASIDを無視したアドレス変換を実装します@<fn>{tlb}。

//footnote[tlb][PTWはページエントリをキャッシュすることで高速化できます。ASIDが異なるときのキャッシュは利用することができません。キャッシュ機構(TLB)は応用編で実装します。]

TODO 図 (Sv39)

PPN(Physical Page Number)はroot PTEの物理アドレスの一部を格納するフィールドです。
root PTEのアドレスは仮想アドレスのVPNビットと組み合わせて作られます(TODO 図)。

==== アドレス変換プロセス (Sv39)

Sv39の仮想アドレスは次の方法によって物理アドレスに変換されます@<fn>{access-fault}。

//footnote[access-fault][RISC-VのMMUはPMP、PMAという仕組みで物理アドレス空間へのアクセスを制限することができ、それに違反した場合にアクセスフォルト例外を発生させます。本章ではPMP、PMAを実装していないのでアクセスフォルト例外に関する機能について説明せず、実装もしません。これらの機能は応用編で実装します。]

TODO プロセス

基本的にアドレス変換はS-mode、U-modeで有効になります。
TODO ここで説明
mstatusレジスタのMXR、SUM、MPRVビットを利用すると、プロセスTODOの特権レベル、PTEの権限について挙動を少し変更できます。
これらのビットについては実装するときに解説します。

アドレスの変換途中でPTEが不正な値だったり、ページが求める権限を持たずにページにアクセスにアクセスしようとした場合、
アクセスする目的に応じたページフォルト(Page fault)例外が発生します。
命令フェッチはInstruction page fault例外、ロード命令はLoad page fault例外、ストアとAMO命令はStore/AMO page fault例外が発生します。

=== 実装順序

図

RISC-Vでは命令フェッチ、データのロードストアの両方でページングを利用できます。
命令フェッチ、データのロードストアのそれぞれのために2つのPTWを用意してもいいですが、
シンプルなアーキテクチャにするために本章では1つのPTWを共有することにします。
inst_fetcherモジュール、amounitモジュールは仮想アドレスを扱うことがありますが、
mmio_controllerモジュールは常に物理アドレス空間を扱います。
そのため、inst_fetcherモジュール、amounitモジュールとmmio_controllerモジュールの間にPTWを配置します(図TODO)。

TODO 図

本章では、仮想記憶システムを次の順序で実装します。

 1. 例外を伝達するインターフェースを実装する
 1. Bareにだけ対応したアドレス変換モジュールを実装する
 1. satpレジスタ、mstatusのMXR、SUM、MPRVビットを作成する
 1. Sv39を実装する
 1. SFENCE.VMA命令、FENCEI命令を実装する

== メモリインターフェースの例外の実装

PTWで発生した例外は、最終的にcsrunitモジュールで処理します。
そのために、例外の情報をメモリのインターフェースを使って伝達します。

=== 例外を伝達する


@<code>{}

=== 例外の発生アドレスを特定する

== satpレジスタの作成

== アドレス変換モジュール(PTW)の作成

== mstatusのMXR、SUM、MPRVビットの作成

== Sv39の実装

=== pte

=== ptw

=== パイプラインのフラッシュ

TODO ↓ここに移動
satp、mstatusレジスタの変更の対応
fencei

== SFENCE.VMA命令の実装

=== SFENCE.VMA命令を実装する

=== mstatus.TVMの実装

== FENCE.I命令の実装