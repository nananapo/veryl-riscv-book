= CPUのパイプライン処理化

これまでの章では、
同時に1つの命令のみを実行するCPUを実装しました。
高機能なCPUを実装するのは面白いですが、
プログラムの実行が遅くてはいけません。
機能を増やす前に、一度性能のことを考えてみましょう。

== CPUの性能を考える

CPUの性能指標は、
例えば消費電力や実行速度が考えられます。
本章では、プログラムの実行速度について考えます。

=== CPUの性能指標

プログラムの実行速度を比較する時、
プログラムの実行にかかる時間のみが絶対的な指標になります。
プログラムの実行時間は、簡単に、次のような式で表すことができます@<bib>{patahene}。

//texequation[][]{
CPU時間 = \frac{実行命令数 \times CPI}{クロック周波数}
//}

それぞれの用語の定義は次の通りです。

 : CPU時間 (CPU time)
    プログラムの実行のためにCPUが費やした時間

 : 実行命令数
    プログラムの実行で実行される命令数

 : CPI (clock cycles per instruction)
    プログラム全体またはプログラムの一部分の命令を実行した時の,
    1命令当たりの平均クロック・サイクル数

 : クロック周波数 (clock rate)
    クロック・サイクル時間(clock cycle time)の逆数

今のところ、CPUには命令をスキップしたり無駄に実行することはありません。
そのため、実行命令数はプログラムを1命令ずつ順に実行していった時の実行命令数になります。

CPIを計測するためには、
何の命令にどれだけのクロック・サイクル数がかかるかと、
それぞれの命令の割合が必要です。
メモリにアクセスする命令は3~4クロック、
それ以外の命令は1クロックで実行されます。
命令の割合については考えないでおきます。

クロック周波数は、CPUの回路のクリティカルパスの長さによって決まります。
クリティカルパスとは、組み合わせ回路の中で最も大きな遅延を持つパスのことです。

=== 実行速度を上げる方法を考える

CPU性能方程式の各項に注目すると、
CPU時間を減らすためには、
実行命令数を減らすか、
CPIを減らすか、
クロック周波数を増大させる必要があります。

==== 実行命令数に注目する

実行命令数を減らすためには、
コンパイラによる最適化でプログラムの命令数を減らすソフトウェア的な方法と、
命令セットアーキテクチャ(ISA)を変更することで必要な命令数を減らす方法が存在します。
どちらも本書の目的とするところではないので、検討しません@<fn>{other.runinst}。

//footnote[other.runinst][他の方法として、関数呼び出しやループをCPU側で検知して結果を保存, 利用することで実行命令数を減らす手法があります。この手法についてはずっと後の章で検討します。]

==== CPIに注目する

CPIを減らすためには、
1クロックで1つ以上の命令を実行開始し、1つ以上の命令を実行完了すればいいです。
これを実現する手法として、
スーパースカラやアウトオブオーダー実行が存在します。
これらの手法は後の章で解説, 実装します。

==== クロック周波数に注目する

クロック周波数を増大させるには、
クリティカルパスの長さを短くする必要があります。

今のところ、CPUは計算命令を1クロック(@<b>{シングルサイクル})で実行します。
例えばADD命令を実行する時、
FIFOに保存されたADD命令をデコードし、
命令のビット列をもとにレジスタのデータを選択し、
ALUで足し算を実行し、
その結果をレジスタにライトバックします。
これらを1クロックで実行するということは、
命令が保存されている32ビットのレジスタとレジスタファイルを入力に、
64ビットのADD演算の結果を出力する組み合わせ回路が存在するということです。
この回路は大変に段数の深い組み合わせ回路を必要とし、
長いクリティカルパスを生成する原因になります。

クロック周波数を増大させるもっとも単純な方法は、
命令の処理をいくつかの@<b>{ステージ(段)}に分割し、
複数クロックで1つの命令を実行することです。
複数のサイクルで命令を実行することから、
この形式のCPUは@<b>{マルチサイクル}CPUといいます。

//image[multicycle][命令の実行 (マルチサイクル)]

命令の処理をいくつかのステージに分割すると、
それに合わせて回路の深さが軽減され、
クロック周波数を増大させることができます。

@<img>{multicycle}では、
1つの命令を3クロック(ステージ)で実行しています。
3クロックもかかるのであれば、
CPIが3倍になり、
CPU時間が増えてしまいそうです。
しかし、処理を均等な3ステージに分割できた場合、
クロック周波数は3分の1になる@<fn>{multicycle.clock}ため、
それほどCPU時間は増えません。

//footnote[multicycle.clock][実際のところは均等に分割することはできないため、Nステージに分割してもクロック周波数はN分の1になりません]

しかし、CPIがステージ分だけ増大してしまうのは問題です。
これは、命令の処理を車の組立のように流れ作業で行うことで緩和することができます。
このような処理のことを、@<b>{パイプライン処理}と言います。

//image[pipeline][命令の実行 (パイプライン処理)]

本章では、
CPUをパイプライン処理化することで、
性能の向上を図ります。

=== パイプライン処理のステージについて考える

では、具体的に処理をどのようなステージに分割し、パイプライン処理を実現すればいいでしょうか?
これを考えるために、@<chap>{04-impl-rv32i}の最初で検討したCPUの動作を振り返ります。
@<chap>{04-impl-rv32i}では、CPUの動作を次のように順序付けしました。

 1. PCに格納されたアドレスにある命令をフェッチする
 2. 命令を取得したらデコードする
 3. 計算で使用するデータを取得する (レジスタの値を取得したり、即値を生成する)
 4. 計算する命令の場合、計算を行う
 5. メモリにアクセスする命令の場合、メモリ操作を行う
 6. 計算やメモリアクセスの結果をレジスタに格納する
 7. PCの値を次に実行する命令に設定する

もう少し大きな処理単位に分割しなおすと、
次の5つの処理(ステージ)を構成することができます。
ステージ名の後ろに、それぞれ対応する上のリストの処理の番号を記載しています。

 : IF (Instruction Fetch) ステージ (1)
    メモリから命令をフェッチします。@<br>{}
    フェッチした命令をIDステージに受け渡します

 : ID (Instruction Decode) ステージ (2,3)
    命令をデコードし、制御フラグと即値を生成します。@<br>{}
    生成したデータをEXステージに渡します。

 : EX (EXecute) ステージ (3, 4)
    制御フラグ, 即値, レジスタの値を利用し、ALUで計算します。@<br>{}
    分岐判定やジャンプ先の計算も行い、生成したデータをMEMステージに渡します。

 : MEM (MEMory) ステージ (5, 7)
    メモリにアクセスする命令とCSR命令を処理します。@<br>{}
    分岐命令かつ分岐が成立する, ジャンプ命令である, またはトラップが発生するとき、
    IF, ID, EXステージにある命令をフラッシュして、ジャンプ先をIFステージに伝えます。
    メモリ, CSRの読み込み結果等をWBステージに渡します。

 : WB (WriteBack) ステージ (6)
    ALUの演算結果, メモリやCSRの読み込み結果など、命令の処理結果をレジスタに書き込みます。

IF, ID, EX, MEM, WBの5段の構成を、
5段パイプラインと呼ぶことがあります。

//note[CSRをMEMステージで処理する]{
上記の5段のパイプライン処理では、CSRの処理をMEMステージで行っています。
これはいったいなぜでしょうか？

今のところCPUにはECALL命令による例外しか存在しないため、
EXステージでCSRの処理を行ってしまっても問題ありません。
しかし、他の例外、例えばメモリアクセスに伴う例外を実装するとき、
問題が生じます。

メモリアクセスに起因する例外が発生するのはMEMステージです。
このとき、EXステージでCSRの処理を行っていて、
EXステージに存在する命令がmtvecレジスタに書き込むCSRRW命令だった場合、
本来はMEMステージで発生した例外によって実行されないはずであるCSRRW命令によって、
既にmtvecレジスタが書き換えられているかもしれません。
これを復元する機能を記述することを書くことはできますが、
MEMステージ以降でCSRを処理することでもこの事態を回避できるため、
無駄な複雑性を導入しないためにめに、MEMステージでCSRを処理しています。
//}

== パイプライン処理の実装

=== ステージに分割する準備

それでは、CPUをパイプライン処理化します。
処理を複数に

TODO

=== FIFOを作成する

=== IFステージ

=== IDステージ

=== EXステージ

=== MEMステージ

=== CSRステージ

=== WBステージ

== データハザードの対処

== パイプライン処理のテスト

== フォワーディング

=== フォワーディングのテスト
