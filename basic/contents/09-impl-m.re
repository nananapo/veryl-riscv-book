= M拡張の実装

== 概要

「第I部 RV32I / RV64Iの実装」ではRV64IのCPUを実装しました。
「第II部 RV64IMACの実装」では、基本的な整数演算しかできないRV64IのCPUに次のような機能を追加します。

 * 乗算、除算、剰余命令 (M拡張)
 * 不可分操作命令 (A拡張)
 * 圧縮命令 (C拡張)
 * 例外
 * Memory-mapped I/O
 * 可視化

また、CPUの性能を計測するプログラムを実行します。

本章では乗算、除算、剰余を求める命令を実装します。
RISC-Vの乗算、除算を行う命令はM拡張に定義されており、
M拡張を実装したRV64IのISAのことを@<code>{RV64IM}と表現します。

M拡張には、XLENが32のときは@<table>{m.instructions.32}の命令が定義されています。
XLENが64のときは@<table>{m.instructions.64}の命令が定義されています。

//table[m.instructions.32][M拡張の命令 (XLEN=32)]{
命令	動作
-------------------------------------------------------------
MUL		rs1(符号付き) × rs2(符号付き)の結果(64ビット)の下位32ビットを求める
MULHU	rs1(符号無し) × rs2(符号無し)の結果(64ビット)の上位32ビットを求める
MULHSU	rs1(符号付き) × rs2(符号無し)の結果(64ビット)の上位32ビットを求める
DIV		rs1(符号付き) / rs2(符号付き)を求める
DIVU	rs1(符号無し) / rs2(符号無し)を求める
REM		rs1(符号付き) % rs2(符号付き)を求める
REMU	rs1(符号無し) % rs2(符号無し)を求める
//}

//table[m.instructions.64][M拡張の命令 (XLEN=64)]{
命令	動作
-------------------------------------------------------------
MUL		rs1(符号付き) × rs2(符号付き)の結果(128ビット)の下位64ビットを求める
MULW	rs1[31:0](符号付き) × rs2[31:0](符号付き)の結果(64ビット)の下位32ビットを求める@<br>{}結果は符号拡張する
MULHU	rs1(符号無し) × rs2(符号無し)の結果(128ビット)の上位64ビットを求める
MULHSU	rs1(符号付き) × rs2(符号無し)の結果(128ビット)の上位64ビットを求める
DIV		rs1(符号付き) / rs2(符号付き)を求める
DIVW	rs1[31:0](符号付き) / rs2[31:0](符号付き)を求める@<br>{}結果は符号拡張する
DIVU	rs1(符号無し) / rs2(符号無し)を求める
DIVWU	rs1[31:0](符号無し) / rs2[31:0](符号無し)を求める@<br>{}結果は符号拡張する
REM		rs1(符号付き) % rs2(符号付き)を求める
REMW	rs1[31:0](符号付き) % rs2[31:0](符号付き)を求める@<br>{}結果は符号拡張する
REMU	rs1(符号無し) % rs2(符号無し)を求める
REMUW	rs1[31:0](符号無し) % rs2[31:0](符号無し)を求める@<br>{}結果は符号拡張する
//}

Verylには乗算、除算、剰余を求める演算子@<code>{*}、@<code>{/}、@<code>{%}が定義されており、
これを利用することで簡単に計算を実装することができます(@<list>{example.by.operator})。

//list[example.by.operator][演算子による実装例]{
assign mul = op1 * op2;
assign div = op1 / op2;
assign rem = op1 % op2;
//}

例えば、乗算回路をFPGA上に実装する場合、通常は合成系によってFPGAに搭載されている乗算器が自動的に利用されます。
これにより、低遅延、低リソースコストで効率的な乗算回路が実現できます。
しかし、32ビットや64ビットの乗算を実装する際、
FPGA上の乗算器の数が不足すると、LUTを用いた大規模な乗算回路が構築されることがあります。
このような大規模な回路は、FPGAのリソースの使用量や遅延に大きな影響を与えるため好ましくありません。
同様に、除算や剰余演算でも同じ問題が生じることがあります。

@<code>{*}、@<code>{/}、@<code>{%}演算子がどのような回路に合成されるかは、
合成系が全体の実装を考慮して自動的に決定するため、
その挙動をコントロールするのは難しいです。
そこで本章では、@<code>{*}、@<code>{/}、@<code>{%}演算子を使用せず、
足し算やシフト演算などの基本的な論理だけを用いて同等の演算を実装します。

== MUL、MULH[[S]U]、MULW命令の実装

=== MULHU命令の実装

 1. 筆算をそのまま実行するかけ算モジュールを作成する

=== MUL、MULH命令の実装

 1. 正 * 正に変更して計算、符号を戻す
 2. (-A[msb] * 2**63 + A[msb-1:lsb]) * (-B[msb] * 2**63 + B[msb-1:lsb])を展開して計算する

=== MULHSU命令の実装

 1. 65ビットの演算にして、符号拡張の方法によって実装する

=== MULW命令の実装

 1. 符号拡張する

付録でやる？
 1. 並列
 2. 1ビットの加算器で構成?
 3. ウォレス木で構成する?
 4. パイプライン化する?


== DIV[U]、DIV[U]W、REM[U]、REM[U]W命令の実装

 1. 筆算をそのまま実行する割り算モジュールを作成する
 2. 引き放し法を使う