= A拡張の実装

本章では、メモリの不可分操作を実現するA拡張を実装します。
A拡張にはLoad-Reserved、Store Conditionalを実現するZalrsc拡張(TODO table)、
ロードした値を加工した値をメモリにストアする操作を単一の命令で実装するZaamo拡張(TODO table)が含まれています。
A拡張の命令を利用すると、同じメモリ空間で複数のソフトウェアが並列、並行して実行されるとき、
ソフトウェア間で同期をとりながら実行することができます。

== アトミック操作

=== アトミック操作とは何か？
アトミック操作(Atomic operation、不可分操作)とは、他のシステムからその操作を観測するとき、1つの操作として観測される操作のことです。
つまり、他のシステムからは、アトミック操作を行う前、アトミック操作を行った後の状態しか観測することができません。

アトミック操作は実行、観測される順序が重要なアプリケーションで利用します。
例えば1からNまでの和を求めるプログラムを考えます(図TODO)。
2つのコアで同時にアドレスX、またはYの値を変更しようとするとき、
命令の実行順序によって最終的な値が1つのコアで実行した場合と異なってしまいます。
この状態を避けるためにはロード、加算、ストアをアトミックに行う必要があります。
このアトミック操作の実現方法として、A拡張はAMOADD命令、LR命令とSC命令を提供します。

=== Zaamo拡張

AMOADD命令はロード、加算、ストアを行う単一の命令です。
Zaamo拡張は他の簡単な操作を行う命令も提供しています。

TODO table

=== Zalrsc拡張

LR命令とSC命令はそれぞれLoad-Reserved、Store Conditional操作を実現する命令です。
LR、SC命令はそれぞれ次のように動作します。

 : LR命令
   指定されたアドレスのデータを読み込み、予約セット(Reservation set)に指定されたアドレスを登録します。

 : SC命令
   予約セットに指定されたアドレスが存在する場合、指定されたアドレスにデータを書き込みます(ストア成功)。
   予約セットにアドレスが存在しない場合は書き込みません(ストア失敗)。
   ストアに成功したら@<code>{0}、失敗したら@<code>{0}以外の値をレジスタにライトバックします。
   命令の実行後に必ず予約セットを空にします。

LR、SC命令を使うことで、アトミックなロード、加算、ストアを次のように記述できます
()。

//list[][]{
//}

同時に他のコアが同じプログラムを実行するとき、間違った値の書き込みはSC命令で失敗します。
失敗したらLR命令からやり直すことで、1つのコアで実行した場合と同一の結果になります。

予約セットのサイズは実装によって異なります。

== 命令の順序

A拡張の命令のビット列は、それぞれ1ビットのaq、rlビットを含んでいます。
このビットは、他のコアやハードウェアスレッドからメモリ操作を観測したときにメモリ操作がどのような順序で観測されるかを制御するものです。

A拡張の命令をAとするとき、それぞれのビットの状態に応じて、Aによるメモリ操作は次のように観測されます。

 : aq=0、rl=0
    Aの前後でメモリ操作の順序は保証されません。
 : aq=1、rl=0
    Aの後ろにあるメモリを操作する命令は、Aのメモリ操作の後に観測されることが保証されます。
 : aq=0、rl=0
    Aのメモリ操作は、Aの前にあるメモリを操作する命令が観測できるようになった後に観測されることが保証されます。
 : aq=1、rl=1
    Aのメモリ操作は、Aの前にあるメモリを操作する命令よりも後、Aの後ろにあるメモリを操作する命令よりも前に観測されることが保証されます。

TODO それぞれの図

今のところ、CPUはメモリ操作を１命令ずつ直列に実行するため、常にaq=1、rl=1であるように動作します。
そのため、本章ではaq、rlビットを考慮しないで実装を行います@<fn>{impl-memory-order}。

//footnote[impl-memory-order][メモリ操作の並び替えによる高速化は応用編で検討します。]

== amounitモジュールの作成

A拡張は他のコア、ハードウェアスレッドと同期してメモリ操作を行うためのものであるため、
A拡張の操作はcoreモジュールの外、メモリよりも前で行うのが好ましいです。
具体的には、coreモジュールとmmio_controllerモジュールの間にA拡張の命令を処理するモジュールを追加、実装します。

TODO
 RAMを外に出す→topから消すのをやめる

メモリ操作をcoreモジュールからそのままmmio_controllerモジュールに受け渡しするだけのモジュールを作成します。
@<code>{src/amounit.veryl}を作成し、次のように記述します
()。

//list[][]{
//}

TODO amounitはconnectではなくステートを持たせる

amounitモジュールをtopモジュールでインスタンス化して、coreモジュールとmmio_controllerモジュールのインターフェースを接続します
()。

== 命令のデコード

TODO 命令の図

A拡張の命令のopcodeはすべてOP-AMO(@<code>{7'b0101111})です(TODO 図)。
それぞれの命令はfunct5とfunct3で区別することができます(TODO テーブル)。

TODO funct5と命令の対応のテーブル

=== is_amoフラグを実装する

@<code>{InstCtrl}構造体に、
A拡張の命令であることを示す@<code>{is_amo}フラグを追加します 
()。

//list[][is_amoフラグを追加する (corectrl.veryl)]{
//}

また、A拡張の命令を区別するための列挙型を定義します
()。
それぞれ、命令のfunct5と対応していることを確認してください。

//list[][]{
//}

inst_decoderモジュールの@<code>{InstCtrl}を生成している部分を変更します。
opcodeが@<code>{OP-AMO}のとき、@<code>{is_amo}を@<code>{T}に設定します
()。
その他のopcodeの@<code>{is_amo}は@<code>{F}に設定してください。

//list[][is_amoフラグを追加する (corectrl.veryl)]{
//}

また、A拡張の命令が有効な命令として判断されるようにします
()。

//list[][A拡張の命令のとき、validフラグを立てる]{
//}

=== アドレスを変更する

A拡張でアクセスするメモリのアドレスはrs1で指定されたレジスタの値です。
これはRV64Iのロードストア命令で使用するrs1と即値を足し合わせたものとは異なるため、
memunitモジュールの@<code>{addr}ポートに割り当てる値を@<code>{is_amo}フラグによって切り替えます
()。

TODO ここでmemu_addrを作る

//list[][core]{
//}

=== メモリインターフェースを変更する

amounitモジュールにA拡張の操作を指示するために、データ用のメモリインターフェースに変更が必要です。
memunitモジュールとamounitモジュールの間のインターフェースを新しく定義します。

membus_ifインターフェースに@<code>{is_amo}フラグ、@<code>{aq}ビット、@<code>{rl}ビット、@<code>{AMOOp}型を追加で定義したインターフェースを作成します。
@<Code>{src/core_data_if.veryl}を作成し、次のように記述します
()。
@<code>{wmask}を@<code>{DATA_WIDTH}ビットに展開する関数も定義しています。

//list[][]{
//}

memunitモジュールからamounitモジュールへの接続でcore_data_ifを使用するように変更します
()。

memunitモジュールで、@<code>{is_amo}、@<code>{aq}、@<code>{rl}、@<code>{amoop}に値を割り当てます
()。

== Zalrsc拡張の実装

予約セットのサイズは実装が自由に決めることができるため、
本書では1つのアドレスのみ保持できるようにします。

=== LR.W、LR.D命令を実装する

32ビット幅、64ビット幅のLR命令を実装します。
LR.W命令はmemunitモジュールで64ビットに符号拡張されるため、
amounitモジュールでLR.W命令とLR.D命令を区別する必要はありません。

amounitモジュールに予約セットを作成します
()。

//list[][]{ 
//}

//list[][]{ 
//}

LR命令を実行するとき、予約セットにアドレスを登録し、ロード結果を返すようにします。

//list[][]{ 
//}

//list[][]{ 
//}

=== SC.W、SC.D命令を実装する

32ビット幅、64ビット幅のSC命令を実装します。
SC.W命令はmemunitモジュールで書き込みマスクを設定しているため、
amounitモジュールでSC.W命令とSC.D命令を区別する必要はありません。

SC命令が成功、失敗したときに結果を返すための状態をState型に追加します
()。

//list[][]{
//}

それぞれの状態で結果を返し、新しく要求を受け入れるようにします
()。
@<code>{State::SCSuccess}はSC命令に成功してストアが終わったときに結果を返します。

//list[][]{
//}

//list[][]{
//}

SC命令を受け入れるときに予約セットを確認し、アドレスが予約セットのアドレスと異なる場合は状態を@<code>{State::SCFail}に移動させます
()。

//list[][]{
//}

SC命令でメモリの@<code>{ready}が@<code>{1}になるのを待っているとき、
@<code>{ready}が@<code>{1}になったら状態を@<code>{State::SCSuccess}に移動させます
()。

TODO 遷移がおかしいね (WaitReady)

//list[][]{
//}

== Zaamo拡張の実装

Zaamo拡張の命令はロード、演算、ストアを行います。

32ビット演算と64ビット演算を区別するために、core_data_ifインターフェースに@<code>{is_op32}フラグを追加します
()。

//list[][core_data_if]{
//}

//list[][memunit]{
//}

Zaamo拡張の命令かどうかを判定する関数を作成します
()。

//list[][]{
//}


ロードしたデータと@<code>{wdata}、フラグを利用して、ストアする値を生成する関数を作成します
()。

//list[][]{
//}

=== Zaamo拡張の命令を実装する

TODO 図

Zaamo拡張の命令をTODO図のような状態遷移で処理するようにします。
@<code>{is_zaamo_fetched}はロード済かを示すフラグで、
@<code>{zaamo_fetched_data}はロードしたデータを保存するレジスタです。

@<code>{is_zaamo_fetched}と@<code>{zaamo_fetched_data}レジスタを作成します
。

//list[][]{
//}

//list[][reset]{
//}

TODO図に基づいてメモリへのロード、ストア要求を割り当てます
()。

//list[][]{
//}

TODO図に基づいて状態を遷移させます
()。

//list[][]{
//}

ストアが完了したら結果を返し、新しく要求を受け入れます
()。

//list[][]{
//}

