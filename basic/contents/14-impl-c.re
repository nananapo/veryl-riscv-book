= C拡張の実装

== 概要

これまでに実装した命令はすべて32ビット幅のものでした。
RISC-Vには32ビット幅以外の命令が定義されており、
それぞれ命令の下位ビットで何ビット幅の命令か判断できます(TODO 図)。

TODO 図

C拡張は16ビット幅の命令を定義する拡張です。
よく使われる命令の幅を16ビットに圧縮できるようにすることでコードサイズを削減できます。
これ以降、C拡張によって導入される16ビット幅の命令のことをRVC命令と呼びます。

全てのRVC命令には同じ操作をする32ビット幅の命令が存在します@<fn>{zc-pseudo}。

//footnote[zc-pseudo][Zc*拡張の一部の命令は複数の命令になります]

RV32IのCPUに実装されるC拡張には表TODOのRVC命令が定義されています。
RV64IのCPUに実装されるC拡張には表TODOに加えて表TODOのRVC命令が定義されています。
一部のRV32IのRVC命令はRV64Iで別の命令に置き換わっていることに注意してください。

表TODO
表TODO

C拡張は浮動小数点命令をサポートするF、D拡張が実装されている場合に他の命令を定義しますが、
基本編ではF、D拡張を実装しないため解説しません。

== IALIGNの変更

TODO 図

@<secref>{11-impl-exception|def-ialign}で解説したように、
命令はIALIGNビットに整列したアドレスに配置されます。
C拡張はIALIGNによる制限を16ビットに緩め、全ての命令が16ビットに整列されたアドレスに配置されるように変更します。
これにより、RVC命令と32ビット幅の命令の組み合わせがあったとしても効果的にコードサイズを削減できます(TODO 図)。

eeiパッケージのIALIGNを変更します
()。

//list[][]{
//}

mepcレジスタの書き込みマスクを変更して、
トラップ時のジャンプ先アドレスに16ビットに整列されたアドレスを指定できるようにします
()。
mtvecレジスタの下位2ビットはモードを指定するために使用されているため、変更の必要はありません。

//list[][]{
//}

命令アドレスのミスアライン例外の判定を変更します。
IALIGNが16の場合は例外が発生しないようにします
()。
ジャンプ、分岐命令は2バイト単位のアドレスしか指定できないため、
C拡張が実装されている場合には例外が発生しません。

//list[][]{
//}

== 実装方針

本章では次の順序でC拡張を実装します。

1. 命令フェッチ処理をcoreモジュールから分離する
2. 16ビットに整列されたアドレスに配置された32ビット幅の命令を処理できるようにする
3. RVC命令を32ビット幅の命令に変換するモジュールを作成する
4. RVC命令をIFステージで扱えるようにする

最終的な命令フェッチ処理の構成は図TODOのようになります。

TODO core <-> inst_fetcher <-> memの図

== 命令フェッチモジュールの実装



=== 既存の動作を実現する

=== 16ビット境界に配置された32ビット幅の命令をサポートする

== RVC命令のデコード

=== 圧縮命令を32ビット幅の命令に変換する

=== 圧縮命令フラグを実装する

interfaceやら
coreやら
インスタンス化してつなぐ
