= M-modeの実装 (1. CSRの実装)

== 概要

「第II部 RV64IMACの実装」では、RV64IMACと例外、メモリマップドI/Oを実装しました。
「第III部 特権/割り込みの実装」では、次のような機能を実装します。

 * 特権レベル (M-mode、S-mode、U-mode)
 * 仮想記憶システム(ページング)
 * 割り込み(CLINT、PLIC)

これらの機能を実装したCPUはOSを動かすための十分な機能を持っています。
第III部の最後ではLinuxを動作させます。

=== 特権レベルとは何か？

CPUで動くアプリケーションは様々ですが、
多くのアプリケーションはOS(Operating System、オペレーティングシステム)の上で動くように作成されています。
「OSの上で動く」とは、アプリケーションはOSの機能を使い、OSに管理されながら実行されるということです。

多くのOSはデバイスやメモリなどのリソースの管理を行い、簡単にそれを扱うためのインターフェースをアプリケーションに提供します。
また、アプリケーションのデータを別のアプリケーションから保護したり、OSが提供する方法でしかデバイスにアクセスできなくするセキュリティ機能も備えています。

セキュリティ機能を実現するためには、OSがアプリケーションを実行するときにCPUが提供する一部の機能を制限する機能が必要です。
RISC-Vでは、この機能を特権レベル(privilege level)という機能、枠組みによって提供しています。
ほとんどの特権レベルの機能はCSRを通じて提供されます。

特権レベルは次の3種類@<fn>{virtualization}が用意されています(TODO table)。
それぞれの特権レベルは2ビットの数値で表すことができます。

TODO table

//footnote[virtualization][V拡張が実装されている場合、さらに仮想化のための特権レベルが定義されます。]

高い特権レベルには低い特権レベルの機能を制限する機能があったり、高い特権レベルでしか利用できない機能が定義されています。

=== 特権レベルの実装順序

RISC-VのCPUに特権レベルを実装するとき、TODOテーブルのいずれかの構成にする必要があります。
特権レベルを実装していないときはM-modeだけが実装されているように扱います。

TODO M, MU, MSUテーブル

本章ではM-mode向けのCSRの一部を実装します。
実装する機能、レジスタと章の対応は表TODOの通りです

table 実装する機能とレジスタと章の対応

=== XLENの定義

M-modeのCSRの多くは、特権レベルがM-modeのときのXLENであるMXLENをビット幅として定義されています。
S-mode、U-modeのときのXLENはそれぞれSXLEN、UXLENと定義されており、MXLEN >= SXLEN >= UXLENを満たす必要があります。
仕様上はmstatusレジスタを使用してSXLEN、UXLENを変更できるように実装できますが、
本書ではMXLEN、SXLEN、UXLENが常に64(eeiパッケージに定義しているXLEN)になるように実装します。

== CSRのアドレスの定義

本書で実装するM-modeのCSRのアドレスをすべて定義します
()。

//list[][]{
//}

== misaレジスタ (Machine ISA)

TODO 図

misaレジスタは、ハードウェアスレッドがサポートするISAを表すMXLENビットのレジスタです。
MXLフィールドにはMXLENを表す数値(table TODO)が格納されています。
Extensionsフィールドは下位ビットからそれぞれアルファベットのA、B、 Cと対応していて、
それぞれのビットはそのアルファベットが表す拡張(例えばA拡張ならAビット、C拡張ならC)が実装されているなら@<code>{1}に設定されています。
仕様上はExtensionsフィールドを書き換えられるように実装することができますが、本書では書き換えられないようにします。

misaレジスタを作成し、読み込めるようにします
()。
CPUは@<code>{RV64IMAC}なのでMXLフィールドに@<code>{64}を表す@<code>{2}を設定し、
ExtensionsフィールドのM拡張(M)、基本整数命令セット(I)、C拡張(C)、A拡張(A)のビットを@<code>{1}にしています。

//list[][]{
//}

//list[][]{
//}

これ以降、AというCSRのBフィールド、ビットのことをA.Bと表記することがあります。

== mimpidレジスタ (Machine Implementation ID)

TODO 図

mimpidレジスタは、プロセッサ実装のバージョンを表す値を格納しているMXLENビットのレジスタです。
値が@<code>{0}のときは、mimpidレジスタが実装されていないことを示します。

他にもプロセッサの実装の情報を表すレジスタ(mvendorid@<fn>{mvendorid}、marchid@<fn>{marchid})がありますが、本書では実装しません。

//footnote[mvendorid][製造業者のID(JEDEC ID)を格納します]
//footnote[marchid][マイクロアーキテクチャの種類を示すIDを格納します]

せっかくなので、適当な値を設定しましょう。
eeiパッケージにIDを定義して、読み込めるようにします
()。

//list[][]{
//}

//list[][]{
//}

== mhartidレジスタ (Hart ID)

TODO 図

mhartidレジスタは、今実行しているハードウェアスレッド(hart)のIDを格納しているMXLENビットのレジスタです。
複数のプロセッサ、ハードウェアスレッドが存在するときに、それぞれを区別するために使用できます。
IDはどんな値でも良いですが、IDが@<code>{0}のハードウェアスレッドが1つ存在する必要があります。
基本編で作るCPUは1コア1ハードウェアスレッドであるためmhartidレジスタに0を設定します。

mhart変数を作成し、読み込めるようにします
()。

//list[][]{
//}

//list[][]{
//}

== mstatusレジスタ (Machine Status)

TODO 図

mstatusレジスタは、拡張の設定やトラップ、状態などを管理するMXLENビットのレジスタです。
基本編ではTODO 図に示しているフィールドを、そのフィールドが必要になったときに実装します。
とりあえず今のところは読み込みだけできるようにしておきます
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}


== ハードウェアパフォーマンスモニタ

RISC-Vには、ハードウェアの性能評価指標を得るためにmcycleとminstret、それぞれ29個のmhpmcounter、mhpmeventレジスタが定義されています。
それぞれ次の値を得るために利用できます。

 : mcycleレジスタ (64ビット)
    ハードウェアスレッドが起動(リセット)されてから経過したサイクル数
 : minstretレジスタ (64ビット)
    ハードウェアスレッドがリタイア(実行完了)した命令数
 : mhpmcounter、mhpmeventレジスタ (64ビット)
    mhpmeventレジスタで選択された指標がmhpmcounterレジスタに反映されます。

基本編ではmcycle、minstretレジスタを実装します。
mhpmcounter、mhpmeventレジスタは表示するような指標がないため実装しません。
また、mcountinhibitレジスタを使うとカウントを停止するかを制御できますが、これも実装しません。

=== mcycleレジスタ

TODO mcycleとminstretを分割

mcycleレジスタを定義し、always_ffブロックで値を更新します
()。

//list[][]{
//}

値を読み込めるようにします
()。

//list[][]{
//}

=== minstretレジスタ

coreモジュールでinstretレジスタを作成し、
トラップが発生していない命令がWBステージに到達した場合にインクリメントさせます
()。
csrunitモジュールはトラップではないMRET命令でも@<code>{raise_trap}フラグを立てているため、
MRET命令でもインクリメントするために@<code>{trap_return}フラグを実装しています
()。

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}

//list[][]{
//}


TODO ここでリファクタリングする

== mscratchレジスタ (Machine Scratch)

mscratchレジスタは、M-modeのときに自由に読み書きできるMXLENビットのレジスタです。

mscratchレジスタの典型的な用途はコンテキストスイッチです。
コンテキストスイッチとは、実行しているアプリケーションAを別のアプリケーションBに切り替えることを指します。
多くの場合、コンテキストスイッチはトラップによって開始しますが、
Aの実行途中の状態(レジスタの値)を保存しないとAを実行再開できなくなります。
そのため、コンテキストスイッチが始まったとき、つまりトラップが発生したときにレジスタの値をメモリに保存する必要があります。
しかし、ストア命令はアドレスの指定にレジスタの値を使うため、アドレスの指定のために少なくとも1つのレジスタの値を犠牲にしなければならず、すべてのレジスタの値を保存することができません@<fn>{save-near-zero}
()。

//list[][]{
//}

//footnote[save-near-zero][x0と即値を使うとアドレス0付近にすべてのレジスタの値を保存することができますが、一般的な方法ではなく、動的に場所を変更するのも難しいです]

この問題を回避するために、一時的な値の保存場所としてmscratchレジスタが使用されます
()。
事前にmscratchレジスタにメモリアドレス(やメモリアドレスを得るための情報)を格納しておき、
CSRRW命令でmscratchレジスタの値とレジスタの値を交換することで任意の場所にレジスタを保存できます。

mscratchレジスタを定義し、自由に読み書きできるようにします
()。

//list[][]{
//}
//list[][]{
//}
//list[][]{
//}
//list[][]{
//}
