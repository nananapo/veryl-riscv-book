= Memory-mapped I/Oの実装

== Memory-mapped I/Oとは何か？

これまでの実装では、
CPUに内蔵された1つの大きなメモリ空間、
1つのメモリデバイス(memoryモジュール)に命令データを格納、実行し、
データのロードストア命令も同じメモリに対して実行してきました。

一般に流通するコンピュータはTODO図のように複数のデバイスに接続されています。
CPUが起動すると読み込み専用の小さなメモリ(ROM)に格納されたブートローダから命令の実行を開始します。
ブートローダは周辺デバイスの初期化などを行ったあと、
動かしたいアプリケーションの命令やデータをRAMに展開して、
制御をアプリケーションに移します。

CPUがデバイスにアクセスする方法にはCSRやメモリ空間を経由する方法があります。
一般的な方法はメモリ空間を通じてデバイスにアクセスする方法であり、
この方式のことを@<b>{メモリマップドIO}(Memory-mapped I/O, @<code>{MMIO})と呼びます。
メモリ空間の一部をデバイスにアクセスするための空間として扱うことを、メモリに@<b>{マップ}すると呼びます。
RAMとROMもメモリデバイスであり、異なるアドレスにマップされています。

本章ではCPUのメモリ部分をRAMとROMに分割し、
アクセスするアドレスに応じてアクセスするデバイスを切り替える機能を実装します。
デバイスとメモリ空間の対応はTODO図のように設定します。

== 定数の定義

eeiパッケージに定義しているメモリの定数をRAMに変更し、
新しくRAMの開始アドレス、メモリバスのデータ幅、ROMの範囲を示す定数を定義してください
()。

//list[][]{
//}

MEM_DATA_WIDTH、MEM_ADDR_WIDTHを使っている部分をMEMBUS_DATA_WIDTHに置き換えます。

== コントローラ

=== コントローラを実装する

アクセスするアドレスに応じてアクセス先のデバイスを切り替えるモジュールを実装します。

@<code>{src/mmio_controller.veryl}を作成し、次のように記述します
()。

//list[][]{
//}

mmio_controllerモジュールは、
membusからメモリアクセス要求を受け付け、
アクセス対象のモジュールからのレスポンスを返すモジュールです。
@<code>{State}に応じて次のように動作します。

TODO
各状態の説明

まだアクセス対象のデバイスを実装していないため、
常に@<code>{0}を読み取り、書き込みは無視します。

=== コントローラを接続する

coreモジュールとmmio_controllerモジュールを接続します。
既存のmemoryモジュールはコメントアウトしてください。

topモジュールでコントローラをインスタンス化します
()。



== ROMの実装

== RAMのベースアドレスの変更

== RAMの実装

== デバッグ用IOの実装

ROMからRAMにジャンプする

終わり
=> Web版でUARTを実装します