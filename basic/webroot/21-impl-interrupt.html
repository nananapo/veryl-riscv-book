<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>M-modeの実装 (2. 割り込みの実装) | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="U-modeの実装" href="22-umode-csr.html">
    <link rel="prev" title="M-modeの実装 (1. CSRの実装)" href="20-mmode-csr.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
<li class="toc-part">第I部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">1 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">2 例外の実装</a></li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">3 Memory-mapped I/Oの実装</a></li>
    <li class="toc-chapter"><a href="./13-impl-a.html">4 A拡張の実装</a></li>
    <li class="toc-chapter"><a href="./14-impl-c.html">5 C拡張の実装</a></li>
  </ul>
</li>
<li class="toc-part">第II部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">6 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">7 M-modeの実装 (2. 割り込みの実装)</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-1">7.1 概要</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-2">7.2 RISC-Vの割り込み</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-3">7.3 ACLINTモジュールの作成</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-4">7.4 ソフトウェア割り込みの実装 (MSWI)</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-5">7.5 タイマ割り込みの実装 (MTIMER)</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-6">7.6 WFI命令の実装</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-7">7.7 time、instret、cycleレジスタの実装</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">8 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">9 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">10 S-modeの実装 (2. 仮想記憶システム)</a></li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">11 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">12 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h7"></a><span class="secno">第7章</span> <br/>M-modeの実装 (2. 割り込みの実装)</h1>

<h2 class="numbox"><a id="h7-1"></a><span class="secno">7.1</span> 概要</h2>

<h3 class="none"><a id="h7-1-1"></a><span class="secno">7.1.1</span> 割り込みとは何か？</h3>
<p>アプリケーションを記述するとき、キーボードやマウスの入力、時間の経過のようなイベントに起因して何らかのプログラムを実行したいことがあります。例えばキーボードから入力を得たいとき、ポーリング(Polling)、または割り込み(Interrupt)という手法が利用されます。</p>
<p>TODO図</p>
<p>ポーリングとは、定期的に問い合わせを行う方式のことです。例えばキーボード入力の場合、定期的にキーボードデバイスにアクセスして入力があるかどうかを確かめます。1秒くらいかかる処理Aを繰り返すとして、繰り返しごとに入力の有無を確認する場合、最大1秒の遅延が発生します(TODO 図)。待ち時間減らすために処理Aを分割すると遅延は減少しますが、長時間キーボード入力が無い場合、入力の有無の確認頻度が上がる分だけ何も入力が無いデバイスに対する確認処理が実行されることになります。この問題は、CPUからデバイスに問い合わせをする方式では解決できません。</p>
<p>入力の理想的な確認タイミングは入力が確認できるようになってすぐであるため、入力があったタイミングでデバイス側からCPUにイベントを通知すればいいです。これを実現するのが割り込みです。</p>
<p>TODO 図</p>
<p>割り込みとは、何らかのイベントの通知によって実行中のプログラムを中断して通知内容を処理する方式のことです。割り込みを使うと、ポーリングのように無駄にデバイスにアクセスをすることなく、入力の処理が必要な時にだけ実行できます(TODO 図)。</p>

<h2 id="riscv-interrupts" class="numbox"><a id="h7-2"></a><span class="secno">7.2</span> RISC-Vの割り込み</h2>
<p>RISC-Vでは割り込み機能がCSRによって提供されます。割り込みが発生するとトラップが発生します。割り込みを発生させるようなイベントは外部割り込み、ソフトウェア割り込み、タイマ割り込みの3つに大別されます。</p>
<dl>
<dt>外部割り込み (External Interrupt)</dt>
<dd>
    コア外部のデバイスによって発生する割り込み。
    複数の外部デバイスの割り込みは割り込みコントローラ(<a href="./25-impl-plic.html">第11章「PLICの実装」</a>)などによって調停(制御)されます。
</dd>
<dt>ソフトウェア割り込み (Software Interrupt)</dt>
<dd>
    CPUで動くソフトウェアが発生させる割り込み。
    CSR、もしくはメモリにマップされたレジスタ値の変更によって発生します。
</dd>
<dt>タイマ割り込み</dt>
<dd>
    タイマ回路(デバイス)によって引き起こされる割り込み。
    タイマの設定と時間経過によって発生します。
</dd>
</dl>
<p><b>M-modeだけ</b>が実装されたRISC-VのCPUでは、次にような順序で割り込みが提供されます。他に実装されている特権レベルがある場合については「<a href="22-umode-csr.html#h8-8">8.8 割り込み条件の変更</a>」、<a href="./23-smode-csr.html">第9章「S-modeの実装 (1. CSRの実装)」</a>で解説します。</p>
<ol start="1" type="1">
<li>割り込みを発生させるようなイベントがデバイスで発生する</li>
<li>割り込み原因に対応したmipレジスタのビットが<code class="inline-code">0</code>から<code class="inline-code">1</code>になる</li>
<li>割り込み原因に対応したmieレジスタのビットが<code class="inline-code">1</code>であることを確認する (<code class="inline-code">0</code>なら割り込みは発生しない)</li>
<li>mstatus.MIEが<code class="inline-code">1</code>であることを確認する (<code class="inline-code">0</code>なら割り込みは発生しない)</li>
<li>(割り込み(トラップ)開始)</li>
<li>mstatus.MPIEにmstatus.MIEを格納する</li>
<li>mstatus.MIEに<code class="inline-code">0</code>を格納する</li>
<li>mtvecレジスタの値(トラップベクタ)にジャンプする</li>
</ol>
<p>TODO mipとmieの図</p>
<p>mip(Machine Interrupt Pending)レジスタは割り込みの発生を待っている(待機)状態を示すMXLENビットのCSRです(TODO 図)。mie(Machine Interrupt Enable)レジスタは割り込みを許可するかを原因ごとに管理する制御するMXLENビットのCSRです(TODO 図)。mstatus.MIEはすべての割り込みを許可するかどうかを制御する1ビットのフィールドです。mieとmstatus.MIEのことを割り込みイネーブル(許可)レジスタと呼び、特にmstatus.MIEのようなすべての割り込みを制御するレジスタのことをグローバル割り込みイネーブルビットと呼びます</p>
<p>割り込みの発生時にmstatus.MIEを0にすることで、割り込みの処理中に割り込みが発生することを防いでいます。また、トラップから戻る(MRET命令を実行する)とき、mstatus.MPIEの値をmstatus.MIEに書き戻すことで割り込みの許可状態を戻します。</p>

<h3 class="none"><a id="h7-2-1"></a><span class="secno">7.2.1</span> 割り込みの優先順位</h3>
<p>RISC-Vには外部割り込み、ソフトウェア割り込み、タイマ割り込みがそれぞれM-mode、S-mode向けに用意されています。それぞれの割り込みにはテーブルTODOのような優先順位が定義されていて、複数の割り込みを発生させられるときは優先順位が高い割り込みを発生させます。</p>
<p>TODOテーブル</p>

<h3 class="none"><a id="h7-2-2"></a><span class="secno">7.2.2</span> 割り込みの原因(cause)</h3>
<p>それぞれの割り込みには原因を区別するための値(cause)が割り当てられています。割り込みのcauseのMSBは1です。</p>
<p><code class="inline-code">CsrCause</code>型に割り込みのcauseを追加してください()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-2-3"></a><span class="secno">7.2.3</span> ACLINT (Advanced Core Local Interruptor)</h3>
<p>RISC-Vにはソフトウェア割り込みとタイマ割り込みを実現するデバイスの仕様であるACLINTが用意されています。ACLINTは、SiFive社が開発したCLINT(Core-Local Interruptor)デバイスが基になった仕様です。</p>
<p>ACLINTにはMTIMER、MSWI、SSWIの3つのデバイスが定義されています。それぞれタイマ割り込み、ソフトウェア割り込み、ソフトウェア割り込み向けのデバイスで、mipレジスタのMTIP、MSIP、SSIPビットに状態を通知します。</p>
<p>本書ではACLINTを図TODOのようなメモリマップで実装します。本章ではMTIMER、MSWIデバイスを実装し、「<a href="23-smode-csr.html#h9-8">9.8 ソフトウェア割り込みの実装 (SSWI)</a>」でSSWIデバイスを実装します。デバイスのの具体的な仕様については後で解説します。</p>
<p>メモリマップ用の定数をeeiパッケージに記述してください()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h2 class="numbox"><a id="h7-3"></a><span class="secno">7.3</span> ACLINTモジュールの作成</h2>
<p>まず、ACLINTとcoreモジュールを接続するためのインターフェースを作成します。<code class="inline-code">src/aclint_if.veryl</code>を作成し、次のように記述します()。インターフェースの中身はデバイスの実装時に実装します。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>topモジュールでaclint_ifインターフェースをインスタンス化しておきます()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>ACLINTを実装するモジュールを作成します。<code class="inline-code">src/aclint_memory.veryl</code>を作成し、次のように記述します()。まだ何のレジスタも実装していません。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>aclint_memoryモジュールをインスタンス化し、mmio_controllerモジュールを接続します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>coreモジュール内のcsrunitモジュールとaclint_memoryモジュールを接続します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h2 class="numbox"><a id="h7-4"></a><span class="secno">7.4</span> ソフトウェア割り込みの実装 (MSWI)</h2>
<p>MSWIデバイスはソフトウェア割り込み(machine software interrupt)を提供するためのデバイスです。MSWIデバイスにはハードウェアスレッド毎に4バイトのMSIPレジスタが用意されています(TODO テーブル)。MSIPレジスタの上位31ビットは読み込み専用の<code class="inline-code">0</code>であり、最下位ビットのみ変更できます。各MSIPレジスタは、それに対応するハードウェアスレッドのmip.MSIPと接続されています。</p>
<p>TODOテーブル (最大4095個)</p>
<p>仕様上はmhartidとACLINTのレジスタのhartIDが一致する必要はありませんが、本書ではmhartidとhartIDが同じになるように実装します。</p>

<h3 class="none"><a id="h7-4-1"></a><span class="secno">7.4.1</span> MSIPレジスタを実装する</h3>
<p>ACLINTモジュールにMSIPレジスタを実装します。今のところCPUにはmhartidが0のハードウェアスレッドしか存在しないため、MSIP0のみ実装します。</p>
<p><code class="inline-code">msip0</code>レジスタを作成し、読み書きできるようにします()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>aclint_ifインターフェースに<code class="inline-code">msip</code>を作成し、<code class="inline-code">msip0</code>レジスタと接続します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-4-2"></a><span class="secno">7.4.2</span> mip、mieレジスタを実装する</h3>
<p>mipレジスタのMSIPビット、MIEレジスタのMSIEビットを実装します。mie.MSIEはMSIPビットによる割り込み待機を許可するかを制御するビットです。mip.MSIPとmie.MSIEは同じ位置のビットに配置されています。mip.MSIPに書き込むことはできません。</p>
<p>csrunitモジュールにmip、mieレジスタを作成します()。mieレジスタはMSIPビットだけ書き込めるように実装し、mipレジスタはMSIEビットを接続した値として実装します。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-4-3"></a><span class="secno">7.4.3</span> mstatusのMIE、MPIEビットを実装する</h3>
<p>mstatus.MIE、MPIEを変更できるようにします()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-4-4"></a><span class="secno">7.4.4</span> 割り込み処理の実装</h3>
<p>必要なレジスタを実装できたので、割り込みを起こす処理を実装します。割り込みはmip、mieの両方のビット、mstatus.MIEビットが立っているときに発生します。</p>
<p>割り込みを起こすべきかを判定する変数、cause、トラップベクタを示す変数を作成します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>トラップ情報についての変数に割り込みの変数を割り当てます()。割り込みよりも例外を優先します。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>トラップが発生するとき、mstatus.MPIEにmstatus.MIE、mstatus.MIEに<code class="inline-code">0</code>を設定します()。また、例外が発生したときにのみmtvalレジスタに例外の原因を書き込むようにします。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-4-5"></a><span class="secno">7.4.5</span> MRET命令の実装</h3>
<p>トラップから戻る(trap return)とき、mstatus.MIEにmstatus.MPIE、mstatus.MPIEに<code class="inline-code">0</code>を書き込みます()。これにより、トラップによって変更されていたmstatus.MIEを元に戻されます。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-4-6"></a><span class="secno">7.4.6</span> mtvecのVectoredモードの実装</h3>
<p>mtvecレジスタにはMODEフィールドがあり、割り込みが発生するときのトラップベクタの決定方法を制御できます。</p>
<p>MODEがDirect(<code class="inline-code">2'b00</code>)のとき、<code class="inline-code">mtvec.BASE &lt;&lt; 2</code>のアドレスにトラップします。Vectored(<code class="inline-code">2'b01</code>)のとき、<code class="inline-code">(mtvec.BASE &lt;&lt; 2) + 4 * cause</code>のアドレスにトラップします。ここでcauseは割り込みのcauseのMSBを除いた値です。例えばmachine software interruptの場合、<code class="inline-code">(mtvec.BASE &lt;&lt; 2) + 4 * 3</code>がトラップベクタになります。</p>
<p>mtvec.MODEにVectoredを書き込めるようにします()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>MODEとcauseに応じて割り込みのトラップベクタを変更します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-4-7"></a><span class="secno">7.4.7</span> ソフトウェア割り込みをテストする</h3>
<p>ソフトウェア割り込みが正しく動くことを確認します。</p>
<p><code class="inline-code">test/aclint_msi.c</code>を作成し、次のように記述します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>プログラムでは、mtvecにinterrupt_handler関数のアドレスを書き込み、mstatus.MIE、mie.MSIEを<code class="inline-code">1</code>に設定して割り込みを許可してからMSIP0レジスタに1を書き込んでいます。</p>
<p>プログラムをコンパイルして実行すると、TODOリストのように表示されます。main関数からinterrupt_handler関数にトラップしていることが分かります。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>ソフトウェア割り込みが発生していることを確認できました。</p>

<h2 class="numbox"><a id="h7-5"></a><span class="secno">7.5</span> タイマ割り込みの実装 (MTIMER)</h2>

<h3 class="none"><a id="h7-5-1"></a><span class="secno">7.5.1</span> タイマ割り込みの仕組み</h3>
<p>MTIMERデバイスは、タイマ割り込み(machine timer interrupt)を提供するためのデバイスです。MTIMERデバイスには1つの8バイトのMTIMEレジスタ、ハードウェアスレッド毎に8バイトのMTIMECMPレジスタが用意されています(TODOテーブル)。本書ではMTIMECMPの後ろにMTIMEを配置します。</p>
<p>TODO テーブル (MTIME)TODO テーブル (MTIMECMP 最大4095個)</p>
<p>MTIMEレジスタは、固定された周波数でのサイクル数をカウントするレジスタです。リセット時に<code class="inline-code">0</code>になります。</p>
<p>MTIMERデバイスは、それに対応するハードウェアスレッドのmip.MTIPと接続されており、MTIMEがMTIMECMPを上回ったときmip.MTIPを<code class="inline-code">1</code>にします。これにより、指定した時間に割り込みを発生させることが可能になります。</p>

<h3 class="none"><a id="h7-5-2"></a><span class="secno">7.5.2</span> MTIME、MTIMECMPレジスタを実装する</h3>
<p>ACLINTモジュールにMTIME、MTIMECMPレジスタを実装します。今のところmhartidが<code class="inline-code">0</code>のハードウェアスレッドしか存在しないため、MTIMECMP0のみ実装します。</p>
<p><code class="inline-code">mtime</code>、<code class="inline-code">mtimecmp0</code>レジスタを作成し、読み書きできるようにします()。<code class="inline-code">mtime</code>に値が書き込まれないとき、クロック毎にインクリメントします。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>aclint_ifインターフェースに<code class="inline-code">mtip</code>を作成し、タイマ割り込みが発生する条件を設定します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-5-3"></a><span class="secno">7.5.3</span> 割り込み原因を設定する</h3>
<p>TODO memunitを止められていない -&gt; 割り込めるのは最初の1クロックだけ</p>
<p>割り込み原因を優先順位に応じて設定します。タイマ割り込みはソフトウェア割り込みよりも優先順位が低いため、ソフトウェア割り込みの下で原因を設定します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h3 class="none"><a id="h7-5-4"></a><span class="secno">7.5.4</span> タイマ割り込みをテストする</h3>
<p>タイマ割り込みが正しく動くことを確認します。</p>
<p><code class="inline-code">test/aclint_mti.c</code>を作成し、次のように記述します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>プログラムでは、mtimecmpをmtimeに<code class="inline-code">1000</code>を足した値に設定し、mtvecにinterrupt_handler関数のアドレスを書き込んだ後、mstatus.MIE、mie.MTIEを<code class="inline-code">1</code>に設定して割り込みを許可しています。</p>
<p>プログラムをコンパイルして実行すると、TODOリストのように表示されます。時間経過によってmain関数からinterrupt_handler関数にトラップしていることが分かります。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>タイマ割り込みが発生していることを確認できました。</p>

<h2 class="numbox"><a id="h7-6"></a><span class="secno">7.6</span> WFI命令の実装</h2>
<p>WFI命令は割り込みが発生するまで、CPUをストールさせる命令です。ただし、グローバル割り込みイネーブルビットは考慮せず、ある割り込みの待機(pending)ビットと許可(enable)ビットの両方が立っているときに実行を再開します。また、それ以外の自由な理由で実行を再開させてもいいです。WFI命令で割り込みが発生するとき、WFI命令の次のアドレスの命令で割り込みが起こったことにします。</p>
<p>本書ではWFI命令でCPUをストールさせるように実装します。</p>
<p>inst_decoderモジュールでWFI命令をデコードできるようにします()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>csrunitモジュールに<code class="inline-code">stall</code>フラグを実装し、WFI命令の時にビットを立てるようにします()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>WFI命令で割り込みが発生するとき、mepcレジスタに<code class="inline-code">pc + 4</code>を書き込むようにします()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>coreモジュールでcsrunitモジュールの<code class="inline-code">stall</code>フラグによってMEM(CSR)ステージをストールさせます()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>

<h2 class="numbox"><a id="h7-7"></a><span class="secno">7.7</span> time、instret、cycleレジスタの実装</h2>
<p>RISC-Vにはtime、instret、cycleという読み込み専用のCSRが定義されており、それぞれmtime、minstret、mcycleレジスタと同じ値をとります<sup><a id="fnb-hpmcounter" href="#fn-hpmcounter" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-hpmcounter" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>mhpmcounterレジスタと同じ値をとるhpmcounterレジスタもありますが、mhpmcounterレジスタを実装していないので実装しません。</p></div>
</div><!--/.footnote-list-->
<p><code class="inline-code">CsrAddr</code>型にレジスタのアドレスを追加します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>mtimeレジスタの値をACLINTモジュールからcsrunitに渡します()。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
<p>time、instret、cycleレジスタを読み込めるようにします。</p>
<div class="caption-code">
<pre class="emlist">
</pre>
</div>
        </main>
        <nav class="page-navi">
          <a href="20-mmode-csr.html" class="page-prev">&#9664;</a>
          <a href="22-umode-csr.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
