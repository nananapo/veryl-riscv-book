<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>例外の実装 | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="Memory-mapped I/Oの実装" href="12-impl-mmio.html">
    <link rel="prev" title="M拡張の実装" href="10-impl-m.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき</a></li>
<li class="toc-part">第I部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">1 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">2 例外の実装</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./11-impl-exception.html#h2-1">2.1 例外とは何か?</a></li>
        <li class="toc-section"><a href="./11-impl-exception.html#h2-2">2.2 例外情報の伝達</a></li>
        <li class="toc-section"><a href="./11-impl-exception.html#h2-3">2.3 Breakpoint例外の実装</a></li>
        <li class="toc-section"><a href="./11-impl-exception.html#h2-4">2.4 Illegal instruction例外の実装</a></li>
        <li class="toc-section"><a href="./11-impl-exception.html#h2-5">2.5 命令アドレスのミスアライン例外</a></li>
        <li class="toc-section"><a href="./11-impl-exception.html#h2-6">2.6 ロードストア命令のミスアライン例外</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">3 Memory-mapped I/Oの実装</a></li>
    <li class="toc-chapter"><a href="./13-impl-a.html">4 A拡張の実装</a></li>
    <li class="toc-chapter"><a href="./14-impl-c.html">5 C拡張の実装</a></li>
  </ul>
</li>
<li class="toc-part">第II部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">6 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">7 M-modeの実装 (2. 割り込みの実装)</a></li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">8 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">9 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">10 S-modeの実装 (2. 仮想記憶システム)</a></li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">11 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">12 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h2"></a><span class="secno">第2章</span> <br/>例外の実装</h1>

<h2 class="numbox"><a id="h2-1"></a><span class="secno">2.1</span> 例外とは何か?</h2>
<p>CPUがソフトウェアを実行するとき、処理を中断したり終了しなければならないような異常な状態<sup><a id="fnb-unusual-condition" href="#fn-unusual-condition" class="noteref" epub:type="noteref">*1</a></sup>が発生することがあります。例えば、実行環境(EEI)がサポートしていない、または実行を禁止しているような違法(illegal)<sup><a id="fnb-illegal" href="#fn-illegal" class="noteref" epub:type="noteref">*2</a></sup>な命令を実行しようとする場合です。このとき、CPUはどのような動作をすればいいのでしょうか？</p>
<div class="footnote-list">
<div class="footnote" id="fn-unusual-condition" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>異常な状態(unusual condition)。予期しない(unexpected)事象と呼ぶ場合もあります。</p></div>
<div class="footnote" id="fn-illegal" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>不正と呼ぶこともあります。逆に実行できる命令のことを合法(legal)な命令と呼びます</p></div>
</div><!--/.footnote-list-->
<p>RISC-Vでは、命令によって引き起こされる異常な状態のことを<b>例外(Exception)</b>と呼び、例外が発生した場合には<b>トラップ(Trap)</b>を引き起こします。トラップとは例外、または割り込み(Interrupt)<sup><a id="fnb-interrupt" href="#fn-interrupt" class="noteref" epub:type="noteref">*3</a></sup>によってCPUの状態、制御を変更することです。具体的にはPCをトラップベクタ(trap vector)に移動したり、CSRを変更します。</p>
<div class="footnote-list">
<div class="footnote" id="fn-interrupt" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*3] </span>割り込みは<a href="./21-impl-interrupt.html">第7章「M-modeの実装 (2. 割り込みの実装)」</a>で実装します。</p></div>
</div><!--/.footnote-list-->
<p>本書では既にECALL命令の実行によって発生するEnvironment call from M-mode例外を実装しており、例外が発生したら次のように動作します。</p>
<ol start="1" type="1">
<li>mcauseレジスタにトラップの発生原因を示す値(<code class="inline-code">11</code>)を書き込む</li>
<li>mepcレジスタにPCの値を書き込む</li>
<li>PCをmtvecレジスタの値に設定する</li>
</ol>
<p>本章では、例外発生時に例外に固有の情報を書き込むmtvalレジスタと、現在の実装で発生する可能性がある例外を実装します。本書ではこれ以降、トラップの発生原因を示す値のことをcauseと呼びます。</p>

<h2 class="numbox"><a id="h2-2"></a><span class="secno">2.2</span> 例外情報の伝達</h2>

<h3 class="none"><a id="h2-2-1"></a><span class="secno">2.2.1</span> Environment call from M-mode例外をIFステージで処理する</h3>
<p>今のところ、ECALL命令による例外はMEM(CSR)ステージのcsrunitモジュールで例外判定、処理されています。ECALL命令によって例外が発生するかは命令がECALLであるかどうかだけを判定すれば分かるため、命令をデコードする時点、つまりIDステージで判定できます。</p>
<p>本章で実装する例外にはMEMステージよりも前で発生する例外があるため、IDステージから順に次のステージに例外の有無、causeを受け渡していく仕組みを実装します。</p>
<p>まず、例外が発生するかどうか(<code class="inline-code">valid</code>)、例外のcause(<code class="inline-code">cause</code>)をまとめた<code class="inline-code">ExceptionInfo</code>構造体を定義します(<span class="listref"><a href="./11-impl-exception.html#corectrl.veryl.exptinfo-range.ExceptionInfo">リスト2.1</a></span>)。</p>
<div id="corectrl.veryl.exptinfo-range.ExceptionInfo" class="caption-code">
<span class="caption">リスト2.1: リスト2.1: ExceptionInfo構造体を定義する (corectrl.veryl)</span>
<pre class="list language-ExceptionInfo">    // 例外の情報を保存するための型
    struct ExceptionInfo {
        valid: logic   ,
        cause: CsrCause,
    }
</pre>
</div>
<p>EXステージ、MEMステージのFIFOのデータ型に構造体を追加します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.exptinfo-range.exq_type">リスト2.2</a></span>、<span class="listref"><a href="./11-impl-exception.html#core.veryl.exptinfo-range.memq_type">リスト2.3</a></span>)。</p>
<div id="core.veryl.exptinfo-range.exq_type" class="caption-code">
<span class="caption">リスト2.2: リスト2.2: EXステージのFIFOにExceptionInfoを追加する (core.veryl)</span>
<pre class="list language-exq_type">    struct exq_type {
        addr: Addr         ,
        bits: Inst         ,
        ctrl: InstCtrl     ,
        imm : UIntX        ,
        <b>expt: ExceptionInfo,</b>
    }
</pre>
</div>
<div id="core.veryl.exptinfo-range.memq_type" class="caption-code">
<span class="caption">リスト2.3: リスト2.3: MEMステージのFIFOにExceptionInfoを追加する (core.veryl)</span>
<pre class="list language-memq_type">    struct memq_type {
        addr      : Addr            ,
        bits      : Inst            ,
        ctrl      : InstCtrl        ,
        imm       : UIntX           ,
        <b>expt      : ExceptionInfo   ,</b>
        alu_result: UIntX           ,
        rs1_addr  : logic        &lt;5&gt;,
</pre>
</div>
<p>IDステージからEXステージに命令を渡すとき、命令がECALL命令なら例外が発生することを伝えます(<span class="listref"><a href="./11-impl-exception.html#core.veryl.exptinfo-range.idex">リスト2.4</a></span>)。</p>
<div id="core.veryl.exptinfo-range.idex" class="caption-code">
<span class="caption">リスト2.4: リスト2.4: IDステージでECALL命令を判定する (core.veryl)</span>
<pre class="list language-idex">    always_comb {
        // ID -&gt; EX
        if_fifo_rready = exq_wready;
        exq_wvalid     = if_fifo_rvalid;
        exq_wdata.addr = if_fifo_rdata.addr;
        exq_wdata.bits = if_fifo_rdata.bits;
        exq_wdata.ctrl = ids_ctrl;
        exq_wdata.imm  = ids_imm;
        <b>// exception</b>
        <b>exq_wdata.expt.valid = ids_inst_bits == 32'h00000073; // ECALL</b>
        <b>exq_wdata.expt.cause = CsrCause::ENVIRONMENT_CALL_FROM_M_MODE;</b>
    }
</pre>
</div>
<p>EXステージで例外は発生しないので、例外情報をそのままMEMステージに渡します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.exptinfo-range.exmem">リスト2.5</a></span>)。</p>
<div id="core.veryl.exptinfo-range.exmem" class="caption-code">
<span class="caption">リスト2.5: リスト2.5: EXステージからMEMステージに例外情報を渡す (core.veryl)</span>
<pre class="list language-exmem">    always_comb {
        // EX -&gt; MEM
        exq_rready            = memq_wready &amp;&amp; !exs_stall;
        ...
        memq_wdata.jump_addr  = if inst_is_br(exs_ctrl) ? exs_pc + exs_imm : exs_alu_result &amp; ~1;
        <b>memq_wdata.expt       = exq_rdata.expt;</b>
    }
</pre>
</div>
<p>csrunitモジュールを変更します。<code class="inline-code">expt_info</code>ポートを追加して、MEMステージ以前の例外情報を受け取ります(<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.exptinfo-range.port">リスト2.6</a></span>、<span class="listref"><a href="./11-impl-exception.html#core.veryl.exptinfo-range.memreg">リスト2.7</a></span>、<span class="listref"><a href="./11-impl-exception.html#core.veryl.exptinfo-range.csru">リスト2.8</a></span>)。</p>
<div id="csrunit.veryl.exptinfo-range.port" class="caption-code">
<span class="caption">リスト2.6: リスト2.6: csrunitモジュールに例外情報を受け取るためのポートを追加する (csrunit.veryl)</span>
<pre class="list language-port">module csrunit (
    clk        : input  clock            ,
    rst        : input  reset            ,
    valid      : input  logic            ,
    pc         : input  Addr             ,
    ctrl       : input  InstCtrl         ,
    <b>expt_info  : input  ExceptionInfo    ,</b>
    rd_addr    : input  logic        &lt;5&gt; ,
</pre>
</div>
<div id="core.veryl.exptinfo-range.memreg" class="caption-code">
<span class="caption">リスト2.7: リスト2.7: MEMステージの例外情報の変数を作成する (core.veryl)</span>
<pre class="list language-memreg">    ///////////////////////////////// MEM Stage /////////////////////////////////
    var mems_is_new   : logic           ;
    let mems_valid    : logic            = memq_rvalid;
    let mems_pc       : Addr             = memq_rdata.addr;
    let mems_inst_bits: Inst             = memq_rdata.bits;
    let mems_ctrl     : InstCtrl         = memq_rdata.ctrl;
    <b>let mems_expt     : ExceptionInfo    = memq_rdata.expt;</b>
    let mems_rd_addr  : logic        &lt;5&gt; = mems_inst_bits[11:7];
</pre>
</div>
<div id="core.veryl.exptinfo-range.csru" class="caption-code">
<span class="caption">リスト2.8: リスト2.8: csrunitモジュールに例外情報を供給する (core.veryl)</span>
<pre class="list language-csru">    inst csru: csrunit (
        clk                             ,
        rst                             ,
        valid    : mems_valid           ,
        pc       : mems_pc              ,
        ctrl     : mems_ctrl            ,
        <b>expt_info: mems_expt            ,</b>
        rd_addr  : mems_rd_addr         ,
</pre>
</div>
<p>ECALL命令かどうかを判定する<code class="inline-code">is_ecall</code>変数を削除して、例外の発生条件、例外の種類を示す値を変更します(<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.exptinfo-range.remove_ecall">リスト2.9</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.exptinfo-range.expt">リスト2.10</a></span>)。</p>
<div id="csrunit.veryl.exptinfo-range.remove_ecall" class="caption-code">
<span class="caption">リスト2.9: リスト2.9: csrunitモジュールでのECALL命令の判定を削除する (csrunit.veryl)</span>
<pre class="list language-remove_ecall">    // CSRR(W|S|C)[I]命令かどうか
    let is_wsc: logic = ctrl.is_csr &amp;&amp; ctrl.funct3[1:0] != 0;
    <del>// ECALL命令かどうか</del>
    <del>let is_ecall: logic = ctrl.is_csr &amp;&amp; csr_addr == 0 &amp;&amp; rs1[4:0] == 0 &amp;&amp; ctrl.funct3 == 0 &amp;&amp; rd_addr == 0;</del>
</pre>
</div>
<div id="csrunit.veryl.exptinfo-range.expt" class="caption-code">
<span class="caption">リスト2.10: リスト2.10: ExceptionInfoを使って例外を起こす (csrunit.veryl)</span>
<pre class="list language-expt">    // Exception
    let raise_expt: logic = valid &amp;&amp; expt_info.valid;
    let expt_cause: UIntX = expt_info.cause;
</pre>
</div>

<h3 class="none"><a id="h2-2-2"></a><span class="secno">2.2.2</span> mtvalレジスタを実装する</h3>
<p>例外が発生すると、CPUはトラップベクタにジャンプして例外を処理します。mcauseレジスタを読むことでどの例外が発生したかを判別できますが、その例外の詳しい情報を知りたいことがあります。</p>
<div id="mtval" class="image">
<img src="images/11-impl-exception/mtval.png" alt="mtvalレジスタ" class="img" style="width:90%" />
<p class="caption">
図2.1: mtvalレジスタ
</p>
</div>
<p>RISC-Vには、例外が発生したときのソフトウェアによるハンドリングを補助するために、MXLENビットのmtvalレジスタが定義されています(<span class="imgref"><a href="./11-impl-exception.html#mtval">図2.1</a></span>)。例外が発生したとき、CPUはmtvalレジスタに例外に固有の情報を書き込みます。これ以降、例外に固有の情報のことをtvalと呼びます。</p>
<p><code class="inline-code">ExceptionInfo</code>構造体に例外に固有の情報を示す<code class="inline-code">value</code>を追加します(<span class="listref"><a href="./11-impl-exception.html#corectrl.veryl.mtval-range.ExceptionInfo">リスト2.11</a></span>)。</p>
<div id="corectrl.veryl.mtval-range.ExceptionInfo" class="caption-code">
<span class="caption">リスト2.11: リスト2.11: tvalをExceptionInfoに追加する (corectrl.veryl)</span>
<pre class="list language-ExceptionInfo">    struct ExceptionInfo {
        valid: logic   ,
        cause: CsrCause,
        <b>value: UIntX   ,</b>
    }
</pre>
</div>
<p>ECALL命令はmtvalに書き込むような情報がないので<code class="inline-code">0</code>に設定します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.mtval-range.idex">リスト2.12</a></span>)。</p>
<div id="core.veryl.mtval-range.idex" class="caption-code">
<span class="caption">リスト2.12: リスト2.12: ECALL命令のtvalを設定する (corectrl.veryl)</span>
<pre class="list language-idex">        // exception
        exq_wdata.expt.valid = ids_inst_bits == 32'h00000073; // ECALL
        exq_wdata.expt.cause = CsrCause::ENVIRONMENT_CALL_FROM_M_MODE;
        <b>exq_wdata.expt.value = 0;</b>
</pre>
</div>
<p><code class="inline-code">CsrAddr</code>型にmtvalレジスタのアドレスを追加します(<span class="listref"><a href="./11-impl-exception.html#eei.veryl.mtval-range.CsrAddr">リスト2.13</a></span>)。</p>
<div id="eei.veryl.mtval-range.CsrAddr" class="caption-code">
<span class="caption">リスト2.13: リスト2.13: mtvalのアドレスを定義する (eei.veryl)</span>
<pre class="list language-CsrAddr">    enum CsrAddr: logic&lt;12&gt; {
        MTVEC = 12'h305,
        MEPC = 12'h341,
        MCAUSE = 12'h342,
        <b>MTVAL = 12'h343,</b>
        LED = 12'h800,
    }
</pre>
</div>
<p>mtvalレジスタを実装して、書き込み、読み込みできるようにします(<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.wmask">リスト2.14</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.reg">リスト2.15</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.rw">リスト2.16</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.reset">リスト2.17</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.write">リスト2.18</a></span>)。</p>
<div id="csrunit.veryl.mtval-range.wmask" class="caption-code">
<span class="caption">リスト2.14: リスト2.14: mtvalの書き込みマスクを定義する (csrunit.veryl)</span>
<pre class="list language-wmask">    const MTVAL_WMASK : UIntX = 'hffff_ffff_ffff_ffff;
</pre>
</div>
<div id="csrunit.veryl.mtval-range.reg" class="caption-code">
<span class="caption">リスト2.15: リスト2.15: mtval変数を作成する (csrunit.veryl)</span>
<pre class="list language-reg">    var mtvec : UIntX;
    var mepc  : UIntX;
    var mcause: UIntX;
    <b>var mtval : UIntX;</b>
</pre>
</div>
<div id="csrunit.veryl.mtval-range.rw" class="caption-code">
<span class="caption">リスト2.16: リスト2.16: mtvalの読み込みデータ、書き込みマスクを設定する (csrunit.veryl)</span>
<pre class="list language-rw">    always_comb {
        // read
        rdata = case csr_addr {
            ...
            <b>CsrAddr::MTVAL : mtval,</b>
            ...
        };
        // write
        wmask = case csr_addr {
            ...
            <b>CsrAddr::MTVAL : MTVAL_WMASK,</b>
            ...
        };
</pre>
</div>
<div id="csrunit.veryl.mtval-range.reset" class="caption-code">
<span class="caption">リスト2.17: リスト2.17: mtval変数をリセットする (csrunit.veryl)</span>
<pre class="list language-reset">    always_ff {
        if_reset {
            mtvec  = 0;
            mepc   = 0;
            mcause = 0;
            <b>mtval  = 0;</b>
            led    = 0;
</pre>
</div>
<div id="csrunit.veryl.mtval-range.write" class="caption-code">
<span class="caption">リスト2.18: リスト2.18: mtvalに書き込めるようにする (csrunit.veryl)</span>
<pre class="list language-write">    } else {
        if is_wsc {
            case csr_addr {
                ...
                <b>CsrAddr::MTVAL : mtval  = wdata;</b>
                ...
            }
        }
    }
</pre>
</div>
<p>例外が発生するとき、mtvalレジスタに<code class="inline-code">expt_info.value</code>を書き込むようにします(<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.info">リスト2.19</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.mtval-range.update">リスト2.20</a></span>)。</p>
<div id="csrunit.veryl.mtval-range.info" class="caption-code">
<span class="caption">リスト2.19: リスト2.19: tvalを変数に割り当てる (csrunit.veryl)</span>
<pre class="list language-info">    let raise_expt : logic = valid &amp;&amp; expt_info.valid;
    let expt_cause : UIntX = expt_info.cause;
    <b>let expt_value : UIntX = expt_info.value;</b>
</pre>
</div>
<div id="csrunit.veryl.mtval-range.update" class="caption-code">
<span class="caption">リスト2.20: リスト2.20: 例外が発生するとき、mtvalにtvalを書き込む (csrunit.veryl)</span>
<pre class="list language-update">    if valid {
        if raise_trap {
            if raise_expt {
                mepc   = pc;
                mcause = trap_cause;
                <b>mtval  = expt_value;</b>
            }
</pre>
</div>

<h2 class="numbox"><a id="h2-3"></a><span class="secno">2.3</span> Breakpoint例外の実装</h2>
<p>Breakpoint例外は、EBREAK命令によって引き起こされる例外です。EBREAK命令はデバッガがプログラムを中断させる場合などに利用されます。EBREAK命令はECALL命令と同様に例外を発生させるだけで、ほかに操作を行いません。causeは<code class="inline-code">3</code>で、tvalは例外が発生した命令のアドレスになります。</p>
<p><code class="inline-code">CsrCause</code>型にBreakpoint例外のcauseを追加します(<span class="listref"><a href="./11-impl-exception.html#eei.veryl.breakpoint-range.CsrCause">リスト2.21</a></span>)。</p>
<div id="eei.veryl.breakpoint-range.CsrCause" class="caption-code">
<span class="caption">リスト2.21: リスト2.21: Breakpoint例外のcauseを定義する (eei.veryl)</span>
<pre class="list language-CsrCause">    enum CsrCause: UIntX {
        BREAKPOINT = 3,
        ENVIRONMENT_CALL_FROM_M_MODE = 11,
    }
</pre>
</div>
<p>IDステージでEBREAK命令を判定して、tvalにPCを設定します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.breakpoint-range.idex">リスト2.22</a></span>)。</p>
<div id="core.veryl.breakpoint-range.idex" class="caption-code">
<span class="caption">リスト2.22: リスト2.22: IDステージでEBREAK命令を判定する (core.veryl)</span>
<pre class="list language-idex">        exq_wdata.expt = 0;
        <b>if ids_inst_bits == 32'h00000073 {</b>
            // ECALL
            exq_wdata.expt.valid = <b>1;</b>
            exq_wdata.expt.cause = CsrCause::ENVIRONMENT_CALL_FROM_M_MODE;
            exq_wdata.expt.value = 0;
        <b>} else if ids_inst_bits == 32'h00100073 {</b>
            <b>// EBREAK</b>
            <b>exq_wdata.expt.valid = 1;</b>
            <b>exq_wdata.expt.cause = CsrCause::BREAKPOINT;</b>
            <b>exq_wdata.expt.value = ids_pc;</b>
        <b>}</b>
</pre>
</div>

<h2 class="numbox"><a id="h2-4"></a><span class="secno">2.4</span> Illegal instruction例外の実装</h2>
<p>Illegal instruction例外は、現在の環境で実行できない命令を実行しようとしたときに発生する例外です。causeは<code class="inline-code">2</code>で、tvalは例外が発生した命令のビット列になります。</p>
<p>本章では、EEIが認識できない不正な命令ビット列を実行しようとした場合と、読み込み専用のCSRに書き込もうとした場合の2つの状況で例外を発生させます。</p>

<h3 class="none"><a id="h2-4-1"></a><span class="secno">2.4.1</span> 不正な命令ビット列で例外を起こす</h3>
<p>CPUに実装していない命令、つまりデコードできない命令を実行しようとするとき、Illegal instruction例外が発生します。</p>
<p>今のところopcodeが未知の命令は何もしない命令として実行し、それ以外の命令については何も対処していません。ここで、inst_decoderモジュールを、未知の命令であることを報告するように変更します。</p>
<p>inst_decoderモジュールに、命令が有効かどうかを示す<code class="inline-code">valid</code>ポートを追加します(<span class="listref"><a href="./11-impl-exception.html#inst_decoder.veryl.instillegal-range.port">リスト2.23</a></span>、<span class="listref"><a href="./11-impl-exception.html#core.veryl.instillegal-range.ids">リスト2.24</a></span>)。</p>
<div id="inst_decoder.veryl.instillegal-range.port" class="caption-code">
<span class="caption">リスト2.23: リスト2.23: validポートを追加する (inst_decoder.veryl)</span>
<pre class="list language-port">module inst_decoder (
    bits : input  Inst    ,
    <b>valid: output logic   ,</b>
    ctrl : output InstCtrl,
    imm  : output UIntX   ,
) {
</pre>
</div>
<div id="core.veryl.instillegal-range.ids" class="caption-code">
<span class="caption">リスト2.24: リスト2.24: inst_decoderモジュールのvalidポートと変数を接続する (core.veryl)</span>
<pre class="list language-ids">    let ids_valid     : logic    = if_fifo_rvalid;
    let ids_pc        : Addr     = if_fifo_rdata.addr;
    let ids_inst_bits : Inst     = if_fifo_rdata.bits;
    <b>var ids_inst_valid: logic   ;</b>
    var ids_ctrl      : InstCtrl;
    var ids_imm       : UIntX   ;

    inst decoder: inst_decoder (
        bits : ids_inst_bits ,
        <b>valid: ids_inst_valid,</b>
        ctrl : ids_ctrl      ,
        imm  : ids_imm       ,
    );
</pre>
</div>
<p>今のところ実装してある命令を有効な命令として判定する処理をalways_combブロックに記述します(<span class="listref"><a href="./11-impl-exception.html#inst_decoder.veryl.instillegal-range.valid">リスト2.25</a></span>)。</p>
<div id="inst_decoder.veryl.instillegal-range.valid" class="caption-code">
<span class="caption">リスト2.25: リスト2.25: 命令の有効判定を行う (inst_decoder.veryl)</span>
<pre class="list language-valid">valid = case op {
    OP_LUI, OP_AUIPC, OP_JAL, OP_JALR: T,
    OP_BRANCH                        : f3 != 3'b010 &amp;&amp; f3 != 3'b011,
    OP_LOAD                          : f3 != 3'b111,
    OP_STORE                         : f3[2] == 1'b0,
    OP_OP                            : case f7 {
        7'b0000000                       : T, // RV32I
        7'b0100000                       : f3 == 3'b000 || f3 == 3'b101, // SUB, SRA
        7'b0000001                       : T, // RV32M
        default                          : F,
    },
    OP_OP_IMM: case f3 {
        3'b001   : f7[6:1] == 6'b000000, // SLLI (RV64I)
        3'b101   : f7[6:1] == 6'b000000 || f7[6:1] == 6'b010000, // SRLI, SRAI (RV64I)
        default  : T,
    },
    OP_OP_32  : case f7 {
        7'b0000001: f3 == 3'b000 || f3[2] == 1'b1, // RV64M
        7'b0000000: f3 == 3'b000 || f3 == 3'b001 || f3 == 3'b101, // ADDW, SLLW, SRLW
        7'b0100000: f3 == 3'b000 || f3 == 3'b101, // SUBW, SRAW
        default   : F,
    },
    OP_OP_IMM_32: case f3 {
        3'b000      : T, // ADDIW
        3'b001      : f7 == 7'b0000000, // SLLIW
        3'b101      : f7 == 7'b0000000 || f7 == 7'b0100000, // SRLIW, SRAIW
        default     : F,
    },
    OP_SYSTEM: f3 != 3'b000 &amp;&amp; f3 != 3'b100 || // CSRR(W|S|C)[I]
     bits == 32'h00000073 || // ECALL
     bits == 32'h00100073 || // EBREAK
     bits == 32'h30200073, //MRET
    OP_MISC_MEM: T, // FENCE
    default    : F,
};
</pre>
</div>
<p>riscv-testsでメモリ読み書きの順序を保証するFENCE命令<sup><a id="fnb-memory.order" href="#fn-memory.order" class="noteref" epub:type="noteref">*4</a></sup>を使用しているため、opcodeがOP-MISCである命令を合法な命令として取り扱っています。OP-MISCのopcode(<code class="inline-code">7'b0001111</code>)をeeiパッケージに定義してください(<span class="listref"><a href="./11-impl-exception.html#eei.veryl.instillegal-range.op">リスト2.26</a></span>)。</p>
<div id="eei.veryl.instillegal-range.op" class="caption-code">
<span class="caption">リスト2.26: リスト2.26: OP-MISCのビット列を定義する (eei.veryl)</span>
<pre class="list language-op">    const OP_MISC_MEM : logic&lt;7&gt; = 7'b0001111;
</pre>
</div>
<div class="footnote-list">
<div class="footnote" id="fn-memory.order" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*4] </span>基本編で実装するCPUはロードストア命令を直列に実行するため順序を保証する必要がありません。そのためFENCE命令は何もしない命令として扱います。</p></div>
</div><!--/.footnote-list-->
<p><code class="inline-code">CsrCause</code>型にIllegal instruction例外のcauseを追加します(<span class="listref"><a href="./11-impl-exception.html#eei.veryl.instillegal-range.CsrCause">リスト2.27</a></span>)。</p>
<div id="eei.veryl.instillegal-range.CsrCause" class="caption-code">
<span class="caption">リスト2.27: リスト2.27: Illegal instruction例外のcauseを定義する (eei.veryl)</span>
<pre class="list language-CsrCause">    enum CsrCause: UIntX {
        <b>ILLEGAL_INSTRUCTION = 2,</b>
        BREAKPOINT = 3,
        ENVIRONMENT_CALL_FROM_M_MODE = 11,
    }
</pre>
</div>
<p><code class="inline-code">valid</code>フラグを利用して、IDステージでIllegal instruction例外を発生させます(<span class="listref"><a href="./11-impl-exception.html#core.veryl.instillegal-range.idex">リスト2.28</a></span>)。tvalには、命令を右に詰めてゼロで拡張した値を設定します。</p>
<div id="core.veryl.instillegal-range.idex" class="caption-code">
<span class="caption">リスト2.28: リスト2.28: 不正な命令のとき、例外を発生させる (core.veryl)</span>
<pre class="list language-idex">        exq_wdata.expt = 0;
        <b>if !ids_inst_valid {</b>
            <b>// illegal instruction</b>
            <b>exq_wdata.expt.valid = 1;</b>
            <b>exq_wdata.expt.cause = CsrCause::ILLEGAL_INSTRUCTION;</b>
            <b>exq_wdata.expt.value = {1'b0 repeat XLEN - ILEN, ids_inst_bits};</b>
        <b>} else</b> if ids_inst_bits == 32'h00000073 {
</pre>
</div>

<h3 class="none"><a id="h2-4-2"></a><span class="secno">2.4.2</span> 読み込み専用のCSRへの書き込みで例外を起こす</h3>
<p>RISC-VのCSRには読み込み専用のレジスタが存在しており、アドレスの上位2ビットが<code class="inline-code">2'b11</code>のCSRが読み込み専用として定義されています。読み込み専用のCSRに書き込みを行おうとするとIllegal instruction例外が発生します。</p>
<p>CSRに値が書き込まれるのは次のいずれかの場合です。読み書き可能なレジスタ内の読み込み専用のフィールドへの書き込みは例外を引き起こしません。</p>
<ol start="1" type="1">
<li>CSRRW、CSRRWI命令である</li>
<li>CSRRS命令でrs1が0番目のレジスタ以外である</li>
<li>CSRRSI命令で即値が<b>0</b>以外である</li>
<li>CSRRC命令でrs1が0番目のレジスタ以外である</li>
<li>CSRRCI命令で即値が<b>0</b>以外である</li>
</ol>
<p>ソースレジスタの値が<b>0</b>だとしても、0番目のレジスタではない場合にはCSRに書き込むと判断します。CSRに書き込むかどうかを正しく判定するために、csrunitモジュールの<code class="inline-code">rs1</code>ポートを<code class="inline-code">rs1_addr</code>と<code class="inline-code">rs1_data</code>に分解します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.csrro-range.csru">リスト2.30</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.csrro-range.port">リスト2.29</a></span>、<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.csrro-range.wdata">リスト2.31</a></span>)。また、causeを設定するためにcsrunitモジュールに命令のビット列を供給します。</p>
<div id="csrunit.veryl.csrro-range.port" class="caption-code">
<span class="caption">リスト2.29: リスト2.29: csrunitモジュールのポート定義を変更する (csrunit.veryl)</span>
<pre class="list language-port">module csrunit (
    clk        : input  clock            ,
    rst        : input  reset            ,
    valid      : input  logic            ,
    pc         : input  Addr             ,
    <b>inst_bits  : input  Inst             ,</b>
    ctrl       : input  InstCtrl         ,
    expt_info  : input  ExceptionInfo    ,
    rd_addr    : input  logic        &lt;5&gt; ,
    csr_addr   : input  logic        &lt;12&gt;,
    <b>rs1_addr   : input  logic        &lt;5&gt; ,</b>
    <b>rs1_data   : input  UIntX            ,</b>
    rdata      : output UIntX            ,
    raise_trap : output logic            ,
    trap_vector: output Addr             ,
    led        : output UIntX            ,
) {
</pre>
</div>
<div id="core.veryl.csrro-range.csru" class="caption-code">
<span class="caption">リスト2.30: リスト2.30: csrunitモジュールのポート定義を変更する (core.veryl)</span>
<pre class="list language-csru">    inst csru: csrunit (
        clk                               ,
        rst                               ,
        valid      : mems_valid           ,
        pc         : mems_pc              ,
        <b>inst_bits  : mems_inst_bits       ,</b>
        ctrl       : mems_ctrl            ,
        expt_info  : mems_expt            ,
        rd_addr    : mems_rd_addr         ,
        csr_addr   : <b>mems_inst_bits[31:20],</b>
        <b>rs1_addr   : memq_rdata.rs1_addr  ,</b>
        <b>rs1_data   : memq_rdata.rs1_data  ,</b>
        rdata      : csru_rdata           ,
        raise_trap : csru_raise_trap      ,
        trap_vector: csru_trap_vector     ,
        led                               ,
    );
</pre>
</div>
<div id="csrunit.veryl.csrro-range.wdata" class="caption-code">
<span class="caption">リスト2.31: リスト2.31: rs1の変更に対応する&lt;sup&gt;&lt;a id=&quot;fnb-fix-wmask-bug&quot; href=&quot;#fn-fix-wmask-bug&quot; class=&quot;noteref&quot; epub:type=&quot;noteref&quot;&gt;*5&lt;/a&gt;&lt;/sup&gt; (csrunit.veryl)</span>
<pre class="list language-wdata">    <b>let wsource: UIntX = if ctrl.funct3[2] ? {1'b0 repeat XLEN - 5, rs1_addr} : rs1_data;</b>
    wdata   = case ctrl.funct3[1:0] {
        2'b01  : <b>wsource</b>,
        2'b10  : rdata | <b>wsource</b>,
        2'b11  : rdata &amp; ~<b>wsource</b>,
        default: 'x,
    } &amp; wmask | (rdata &amp; ~wmask);
</pre>
</div>
<div class="footnote-list">
<div class="footnote" id="fn-fix-wmask-bug" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*5] </span>基本編 第1部の初版の<code class="inline-code">wdata</code>の生成ロジックに間違いがあったので訂正してあります。</p></div>
</div><!--/.footnote-list-->
<p>命令のfunct3とrs1のアドレスを利用して、書き込み先が読み込み専用レジスタかどうかを判定します<sup><a id="fnb-it-can-be-id" href="#fn-it-can-be-id" class="noteref" epub:type="noteref">*6</a></sup>(<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.csrro-range.check">リスト2.32</a></span>)。また、命令のビット列を利用できるようになったので、MRET命令の判定を命令のビット列の比較に書き換えています。</p>
<div id="csrunit.veryl.csrro-range.check" class="caption-code">
<span class="caption">リスト2.32: リスト2.32: 読み込み専用CSRへの書き込みが発生するか判定する (csrunit.veryl)</span>
<pre class="list language-check">    // CSRR(W|S|C)[I]命令かどうか
    let is_wsc: logic = ctrl.is_csr &amp;&amp; ctrl.funct3[1:0] != 0;
    // MRET命令かどうか
    let is_mret: logic = inst_bits == 32'h30200073;

    // Check CSR access
    let will_not_write_csr     : logic = (ctrl.funct3[1:0] == 2 || ctrl.funct3[1:0] == 3) &amp;&amp; rs1_addr == 0; // set/clear with source = 0
    let expt_write_readonly_csr: logic = is_wsc &amp;&amp; !will_not_write_csr &amp;&amp; csr_addr[11:10] == 2'b11; // attempt to write read-only CSR
</pre>
</div>
<div class="footnote-list">
<div class="footnote" id="fn-it-can-be-id" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*6] </span>IDステージで判定することもできます。</p></div>
</div><!--/.footnote-list-->
<p>例外が発生するとき、causeとtvalを設定します(<span class="listref"><a href="./11-impl-exception.html#csrunit.veryl.csrro-range.expt">リスト2.33</a></span>)。</p>
<div id="csrunit.veryl.csrro-range.expt" class="caption-code">
<span class="caption">リスト2.33: リスト2.33: 読み込み専用CSRの書き込みで例外を発生させる (csrunit.veryl)</span>
<pre class="list language-expt">    let raise_expt: logic = valid &amp;&amp; (expt_info.valid || expt_write_readonly_csr);
    let expt_cause: UIntX = <b>switch {</b>
        <b>expt_info.valid        :</b> expt_info.cause<b>,</b>
        <b>expt_write_readonly_csr: CsrCause::ILLEGAL_INSTRUCTION,</b>
        <b>default                : 0,</b>
    <b>}</b>;
    let expt_value: UIntX = <b>switch {</b>
        <b>expt_info.valid                            :</b> expt_info.value<b>,</b>
        <b>expt_cause == CsrCause::ILLEGAL_INSTRUCTION: {1'b0 repeat XLEN - $bits(Inst), inst_bits},</b>
        <b>default                                    : 0</b>
    <b>}</b>;
</pre>
</div>
<p>この変更により、レジスタにライトバックするようにデコードされた命令がcsrunitモジュールでトラップを起こすようになりました。トラップが発生するときにWBステージでライトバックしないように変更します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.csrro-range.wbq_type">リスト2.34</a></span>、<span class="listref"><a href="./11-impl-exception.html#core.veryl.csrro-range.memwb">リスト2.35</a></span>、<span class="listref"><a href="./11-impl-exception.html#core.veryl.csrro-range.wb">リスト2.36</a></span>)。</p>
<div id="core.veryl.csrro-range.wbq_type" class="caption-code">
<span class="caption">リスト2.34: リスト2.34: トラップが発生したかを示すlogicをwbq_typeに追加する (core.veryl)</span>
<pre class="list language-wbq_type">    struct wbq_type {
        ...
        csr_rdata : UIntX   ,
        <b>raise_trap: logic   ,</b>
    }
</pre>
</div>
<div id="core.veryl.csrro-range.memwb" class="caption-code">
<span class="caption">リスト2.35: リスト2.35: トラップが発生したかをWBステージに伝える (core.veryl)</span>
<pre class="list language-memwb">    wbq_wdata.raise_trap = csru_raise_trap;
</pre>
</div>
<div id="core.veryl.csrro-range.wb" class="caption-code">
<span class="caption">リスト2.36: リスト2.36: トラップが発生しているとき、レジスタにデータを書き込まないようにする (core.veryl)</span>
<pre class="list language-wb">    always_ff {
        if wbs_valid &amp;&amp; wbs_ctrl.rwb_en &amp;&amp; !wbq_rdata.raise_trap {
            regfile[wbs_rd_addr] = wbs_wb_data;
        }
    }
</pre>
</div>

<h2 id="def-ialign" class="numbox"><a id="h2-5"></a><span class="secno">2.5</span> 命令アドレスのミスアライン例外</h2>
<p>RISC-Vでは、命令アドレスがIALIGNビット境界に整列されていない場合にInstruction address misaligned例外が発生します。causeは<code class="inline-code">0</code>で、tvalは命令のアドレスになります。</p>
<p><a href="./14-impl-c.html">第5章「C拡張の実装」</a>で実装するC拡張が実装されていない場合、IALIGNは<code class="inline-code">32</code>と定義されています。C拡張が定義されている場合は<code class="inline-code">16</code>になります。</p>
<p>IALIGNビット境界に整列されていない命令アドレスになるのはジャンプ命令、分岐命令を実行する場合です<sup><a id="fnb-epc-tvec-mask" href="#fn-epc-tvec-mask" class="noteref" epub:type="noteref">*7</a></sup>。PCの遷移先が整列されていない場合に例外が発生します。分岐命令の場合、分岐が成立する場合にしか例外は発生しません。</p>
<div class="footnote-list">
<div class="footnote" id="fn-epc-tvec-mask" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*7] </span>mepc、mtvecはIALIGNビットに整列されたアドレスしか書き込めないため、遷移先のアドレスは常に整列されています。</p></div>
</div><!--/.footnote-list-->
<p><code class="inline-code">CsrCause</code>型にInstruction address misaligned例外のcauseを追加します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.instmisalign-range.CsrCause">リスト2.37</a></span>)。</p>
<div id="core.veryl.instmisalign-range.CsrCause" class="caption-code">
<span class="caption">リスト2.37: リスト2.37: Instruction address misaligned例外のcauseを定義する (eei.veryl)</span>
<pre class="list language-CsrCause">    enum CsrCause: UIntX {
        <b>INSTRUCTION_ADDRESS_MISALIGNED = 0,</b>
        ILLEGAL_INSTRUCTION = 2,
        BREAKPOINT = 3,
        ENVIRONMENT_CALL_FROM_M_MODE = 11,
    }
</pre>
</div>
<p>EXステージでアドレスを確認して例外を判定します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.instmisalign-range.exmem">リスト2.38</a></span>)。tvalは遷移先のアドレスになることに注意してください。</p>
<div id="core.veryl.instmisalign-range.exmem" class="caption-code">
<span class="caption">リスト2.38: リスト2.38: EXステージでInstruction address misaligned例外の判定を行う (core.veryl)</span>
<pre class="list language-exmem">        memq_wdata.jump_addr  = if inst_is_br(exs_ctrl) ? exs_pc + exs_imm : exs_alu_result &amp; ~1;
        // exception
        <b>let instruction_address_misaligned: logic = memq_wdata.br_taken &amp;&amp; memq_wdata.jump_addr[1:0] != 2'b00;</b>
        memq_wdata.expt                = exq_rdata.expt;
        <b>if !memq_rdata.expt.valid {</b>
        <b>    if instruction_address_misaligned {</b>
        <b>        memq_wdata.expt.valid = 1;</b>
        <b>        memq_wdata.expt.cause = CsrCause::INSTRUCTION_ADDRESS_MISALIGNED;</b>
        <b>        memq_wdata.expt.value = memq_wdata.jump_addr;</b>
        <b>    }</b>
        <b>}</b>
</pre>
</div>

<h2 class="numbox"><a id="h2-6"></a><span class="secno">2.6</span> ロードストア命令のミスアライン例外</h2>
<p>RISC-Vでは、ロード、ストア命令でアクセスするメモリのアドレスが、ロード、ストアするビット幅に整列されていない場合に、それぞれLoad address misaligned例外、Store/AMO address misaligned例外が発生します<sup><a id="fnb-enable-misalign" href="#fn-enable-misalign" class="noteref" epub:type="noteref">*8</a></sup>。例えばLW命令は4バイトに整列されたアドレス、LD命令は8バイトに整列されたアドレスにしかアクセスできません。causeはそれぞれ<code class="inline-code">4</code>、<code class="inline-code">6</code>で、tvalはアクセスするメモリのアドレスになります。</p>
<div class="footnote-list">
<div class="footnote" id="fn-enable-misalign" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*8] </span>例外を発生させず、そのようなメモリアクセスをサポートすることもできます。本書ではCPUを単純に実装するために例外とします。</p></div>
</div><!--/.footnote-list-->
<p><code class="inline-code">CsrCause</code>型に例外のcauseを追加します(<span class="listref"><a href="./11-impl-exception.html#eei.veryl.memmisalign-range.CsrCause">リスト2.39</a></span>)。</p>
<div id="eei.veryl.memmisalign-range.CsrCause" class="caption-code">
<span class="caption">リスト2.39: リスト2.39: 例外のcauseを定義する (eei.veryl)</span>
<pre class="list language-CsrCause">    enum CsrCause: UIntX {
        INSTRUCTION_ADDRESS_MISALIGNED = 0,
        ILLEGAL_INSTRUCTION = 2,
        BREAKPOINT = 3,
        <b>LOAD_ADDRESS_MISALIGNED = 4,</b>
        <b>STORE_AMO_ADDRESS_MISALIGNED = 6,</b>
        ENVIRONMENT_CALL_FROM_M_MODE = 11,
    }
</pre>
</div>
<p>EXステージでアドレスを確認して例外を判定します(<span class="listref"><a href="./11-impl-exception.html#core.veryl.memmisalign-range.expt">リスト2.40</a></span>)。</p>
<div id="core.veryl.memmisalign-range.expt" class="caption-code">
<span class="caption">リスト2.40: リスト2.40: EXステージで例外の判定を行う (core.veryl)</span>
<pre class="list language-expt">        let instruction_address_misaligned: logic = memq_wdata.br_taken &amp;&amp; memq_wdata.jump_addr[1:0] != 2'b00;
        <b>let loadstore_address_misaligned  : logic = inst_is_memop(exs_ctrl) &amp;&amp; case exs_ctrl.funct3[1:0] {</b>
        <b>    2'b00  : 0, // B</b>
        <b>    2'b01  : exs_alu_result[0] != 1'b0, // H</b>
        <b>    2'b10  : exs_alu_result[1:0] != 2'b0, // W</b>
        <b>    2'b11  : exs_alu_result[2:0] != 3'b0, // D</b>
        <b>    default: 0,</b>
        <b>};</b>
        memq_wdata.expt = exq_rdata.expt;
        if !memq_rdata.expt.valid {
            if instruction_address_misaligned {
                memq_wdata.expt.valid = 1;
                memq_wdata.expt.cause = CsrCause::INSTRUCTION_ADDRESS_MISALIGNED;
                memq_wdata.expt.value = memq_wdata.jump_addr;
            <b>} else if loadstore_address_misaligned {</b>
            <b>    memq_wdata.expt.valid = 1;</b>
            <b>    memq_wdata.expt.cause = if exs_ctrl.is_load ? CsrCause::LOAD_ADDRESS_MISALIGNED : CsrCause::STORE_AMO_ADDRESS_MISALIGNED;</b>
            <b>    memq_wdata.expt.value = exs_alu_result;</b>
            }
        }
</pre>
</div>
<p>例外が発生するときにmemunitモジュールが動作しないようにします(<span class="listref"><a href="./11-impl-exception.html#core.veryl.memmisalign-range.memu">リスト2.41</a></span>)。</p>
<div id="core.veryl.memmisalign-range.memu" class="caption-code">
<span class="caption">リスト2.41: リスト2.41: 例外が発生するとき、memunitのvalidを0にする (core.veryl)</span>
<pre class="list language-memu">    inst memu: memunit (
        clk                                   ,
        rst                                   ,
        valid : mems_valid <b>&amp;&amp; !mems_expt.valid</b>,
        is_new: mems_is_new                   ,
        ctrl  : mems_ctrl                     ,
        addr  : memq_rdata.alu_result         ,
        rs2   : memq_rdata.rs2_data           ,
        rdata : memu_rdata                    ,
        stall : memu_stall                    ,
        membus: d_membus                      ,
    );
</pre>
</div>
        </main>
        <nav class="page-navi">
          <a href="10-impl-m.html" class="page-prev">&#9664;</a>
          <a href="12-impl-mmio.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
