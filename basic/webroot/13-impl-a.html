<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>A拡張の実装 | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="C拡張の実装" href="14-impl-c.html">
    <link rel="prev" title="Memory-mapped I/Oの実装" href="12-impl-mmio.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき</a></li>
<li class="toc-part">第I部 RV32I/RV64Iの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./02-setup.html">1 環境構築</a></li>
    <li class="toc-chapter"><a href="./03-veryl.html">2 ハードウェア記述言語 Veryl</a></li>
    <li class="toc-chapter"><a href="./04-impl-rv32i.html">3 RV32Iの実装</a></li>
    <li class="toc-chapter"><a href="./04a-zicsr.html">4 Zicsr拡張の実装</a></li>
    <li class="toc-chapter"><a href="./04b-riscvtests.html">5 riscv-testsによるテスト</a></li>
    <li class="toc-chapter"><a href="./05-impl-rv64i.html">6 RV64Iの実装</a></li>
    <li class="toc-chapter"><a href="./05a-pipeline.html">7 CPUのパイプライン化</a></li>
    <li class="toc-chapter"><a href="./05b-synth.html">8 CPUの合成</a></li>
  </ul>
</li>
<li class="toc-part">第II部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">9 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">10 例外の実装</a></li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">11 Memory-mapped I/Oの実装</a></li>
    <li class="toc-chapter"><a href="./13-impl-a.html">12 A拡張の実装</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./13-impl-a.html#h12-1">12.1 アトミック操作</a></li>
        <li class="toc-section"><a href="./13-impl-a.html#h12-2">12.2 命令のデコード</a></li>
        <li class="toc-section"><a href="./13-impl-a.html#h12-3">12.3 amounitモジュールの作成</a></li>
        <li class="toc-section"><a href="./13-impl-a.html#h12-4">12.4 Zalrsc拡張の実装</a></li>
        <li class="toc-section"><a href="./13-impl-a.html#h12-5">12.5 Zaamo拡張の実装</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./14-impl-c.html">13 C拡張の実装</a></li>
  </ul>
</li>
<li class="toc-part">第III部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">14 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">15 M-modeの実装 (2. 割り込みの実装)</a></li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">16 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">17 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">18 S-modeの実装 (2. 仮想記憶システム)</a></li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">19 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">20 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99-postface.html">あとがき (第Ⅰ部)</a></li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき (第Ⅱ部、第Ⅲ部)</a></li>
    <li class="toc-chapter"><a href="./100-contribute.html">このプロジェクトに貢献する</a></li>
    <li class="toc-chapter"><a href="./bib.html">参考文献</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h12"></a><span class="secno">第12章</span> <br/>A拡張の実装</h1>
<p>本章では、メモリの不可分操作を実現するA拡張を実装します。A拡張にはLoad-Reserved、Store-Conditionalを実現するZalrsc拡張(<span class="tableref"><a href="./13-impl-a.html#a.instructions.zalrsc">表12.2</a></span>)、ロードした値を加工し、その結果をメモリにストアする操作を単一の命令で実装するZaamo拡張(<span class="tableref"><a href="./13-impl-a.html#a.instructions.zaamo">表12.1</a></span>)が含まれています。A拡張の命令を利用すると、同じメモリ空間で複数のソフトウェアを並列、並行して実行するとき、ソフトウェア間で同期をとりながら実行できます。</p>

<h2 class="numbox"><a id="h12-1"></a><span class="secno">12.1</span> アトミック操作</h2>

<h3 class="none"><a id="h12-1-1"></a><span class="secno">12.1.1</span> アトミック操作とは何か？</h3>
<p>アトミック操作(Atomic operation、不可分操作)とは、他のシステムからその操作を観測するとき、1つの操作として観測される操作のことです。つまり、他のシステムは、アトミック操作を行う前、アトミック操作を行った後の状態しか観測できません。</p>
<div id="sampleprogram_2cpu" class="image">
<img src="images/13-impl-a/sampleprogram_2cpu.png" alt="&lt;span class=&quot;imgref&quot;&gt;&lt;a href=&quot;./13-impl-a.html#sampleprogram_1cpu&quot;&gt;図12.2&lt;/a&gt;&lt;/span&gt;のプログラムを2つに分割して2つのCPUで実行する (Xは11になる)" class="img" style="width:80%" />
<p class="caption">
図12.1: <span class="imgref"><a href="./13-impl-a.html#sampleprogram_1cpu">図12.2</a></span>のプログラムを2つに分割して2つのCPUで実行する (Xは11になる)
</p>
</div>
<div id="sampleprogram_1cpu" class="image">
<img src="images/13-impl-a/sampleprogram_1cpu.png" alt="1つのCPUでメモリ上の値を2回インクリメントする (Xは12になる)" class="img" style="width:50%" />
<p class="caption">
図12.2: 1つのCPUでメモリ上の値を2回インクリメントする (Xは12になる)
</p>
</div>
<p>アトミック操作は実行、観測される順序が重要なアプリケーションで利用します。例えば、アドレスXの値をロードして1を足した値を書き戻すプログラムを、2つのコアで同時に実行するとします(<span class="imgref"><a href="./13-impl-a.html#sampleprogram_2cpu">図12.1</a></span>)。このとき命令の実行順序によっては、最終的な値が1つのコアで2回プログラムを実行した場合と異なってしまいます(<span class="imgref"><a href="./13-impl-a.html#sampleprogram_1cpu">図12.2</a></span>)。この状態を避けるためにはロード、加算、ストアをアトミックに行う必要があります。このアトミック操作の実現方法として、A拡張はAMOADD命令、LR命令とSC命令を提供します。</p>

<h3 class="none"><a id="h12-1-2"></a><span class="secno">12.1.2</span> Zaamo拡張</h3>
<p>Zaamo拡張は、値をロードして、演算した値をストアする操作を1つの命令で行う命令を定義しています。AMOADD命令はロード、加算、ストアを行う単一の命令です。Zaamo拡張は他にも簡単な操作を行う命令も提供しています。</p>
<div id="a.instructions.zaamo" class="table">
<p class="caption">表12.1: Zaamo拡張の命令</p>
<table>
<tr class="hline"><th>命令</th><th>動作 (読み込んだ値をレジスタにライトバックする)</th></tr>
<tr class="hline"><td>AMOSWAP.W/D</td><td>メモリから32/64ビット読み込み、<br />rs2の値を書き込む</td></tr>
<tr class="hline"><td>AMOADD.W/D</td><td>メモリから32/64ビット(符号付き)読み込み<br />rs2(符号付き)の値を足して書き込む</td></tr>
<tr class="hline"><td>AMOAND.W/D</td><td>メモリから32/64ビット読み込み<br />rs2の値をAND演算して書き込む</td></tr>
<tr class="hline"><td>AMOOR.W/D</td><td>メモリから32/64ビット読み込み<br />rs2の値をOR演算して書き込む</td></tr>
<tr class="hline"><td>AMOXOR.W/D</td><td>メモリから32/64ビット読み込み<br />rs2の値をXOR演算して書き込む</td></tr>
<tr class="hline"><td>AMOMIN.W/D</td><td>メモリから32/64ビット(符号付き)読み込み<br />rs2(符号付き)の値と比べて小さい値を書き込む</td></tr>
<tr class="hline"><td>AMOMAX.W/D</td><td>メモリから32/64ビット(符号付き)読み込み<br />rs2(符号付き)の値と比べて大きい値をを書き込む</td></tr>
<tr class="hline"><td>AMOMINU.W/D</td><td>メモリから32/64ビット(符号無し)読み込み<br />rs2(符号無し)の値と比べて小さい値を書き込む</td></tr>
<tr class="hline"><td>AMOMAXU.W/D</td><td>メモリから32/64ビット(符号無し)読み込み<br />rs2(符号無し)の値と比べて大きい値を書き込む</td></tr>
</table>
</div>

<h3 class="none"><a id="h12-1-3"></a><span class="secno">12.1.3</span> Zalrsc拡張</h3>
<p>Zalrsc拡張は、LR命令とSC命令を定義しています。LR、SC命令は、それぞれLoad-Reserved、Store-Conditional操作を実現する命令です。それぞれ次のように動作します。</p>
<dl>
<dt>LR命令</dt>
<dd>
   指定されたアドレスのデータを読み込み、指定されたアドレスを予約セット(Reservation set)に登録します。
   ロードしたデータをレジスタにライトバックします。
</dd>
<dt>SC命令</dt>
<dd>
   指定されたアドレスが予約セットに存在する場合、指定されたアドレスにデータを書き込みます(ストア成功)。
   予約セットにアドレスが存在しない場合は書き込みません(ストア失敗)。
   ストアに成功したら<code class="inline-code" translate="no" >0</code>、失敗したら<code class="inline-code" translate="no" >0</code>以外の値をレジスタにライトバックします。
   命令の実行後に必ず予約セットを空にします。
</dd>
</dl>
<p>LR、SC命令を使うことで、アトミックなロード、加算、ストアを次のように記述できます(<span class="listref"><a href="./13-impl-a.html#sample.asm.lrsc">リスト12.1</a></span>)。</p>
<div id="sample.asm.lrsc" class="caption-code">
<span class="caption">リスト12.1: リスト12.1: LR、SC命令によるアトミックな加算</span>
<pre class="list language-lrsc" translate="no"><em class="lineno">1: </em>atomic_add:
<em class="lineno">2: </em>    LR.W x2, (x3) <span class="balloon">← アドレスx3の値をx2にロード</span>
<em class="lineno">3: </em>    ADDI x2, x2, 1 <span class="balloon">← x2に1を足す</span>
<em class="lineno">4: </em>    SC.W x4, x2, (x3) <span class="balloon">← ストアを試行し、結果をx4に格納</span>
<em class="lineno">5: </em>    BNEZ x4, atomic_add <span class="balloon">← SC命令が失敗していたらやり直す</span>
</pre>
</div>
<p>例えば同時に2つのコアが<span class="listref"><a href="./13-impl-a.html#sample.asm.lrsc">リスト12.1</a></span>を実行するとき、同期をとれていない書き込みはSC命令で失敗します。失敗したらLR命令からやり直すことで、1つのコアで2回実行した場合と同一の結果(<code class="inline-code" translate="no" >1</code>を2回加算)になります。</p>
<p>予約セットのサイズは実装によって異なります。</p>
<div id="a.instructions.zalrsc" class="table">
<p class="caption">表12.2: Zalrsc拡張の命令</p>
<table>
<tr class="hline"><th>命令</th><th>動作</th></tr>
<tr class="hline"><td>LR.W/D</td><td>メモリから32/64ビット読み込み、予約セットにアドレスを登録する<br />読み込んだ値をレジスタにライトバックする</td></tr>
<tr class="hline"><td>SC.W/D</td><td>予約セットにrs1の値が登録されている場合、メモリにrs2の値を書き込み<br />0をレジスタにライトバックする。予約セットにアドレスが登録されていない場合<br />メモリに書き込まず、0以外の値をレジスタにライトバックする。<br />命令の実行後に予約セットを空にする</td></tr>
</table>
</div>

<h3 class="none"><a id="h12-1-4"></a><span class="secno">12.1.4</span> 命令の順序</h3>
<p>A拡張の命令のビット列は、それぞれ1ビットのaq、rlビットを含んでいます。このビットは、他のコアやハードウェアスレッドからメモリ操作を観測したときにメモリ操作がどのような順序で観測されるかを制御するものです。</p>
<p>A拡張の命令をAとするとき、それぞれのビットの状態に応じて、Aによるメモリ操作は次のように観測されます。</p>
<dl>
<dt>aq=0、rl=0</dt>
<dd>
    Aの前後でメモリ操作の順序は保証されません。
</dd>
<dt>aq=1、rl=0</dt>
<dd>
    Aの後ろにあるメモリを操作する命令は、Aのメモリ操作の後に観測されることが保証されます。
</dd>
<dt>aq=0、rl=1</dt>
<dd>
    Aのメモリ操作は、Aの前にあるメモリを操作する命令が観測できるようになった後に観測されることが保証されます。
</dd>
<dt>aq=1、rl=1</dt>
<dd>
    Aのメモリ操作は、Aの前にあるメモリを操作する命令よりも後、Aの後ろにあるメモリを操作する命令よりも前に観測されることが保証されます。
</dd>
</dl>
<p>今のところ、CPUはメモリ操作を１命令ずつ直列に実行するため、常にaqが<code class="inline-code" translate="no" >1</code>、rlが<code class="inline-code" translate="no" >1</code>であるように動作します。そのため、本章ではaq、rlビットを考慮しないで実装を行います<sup><a id="fnb-impl-memory-order" href="#fn-impl-memory-order" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-impl-memory-order" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>メモリ操作の並び替えによる高速化は応用編で検討します。</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h12-2"></a><span class="secno">12.2</span> 命令のデコード</h2>
<p>A拡張の命令はすべてR形式で、opcodeはOP-AMO(<code class="inline-code" translate="no" >7'b0101111</code>)です。それぞれの命令はfunct5(<span class="listref"><a href="./13-impl-a.html#eei.veryl.define.AMOOp">リスト12.3</a></span>)とfunct3(Wは<code class="inline-code" translate="no" >2</code>、Dは<code class="inline-code" translate="no" >3</code>)で区別できます。</p>
<p>eeiパッケージにOP-AMOの定数を定義します(<span class="listref"><a href="./13-impl-a.html#eei.veryl.define.op">リスト12.2</a></span>)。</p>
<div id="eei.veryl.define.op" class="caption-code">
<span class="caption">リスト12.2: リスト12.2: OP-AMOの定義 (eei.veryl)</span>
<pre class="list language-op" translate="no"><em class="lineno">1: </em>    const OP_AMO      : logic&lt;7&gt; = 7'b0101111;
</pre>
</div>
<p>A拡張の命令を区別するための列挙型<code class="inline-code" translate="no" >AMOOp</code>を定義します(<span class="listref"><a href="./13-impl-a.html#eei.veryl.define.AMOOp">リスト12.3</a></span>)。それぞれ命令のfunct5と対応しています。</p>
<div id="eei.veryl.define.AMOOp" class="caption-code">
<span class="caption">リスト12.3: リスト12.3: AMOOp型の定義 (eei.veryl)</span>
<pre class="list language-AMOOp" translate="no"><em class="lineno">1: </em>    enum AMOOp: logic&lt;5&gt; {
<em class="lineno">2: </em>        LR = 5'b00010,
<em class="lineno">3: </em>        SC = 5'b00011,
<em class="lineno">4: </em>        SWAP = 5'b00001,
<em class="lineno">5: </em>        ADD = 5'b00000,
<em class="lineno">6: </em>        XOR = 5'b00100,
<em class="lineno">7: </em>        AND = 5'b01100,
<em class="lineno">8: </em>        OR = 5'b01000,
<em class="lineno">9: </em>        MIN = 5'b10000,
<em class="lineno">10: </em>        MAX = 5'b10100,
<em class="lineno">11: </em>        MINU = 5'b11000,
<em class="lineno">12: </em>        MAXU = 5'b11100,
<em class="lineno">13: </em>    }
</pre>
</div>

<h3 class="none"><a id="h12-2-1"></a><span class="secno">12.2.1</span> is_amoフラグを実装する</h3>
<p><code class="inline-code" translate="no" >InstCtrl</code>構造体に、A拡張の命令であることを示す<code class="inline-code" translate="no" >is_amo</code>フラグを追加します(<span class="listref"><a href="./13-impl-a.html#corectrl.veryl.define.is_amo">リスト12.4</a></span>)。</p>
<div id="corectrl.veryl.define.is_amo" class="caption-code">
<span class="caption">リスト12.4: リスト12.4: InstCtrlにis_amoを定義する (corectrl.veryl)</span>
<pre class="list language-is_amo" translate="no"><em class="lineno">1: </em>    struct InstCtrl {
<em class="lineno">2: </em>        itype    : InstType   , // 命令の形式
<em class="lineno">3: </em>        rwb_en   : logic      , // レジスタに書き込むかどうか
<em class="lineno">4: </em>        is_lui   : logic      , // LUI命令である
<em class="lineno">5: </em>        is_aluop : logic      , // ALUを利用する命令である
<em class="lineno">6: </em>        is_muldiv: logic      , // M拡張の命令である
<em class="lineno">7: </em>        is_op32  : logic      , // OP-32またはOP-IMM-32である
<em class="lineno">8: </em>        is_jump  : logic      , // ジャンプ命令である
<em class="lineno">9: </em>        is_load  : logic      , // ロード命令である
<em class="lineno">10: </em>        is_csr   : logic      , // CSR命令である
<em class="lineno">11: </em>        <b>is_amo   : logic      , // AMO instruction</b>
<em class="lineno">12: </em>        funct3   : logic   &lt;3&gt;, // 命令のfunct3フィールド
<em class="lineno">13: </em>        funct7   : logic   &lt;7&gt;, // 命令のfunct7フィールド
<em class="lineno">14: </em>    }
</pre>
</div>
<p>命令がメモリにアクセスするかを判定するinst_is_memop関数を、<code class="inline-code" translate="no" >is_amo</code>フラグを利用するように変更します(<span class="listref"><a href="./13-impl-a.html#corectrl.veryl.define.inst_is_memop">リスト12.5</a></span>)。</p>
<div id="corectrl.veryl.define.inst_is_memop" class="caption-code">
<span class="caption">リスト12.5: リスト12.5: A拡張の命令がメモリにアクセスする命令と判定する (corectrl.veryl)</span>
<pre class="list language-inst_is_memop" translate="no"><em class="lineno">1: </em>    function inst_is_memop (
<em class="lineno">2: </em>        ctrl: input InstCtrl,
<em class="lineno">3: </em>    ) -&gt; logic {
<em class="lineno">4: </em>        return ctrl.itype == InstType::S || ctrl.is_load <b>|| ctrl.is_amo</b>;
<em class="lineno">5: </em>    }
</pre>
</div>
<p>inst_decoderモジュールの<code class="inline-code" translate="no" >InstCtrl</code>を生成している部分を変更します。opcodeが<code class="inline-code" translate="no" >OP-AMO</code>のとき、<code class="inline-code" translate="no" >is_amo</code>を<code class="inline-code" translate="no" >T</code>に設定します(<span class="listref"><a href="./13-impl-a.html#inst_decoder.veryl.define.ctrl">リスト12.6</a></span>)。その他のopcodeの<code class="inline-code" translate="no" >is_amo</code>は<code class="inline-code" translate="no" >F</code>に設定してください。</p>
<div id="inst_decoder.veryl.define.ctrl" class="caption-code">
<span class="caption">リスト12.6: リスト12.6: is_amoフラグを追加する (inst_decoder.veryl)</span>
<pre class="list language-ctrl" translate="no"><em class="lineno">1: </em>                OP_SYSTEM: {
<em class="lineno">2: </em>                    InstType::I, T, F, F, F, F, F, F, T<b>, F</b>
<em class="lineno">3: </em>                },
<em class="lineno">4: </em>                OP_AMO: {
<em class="lineno">5: </em>                    InstType::R, T, F, F, F, F, F, F, F<b>, T</b>
<em class="lineno">6: </em>                },
<em class="lineno">7: </em>                default: {
<em class="lineno">8: </em>                    InstType::X, F, F, F, F, F, F, F, F<b>, F</b>
<em class="lineno">9: </em>                },
</pre>
</div>
<p>また、A拡張の命令が有効な命令として判断されるようにします(<span class="listref"><a href="./13-impl-a.html#inst_decoder.veryl.define.valid">リスト12.7</a></span>)。</p>
<div id="inst_decoder.veryl.define.valid" class="caption-code">
<span class="caption">リスト12.7: リスト12.7: A拡張の命令のとき、validフラグを立てる (inst_decoder.veryl)</span>
<pre class="list language-valid" translate="no"><em class="lineno">1: </em>            OP_MISC_MEM: T, // FENCE
<em class="lineno">2: </em>            <b>OP_AMO     : f3 == 3'b010 || f3 == 3'b011, // AMO</b>
<em class="lineno">3: </em>            default    : F,
</pre>
</div>

<h3 class="none"><a id="h12-2-2"></a><span class="secno">12.2.2</span> アドレスを変更する</h3>
<p>A拡張でアクセスするメモリのアドレスはrs1で指定されたレジスタの値です。これは基本整数命令セットのロードストア命令のアドレス指定方法(rs1と即値を足し合わせる)とは異なるため、memunitモジュールの<code class="inline-code" translate="no" >addr</code>ポートに割り当てる値を<code class="inline-code" translate="no" >is_amo</code>フラグによって切り替えます(<span class="listref"><a href="./13-impl-a.html#core.veryl.define.memu_addr">リスト12.8</a></span>)。</p>
<div id="core.veryl.define.memu_addr" class="caption-code">
<span class="caption">リスト12.8: リスト12.8: メモリアドレスをrs1レジスタの値にする (core.veryl)</span>
<pre class="list language-memu_addr" translate="no"><em class="lineno">1: </em>    var memu_rdata: UIntX;
<em class="lineno">2: </em>    var memu_stall: logic;
<em class="lineno">3: </em>    <b>let memu_addr : Addr  = if mems_ctrl.is_amo ? memq_rdata.rs1_data : memq_rdata.alu_result;</b>
<em class="lineno">4: </em>
<em class="lineno">5: </em>    inst memu: memunit (
<em class="lineno">6: </em>        clk                                   ,
<em class="lineno">7: </em>        rst                                   ,
<em class="lineno">8: </em>        valid : mems_valid &amp;&amp; !mems_expt.valid,
<em class="lineno">9: </em>        is_new: mems_is_new                   ,
<em class="lineno">10: </em>        ctrl  : mems_ctrl                     ,
<em class="lineno">11: </em>        <b>addr  : memu_addr                     ,</b>
<em class="lineno">12: </em>        rs2   : memq_rdata.rs2_data           ,
<em class="lineno">13: </em>        rdata : memu_rdata                    ,
<em class="lineno">14: </em>        stall : memu_stall                    ,
<em class="lineno">15: </em>        membus: d_membus                      ,
<em class="lineno">16: </em>    );
</pre>
</div>
<p>A拡張の命令のメモリアドレスが、操作するデータの幅に整列されていないとき、Store/AMO address misaligned例外が発生します。この例外はストア命令の場合の例外と同じです。</p>
<p>EXステージの例外判定でアドレスを使っている部分を変更します(<span class="listref"><a href="./13-impl-a.html#core.veryl.define.exception">リスト12.9</a></span>)。causeとtvalの割り当てがストア命令の場合と同じになっていることを確認してください。</p>
<div id="core.veryl.define.exception" class="caption-code">
<span class="caption">リスト12.9: リスト12.9: 例外を判定するアドレスを変更する (core.veryl)</span>
<pre class="list language-exception" translate="no"><em class="lineno">1: </em>        <b>let memaddr                       : Addr  = if exs_ctrl.is_amo ? exs_rs1_data : exs_alu_result;</b>
<em class="lineno">2: </em>        let loadstore_address_misaligned  : logic = inst_is_memop(exs_ctrl) &amp;&amp; case exs_ctrl.funct3[1:0] {
<em class="lineno">3: </em>            2'b00  : 0, // B
<em class="lineno">4: </em>            2'b01  : <b>memaddr</b>[0] != 1'b0, // H
<em class="lineno">5: </em>            2'b10  : <b>memaddr</b>[1:0] != 2'b0, // W
<em class="lineno">6: </em>            2'b11  : <b>memaddr</b>[2:0] != 3'b0, // D
<em class="lineno">7: </em>            default: 0,
<em class="lineno">8: </em>        };
</pre>
</div>

<h3 class="none"><a id="h12-2-3"></a><span class="secno">12.2.3</span> ライトバックする条件を変更する</h3>
<p>A拡張の命令を実行するとき、ロードした値をレジスタにライトバックするように変更します(<span class="listref"><a href="./13-impl-a.html#core.veryl.define.wb_data">リスト12.10</a></span>)。</p>
<div id="core.veryl.define.wb_data" class="caption-code">
<span class="caption">リスト12.10: リスト12.10: メモリからロードした値をライトバックする (core.veryl)</span>
<pre class="list language-wb_data" translate="no"><em class="lineno">1: </em>    let wbs_wb_data: UIntX    = switch {
<em class="lineno">2: </em>        wbs_ctrl.is_lui                    : wbs_imm,
<em class="lineno">3: </em>        wbs_ctrl.is_jump                   : wbs_pc + 4,
<em class="lineno">4: </em>        wbs_ctrl.is_load <b>|| wbs_ctrl.is_amo</b>: wbq_rdata.mem_rdata,
<em class="lineno">5: </em>        wbs_ctrl.is_csr                    : wbq_rdata.csr_rdata,
<em class="lineno">6: </em>        default                            : wbq_rdata.alu_result
<em class="lineno">7: </em>    };
</pre>
</div>

<h2 class="numbox"><a id="h12-3"></a><span class="secno">12.3</span> amounitモジュールの作成</h2>
<p>A拡張は他のコア、ハードウェアスレッドと同期してメモリ操作を行うためのものであるため、A拡張の操作はcoreモジュールの外、メモリよりも前で行います。本書では、coreモジュールとmmio_controllerモジュールの間に、A拡張の命令を処理するamounitモジュールを実装します(<span class="imgref"><a href="./13-impl-a.html#amo-mmio-structure">図12.3</a></span>)。</p>
<div id="amo-mmio-structure" class="image">
<img src="images/13-impl-a/amo-mmio-structure.png" alt="amounitモジュールと他のモジュールの接続" class="img" style="width:90%" />
<p class="caption">
図12.3: amounitモジュールと他のモジュールの接続
</p>
</div>

<h3 class="none"><a id="h12-3-1"></a><span class="secno">12.3.1</span> インターフェースを作成する</h3>
<p>amounitモジュールにA拡張の操作を指示するために、<code class="inline-code" translate="no" >is_amo</code>フラグ、<code class="inline-code" translate="no" >aq</code>ビット、<code class="inline-code" translate="no" >rl</code>ビット、<code class="inline-code" translate="no" >AMOOp</code>型をmembus_ifインターフェースに追加で定義したインターフェースを作成します。</p>
<p><code class="inline-code" translate="no" >src/core_data_if.veryl</code>を作成し、次のように記述します(<span class="listref"><a href="./13-impl-a.html#core_data_if.veryl.empty.all">リスト12.11</a></span>)。</p>
<div id="core_data_if.veryl.empty.all" class="caption-code">
<span class="caption">リスト12.11: リスト12.11: core_data_if.veryl</span>
<pre class="list language-all" translate="no"><em class="lineno">1: </em>import eei::*;
<em class="lineno">2: </em>
<em class="lineno">3: </em>interface core_data_if {
<em class="lineno">4: </em>    var valid : logic                       ;
<em class="lineno">5: </em>    var ready : logic                       ;
<em class="lineno">6: </em>    var addr  : logic&lt;XLEN&gt;                 ;
<em class="lineno">7: </em>    var wen   : logic                       ;
<em class="lineno">8: </em>    var wdata : logic&lt;MEMBUS_DATA_WIDTH&gt;    ;
<em class="lineno">9: </em>    var wmask : logic&lt;MEMBUS_DATA_WIDTH / 8&gt;;
<em class="lineno">10: </em>    var rvalid: logic                       ;
<em class="lineno">11: </em>    var rdata : logic&lt;MEMBUS_DATA_WIDTH&gt;    ;
<em class="lineno">12: </em>
<em class="lineno">13: </em>    var is_amo: logic   ;
<em class="lineno">14: </em>    var aq    : logic   ;
<em class="lineno">15: </em>    var rl    : logic   ;
<em class="lineno">16: </em>    var amoop : AMOOp   ;
<em class="lineno">17: </em>    var funct3: logic&lt;3&gt;;
<em class="lineno">18: </em>
<em class="lineno">19: </em>    modport master {
<em class="lineno">20: </em>        valid : output,
<em class="lineno">21: </em>        ready : input ,
<em class="lineno">22: </em>        addr  : output,
<em class="lineno">23: </em>        wen   : output,
<em class="lineno">24: </em>        wdata : output,
<em class="lineno">25: </em>        wmask : output,
<em class="lineno">26: </em>        rvalid: input ,
<em class="lineno">27: </em>        rdata : input ,
<em class="lineno">28: </em>        is_amo: output,
<em class="lineno">29: </em>        aq    : output,
<em class="lineno">30: </em>        rl    : output,
<em class="lineno">31: </em>        amoop : output,
<em class="lineno">32: </em>        funct3: output,
<em class="lineno">33: </em>    }
<em class="lineno">34: </em>
<em class="lineno">35: </em>    modport slave {
<em class="lineno">36: </em>        ..converse(master)
<em class="lineno">37: </em>    }
<em class="lineno">38: </em>
<em class="lineno">39: </em>    modport all_input {
<em class="lineno">40: </em>        ..input
<em class="lineno">41: </em>    }
<em class="lineno">42: </em>}
</pre>
</div>

<h3 class="none"><a id="h12-3-2"></a><span class="secno">12.3.2</span> amounitモジュールの作成</h3>
<p>メモリ操作をcoreモジュールからそのままmmio_controllerモジュールに受け渡しするだけのモジュールを作成します。<code class="inline-code" translate="no" >src/amounit.veryl</code>を作成し、次のように記述します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.empty.all">リスト12.12</a></span>)。</p>
<div id="amounit.veryl.empty.all" class="caption-code">
<span class="caption">リスト12.12: リスト12.12: amounit.veryl</span>
<pre class="list language-all" translate="no"><em class="lineno">1: </em>import eei::*;
<em class="lineno">2: </em>
<em class="lineno">3: </em>module amounit (
<em class="lineno">4: </em>    clk   : input   clock              ,
<em class="lineno">5: </em>    rst   : input   reset              ,
<em class="lineno">6: </em>    slave : modport core_data_if::slave,
<em class="lineno">7: </em>    master: modport Membus::master     ,
<em class="lineno">8: </em>) {
<em class="lineno">9: </em>
<em class="lineno">10: </em>    enum State {
<em class="lineno">11: </em>        Init,
<em class="lineno">12: </em>        WaitReady,
<em class="lineno">13: </em>        WaitValid,
<em class="lineno">14: </em>    }
<em class="lineno">15: </em>
<em class="lineno">16: </em>    var state      : State;
<em class="lineno">17: </em>    inst slave_saved: core_data_if;
<em class="lineno">18: </em>
<em class="lineno">19: </em>    // masterをリセットする
<em class="lineno">20: </em>    function reset_master () {
<em class="lineno">21: </em>        master.valid = 0;
<em class="lineno">22: </em>        master.addr  = 0;
<em class="lineno">23: </em>        master.wen   = 0;
<em class="lineno">24: </em>        master.wdata = 0;
<em class="lineno">25: </em>        master.wmask = 0;
<em class="lineno">26: </em>    }
<em class="lineno">27: </em>
<em class="lineno">28: </em>    // masterに要求を割り当てる
<em class="lineno">29: </em>    function assign_master (
<em class="lineno">30: </em>        addr : input Addr                   ,
<em class="lineno">31: </em>        wen  : input logic                  ,
<em class="lineno">32: </em>        wdata: input UIntX                  ,
<em class="lineno">33: </em>        wmask: input logic&lt;$size(UIntX) / 8&gt;,
<em class="lineno">34: </em>    ) {
<em class="lineno">35: </em>        master.valid = 1;
<em class="lineno">36: </em>        master.addr  = addr;
<em class="lineno">37: </em>        master.wen   = wen;
<em class="lineno">38: </em>        master.wdata = wdata;
<em class="lineno">39: </em>        master.wmask = wmask;
<em class="lineno">40: </em>    }
<em class="lineno">41: </em>
<em class="lineno">42: </em>    // 新しく要求を受け入れる
<em class="lineno">43: </em>    function accept_request_comb () {
<em class="lineno">44: </em>        if slave.ready &amp;&amp; slave.valid {
<em class="lineno">45: </em>            assign_master(slave.addr, slave.wen, slave.wdata, slave.wmask);
<em class="lineno">46: </em>        }
<em class="lineno">47: </em>    }
<em class="lineno">48: </em>
<em class="lineno">49: </em>    // slaveに結果を割り当てる
<em class="lineno">50: </em>    always_comb {
<em class="lineno">51: </em>        slave.ready  = 0;
<em class="lineno">52: </em>        slave.rvalid = 0;
<em class="lineno">53: </em>        slave.rdata  = 0;
<em class="lineno">54: </em>
<em class="lineno">55: </em>        case state {
<em class="lineno">56: </em>            State::Init: {
<em class="lineno">57: </em>                slave.ready = 1;
<em class="lineno">58: </em>            }
<em class="lineno">59: </em>            State::WaitValid: {
<em class="lineno">60: </em>                slave.ready  = master.rvalid;
<em class="lineno">61: </em>                slave.rvalid = master.rvalid;
<em class="lineno">62: </em>                slave.rdata  = master.rdata;
<em class="lineno">63: </em>            }
<em class="lineno">64: </em>            default: {}
<em class="lineno">65: </em>        }
<em class="lineno">66: </em>    }
<em class="lineno">67: </em>
<em class="lineno">68: </em>    // masterに要求を割り当てる
<em class="lineno">69: </em>    always_comb {
<em class="lineno">70: </em>        reset_master();
<em class="lineno">71: </em>        case state {
<em class="lineno">72: </em>            State::Init     : accept_request_comb();
<em class="lineno">73: </em>            State::WaitReady: {
<em class="lineno">74: </em>                assign_master(slave_saved.addr, slave_saved.wen, slave_saved.wdata, slave_saved.wmask);
<em class="lineno">75: </em>            }
<em class="lineno">76: </em>            State::WaitValid: accept_request_comb();
<em class="lineno">77: </em>            default         : {}
<em class="lineno">78: </em>        }
<em class="lineno">79: </em>    }
<em class="lineno">80: </em>
<em class="lineno">81: </em>    // 新しく要求を受け入れる
<em class="lineno">82: </em>    function accept_request_ff () {
<em class="lineno">83: </em>        slave_saved.valid = slave.ready &amp;&amp; slave.valid;
<em class="lineno">84: </em>        if slave.ready &amp;&amp; slave.valid {
<em class="lineno">85: </em>            slave_saved.addr   = slave.addr;
<em class="lineno">86: </em>            slave_saved.wen    = slave.wen;
<em class="lineno">87: </em>            slave_saved.wdata  = slave.wdata;
<em class="lineno">88: </em>            slave_saved.wmask  = slave.wmask;
<em class="lineno">89: </em>            slave_saved.is_amo = slave.is_amo;
<em class="lineno">90: </em>            slave_saved.amoop  = slave.amoop;
<em class="lineno">91: </em>            slave_saved.aq     = slave.aq;
<em class="lineno">92: </em>            slave_saved.rl     = slave.rl;
<em class="lineno">93: </em>            slave_saved.funct3 = slave.funct3;
<em class="lineno">94: </em>            state              = if master.ready ? State::WaitValid : State::WaitReady;
<em class="lineno">95: </em>        } else {
<em class="lineno">96: </em>            state = State::Init;
<em class="lineno">97: </em>        }
<em class="lineno">98: </em>    }
<em class="lineno">99: </em>
<em class="lineno">100: </em>    function on_clock () {
<em class="lineno">101: </em>        case state {
<em class="lineno">102: </em>            State::Init     : accept_request_ff();
<em class="lineno">103: </em>            State::WaitReady: if master.ready {
<em class="lineno">104: </em>                state = State::WaitValid;
<em class="lineno">105: </em>            }
<em class="lineno">106: </em>            State::WaitValid: if master.rvalid {
<em class="lineno">107: </em>                accept_request_ff();
<em class="lineno">108: </em>            }
<em class="lineno">109: </em>            default: {}
<em class="lineno">110: </em>        }
<em class="lineno">111: </em>    }
<em class="lineno">112: </em>
<em class="lineno">113: </em>    function on_reset () {
<em class="lineno">114: </em>        state              = State::Init;
<em class="lineno">115: </em>        slave_saved.addr   = 0;
<em class="lineno">116: </em>        slave_saved.wen    = 0;
<em class="lineno">117: </em>        slave_saved.wdata  = 0;
<em class="lineno">118: </em>        slave_saved.wmask  = 0;
<em class="lineno">119: </em>        slave_saved.is_amo = 0;
<em class="lineno">120: </em>        slave_saved.amoop  = 0 as AMOOp;
<em class="lineno">121: </em>        slave_saved.aq     = 0;
<em class="lineno">122: </em>        slave_saved.rl     = 0;
<em class="lineno">123: </em>        slave_saved.funct3 = 0;
<em class="lineno">124: </em>    }
<em class="lineno">125: </em>
<em class="lineno">126: </em>    always_ff {
<em class="lineno">127: </em>        if_reset {
<em class="lineno">128: </em>            on_reset();
<em class="lineno">129: </em>        } else {
<em class="lineno">130: </em>            on_clock();
<em class="lineno">131: </em>        }
<em class="lineno">132: </em>    }
<em class="lineno">133: </em>}
</pre>
</div>
<p>amounitモジュールは<code class="inline-code" translate="no" >State::Init</code>、(<code class="inline-code" translate="no" >State::WaitReady</code>、)<code class="inline-code" translate="no" >State::WaitValid</code>の順に状態を移動し、通常のロードストア命令を処理します。</p>
<p>coreモジュールのロードストア用のインターフェースをmembus_ifからcore_data_ifに変更します(<span class="listref"><a href="./13-impl-a.html#core.veryl.empty.port">リスト12.13</a></span>、<span class="listref"><a href="./13-impl-a.html#top.veryl.empty.port">リスト12.14</a></span>、<span class="listref"><a href="./13-impl-a.html#top.veryl.empty.core">リスト12.15</a></span>)。</p>
<div id="core.veryl.empty.port" class="caption-code">
<span class="caption">リスト12.13: リスト12.13: d_membusの型を変更する (core.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>    i_membus: modport membus_if::&lt;ILEN, XLEN&gt;::master,
<em class="lineno">2: </em>    d_membus: modport <b>core_data_if</b>::master           ,
<em class="lineno">3: </em>    led     : output  UIntX                          ,
</pre>
</div>
<div id="top.veryl.empty.port" class="caption-code">
<span class="caption">リスト12.14: リスト12.14: core_data_ifインターフェースのインスタンス化 (top.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>    inst d_membus_core: core_data_if;
</pre>
</div>
<div id="top.veryl.empty.core" class="caption-code">
<span class="caption">リスト12.15: リスト12.15: ポートに割り当てるインターフェースを変更する (top.veryl)</span>
<pre class="list language-core" translate="no"><em class="lineno">1: </em>    inst c: core (
<em class="lineno">2: </em>        clk                    ,
<em class="lineno">3: </em>        rst                    ,
<em class="lineno">4: </em>        i_membus               ,
<em class="lineno">5: </em>        <b>d_membus: d_membus_core,</b>
<em class="lineno">6: </em>        led                    ,
<em class="lineno">7: </em>    );
</pre>
</div>
<p>memunitモジュールのインターフェースも変更し、<code class="inline-code" translate="no" >is_amo</code>、<code class="inline-code" translate="no" >aq</code>、<code class="inline-code" translate="no" >rl</code>、<code class="inline-code" translate="no" >amoop</code>に値を割り当てます(<span class="listref"><a href="./13-impl-a.html#memunit.veryl.empty.port">リスト12.16</a></span>、<span class="listref"><a href="./13-impl-a.html#memunit.veryl.empty.reg">リスト12.17</a></span>、<span class="listref"><a href="./13-impl-a.html#memunit.veryl.empty.assign">リスト12.19</a></span>、<span class="listref"><a href="./13-impl-a.html#memunit.veryl.empty.reset">リスト12.18</a></span>、<span class="listref"><a href="./13-impl-a.html#memunit.veryl.empty.Init">リスト12.20</a></span>)。</p>
<div id="memunit.veryl.empty.port" class="caption-code">
<span class="caption">リスト12.16: リスト12.16: membusの型を変更する (memunit.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>    stall : output  logic               , // メモリアクセス命令が完了していない
<em class="lineno">2: </em>    membus: modport <b>core_data_if</b>::master, // メモリとのinterface
<em class="lineno">3: </em>) {
</pre>
</div>
<div id="memunit.veryl.empty.reg" class="caption-code">
<span class="caption">リスト12.17: リスト12.17: 一時保存するレジスタの定義 (memunit.veryl)</span>
<pre class="list language-reg" translate="no"><em class="lineno">1: </em>    var req_wen   : logic                       ;
<em class="lineno">2: </em>    var req_addr  : Addr                        ;
<em class="lineno">3: </em>    var req_wdata : logic&lt;MEMBUS_DATA_WIDTH&gt;    ;
<em class="lineno">4: </em>    var req_wmask : logic&lt;MEMBUS_DATA_WIDTH / 8&gt;;
<em class="lineno">5: </em>    <b>var req_is_amo: logic                       ;</b>
<em class="lineno">6: </em>    <b>var req_amoop : AMOOp                       ;</b>
<em class="lineno">7: </em>    <b>var req_aq    : logic                       ;</b>
<em class="lineno">8: </em>    <b>var req_rl    : logic                       ;</b>
<em class="lineno">9: </em>    <b>var req_funct3: logic&lt;3&gt;                    ;</b>
</pre>
</div>
<div id="memunit.veryl.empty.reset" class="caption-code">
<span class="caption">リスト12.18: リスト12.18: レジスタをリセットする (memunit.veryl)</span>
<pre class="list language-reset" translate="no"><em class="lineno">1: </em>    always_ff {
<em class="lineno">2: </em>        if_reset {
<em class="lineno">3: </em>            state      = State::Init;
<em class="lineno">4: </em>            req_wen    = 0;
<em class="lineno">5: </em>            req_addr   = 0;
<em class="lineno">6: </em>            req_wdata  = 0;
<em class="lineno">7: </em>            req_wmask  = 0;
<em class="lineno">8: </em>            <b>req_is_amo = 0;</b>
<em class="lineno">9: </em>            <b>req_amoop  = 0 as AMOOp;</b>
<em class="lineno">10: </em>            <b>req_aq     = 0;</b>
<em class="lineno">11: </em>            <b>req_rl     = 0;</b>
<em class="lineno">12: </em>            <b>req_funct3 = 0;</b>
<em class="lineno">13: </em>        } else {
</pre>
</div>
<div id="memunit.veryl.empty.assign" class="caption-code">
<span class="caption">リスト12.19: リスト12.19: membusにレジスタの値を割り当てる (memunit.veryl)</span>
<pre class="list language-assign" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        // メモリアクセス
<em class="lineno">3: </em>        membus.valid  = state == State::WaitReady;
<em class="lineno">4: </em>        membus.addr   = req_addr;
<em class="lineno">5: </em>        membus.wen    = req_wen;
<em class="lineno">6: </em>        membus.wdata  = req_wdata;
<em class="lineno">7: </em>        membus.wmask  = req_wmask;
<em class="lineno">8: </em>        <b>membus.is_amo = req_is_amo;</b>
<em class="lineno">9: </em>        <b>membus.amoop  = req_amoop;</b>
<em class="lineno">10: </em>        <b>membus.aq     = req_aq;</b>
<em class="lineno">11: </em>        <b>membus.rl     = req_rl;</b>
<em class="lineno">12: </em>        <b>membus.funct3 = req_funct3;</b>
</pre>
</div>
<div id="memunit.veryl.empty.Init" class="caption-code">
<span class="caption">リスト12.20: リスト12.20: メモリにアクセスする命令のとき、レジスタに情報を設定する (memunit.veryl)</span>
<pre class="list language-Init" translate="no"><em class="lineno">1: </em>                case state {
<em class="lineno">2: </em>                    State::Init: if is_new &amp; inst_is_memop(ctrl) {
<em class="lineno">3: </em>                        ...
<em class="lineno">4: </em>                        <b>req_is_amo = ctrl.is_amo;</b>
<em class="lineno">5: </em>                        <b>req_amoop  = ctrl.funct7[6:2] as AMOOp;</b>
<em class="lineno">6: </em>                        <b>req_aq     = ctrl.funct7[1];</b>
<em class="lineno">7: </em>                        <b>req_rl     = ctrl.funct7[0];</b>
<em class="lineno">8: </em>                        <b>req_funct3 = ctrl.funct3;</b>
<em class="lineno">9: </em>                    }
<em class="lineno">10: </em>                    State::WaitReady: if membus.ready {
</pre>
</div>
<p>amounitモジュールをtopモジュールでインスタンス化し、coreモジュールとmmio_controllerモジュールのインターフェースを接続します(<span class="listref"><a href="./13-impl-a.html#top.veryl.empty.amou">リスト12.21</a></span>)。</p>
<div id="top.veryl.empty.amou" class="caption-code">
<span class="caption">リスト12.21: リスト12.21: amounitモジュールをインスタンス化する (top.veryl)</span>
<pre class="list language-amou" translate="no"><em class="lineno">1: </em>    inst amou: amounit (
<em class="lineno">2: </em>        clk                  ,
<em class="lineno">3: </em>        rst                  ,
<em class="lineno">4: </em>        slave : d_membus_core,
<em class="lineno">5: </em>        master: d_membus     ,
<em class="lineno">6: </em>    );
</pre>
</div>

<h2 class="numbox"><a id="h12-4"></a><span class="secno">12.4</span> Zalrsc拡張の実装</h2>
<p>Zalrsc拡張の命令を実装します。予約セットのサイズは実装が自由に決めることができるため、本書では1つのアドレスのみ保持できるようにします。</p>

<h3 class="none"><a id="h12-4-1"></a><span class="secno">12.4.1</span> LR.W、LR.D命令を実装する</h3>
<p>32ビット幅、64ビット幅のLR命令を実装します。LR.W命令はmemunitモジュールで64ビットに符号拡張されるため、amounitモジュールでLR.W命令とLR.D命令を区別する必要はありません。</p>
<p>amounitモジュールに予約セットを作成します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.lr.list">リスト12.22</a></span>、<span class="listref"><a href="./13-impl-a.html#amounit.veryl.lr.reset">リスト12.23</a></span>)。<code class="inline-code" translate="no" >is_addr_reserved</code>で、予約セットに有効なアドレスが格納されているかを管理します。</p>
<div id="amounit.veryl.lr.list" class="caption-code">
<span class="caption">リスト12.22: リスト12.22: 予約セットの定義 (amounit.veryl)</span>
<pre class="list language-list" translate="no"><em class="lineno">1: </em>    // lr/sc
<em class="lineno">2: </em>    var is_addr_reserved: logic;
<em class="lineno">3: </em>    var reserved_addr   : Addr ;
</pre>
</div>
<div id="amounit.veryl.lr.reset" class="caption-code">
<span class="caption">リスト12.23: リスト12.23: レジスタをリセットする (amounit.veryl)</span>
<pre class="list language-reset" translate="no"><em class="lineno">1: </em>        is_addr_reserved   = 0;
<em class="lineno">2: </em>        reserved_addr      = 0;
</pre>
</div>
<p>LR命令を実行するとき、予約セットにアドレスを登録してロード結果を返すようにします(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.lr.accept_request_comb">リスト12.24</a></span>、<span class="listref"><a href="./13-impl-a.html#amounit.veryl.lr.master_comb">リスト12.25</a></span>、<span class="listref"><a href="./13-impl-a.html#amounit.veryl.lr.accept_request_ff">リスト12.26</a></span>)。既に予約セットが使われている場合はアドレスを上書きします。</p>
<div id="amounit.veryl.lr.accept_request_comb" class="caption-code">
<span class="caption">リスト12.24: リスト12.24: accept_request_comb関数の実装 (amounit.veryl)</span>
<pre class="list language-accept_request_comb" translate="no"><em class="lineno">1: </em>    function accept_request_comb () {
<em class="lineno">2: </em>        if slave.ready &amp;&amp; slave.valid {
<em class="lineno">3: </em>            <b>if slave.is_amo {</b>
<em class="lineno">4: </em>            <b>    case slave.amoop {</b>
<em class="lineno">5: </em>            <b>        AMOOp::LR: assign_master(slave.addr, 0, 0, 0);</b>
<em class="lineno">6: </em>            <b>        default  : {}</b>
<em class="lineno">7: </em>            <b>    }</b>
<em class="lineno">8: </em>            <b>} else {</b>
<em class="lineno">9: </em>                assign_master(slave.addr, slave.wen, slave.wdata, slave.wmask);
<em class="lineno">10: </em>            <b>}</b>
<em class="lineno">11: </em>        }
<em class="lineno">12: </em>    }
</pre>
</div>
<div id="amounit.veryl.lr.master_comb" class="caption-code">
<span class="caption">リスト12.25: リスト12.25: LR命令のときにmasterにロード要求を割り当てる (amounit.veryl)</span>
<pre class="list language-master_comb" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        reset_master();
<em class="lineno">3: </em>        case state {
<em class="lineno">4: </em>            State::Init     : accept_request_comb();
<em class="lineno">5: </em>            <b>State::WaitReady: if slave_saved.is_amo {</b>
<em class="lineno">6: </em>            <b>    case slave_saved.amoop {</b>
<em class="lineno">7: </em>            <b>        AMOOp::LR: assign_master(slave_saved.addr, 0, 0, 0);</b>
<em class="lineno">8: </em>            <b>        default  : {}</b>
<em class="lineno">9: </em>            <b>    }</b>
<em class="lineno">10: </em>            <b>} else {</b>
<em class="lineno">11: </em>                assign_master(slave_saved.addr, slave_saved.wen, slave_saved.wdata, slave_saved.wmask);
<em class="lineno">12: </em>            <b>}</b>
</pre>
</div>
<div id="amounit.veryl.lr.accept_request_ff" class="caption-code">
<span class="caption">リスト12.26: リスト12.26: LR命令のときに予約セットを設定する (amounit.veryl)</span>
<pre class="list language-accept_request_ff" translate="no"><em class="lineno">1: </em>    function accept_request_ff () {
<em class="lineno">2: </em>        slave_saved.valid = slave.ready &amp;&amp; slave.valid;
<em class="lineno">3: </em>        if slave.ready &amp;&amp; slave.valid {
<em class="lineno">4: </em>            slave_saved.addr   = slave.addr;
<em class="lineno">5: </em>            ...
<em class="lineno">6: </em>            slave_saved.funct3 = slave.funct3;
<em class="lineno">7: </em>            <b>if slave.is_amo {</b>
<em class="lineno">8: </em>            <b>    case slave.amoop {</b>
<em class="lineno">9: </em>            <b>        AMOOp::LR: {</b>
<em class="lineno">10: </em>            <b>            // reserve address</b>
<em class="lineno">11: </em>            <b>            is_addr_reserved = 1;</b>
<em class="lineno">12: </em>            <b>            reserved_addr    = slave.addr;</b>
<em class="lineno">13: </em>            <b>            state            = if master.ready ? State::WaitValid : State::WaitReady;</b>
<em class="lineno">14: </em>            <b>        }</b>
<em class="lineno">15: </em>            <b>        default: {}</b>
<em class="lineno">16: </em>            <b>    }</b>
<em class="lineno">17: </em>            <b>} else {</b>
<em class="lineno">18: </em>                state = if master.ready ? State::WaitValid : State::WaitReady;
<em class="lineno">19: </em>            <b>}</b>
</pre>
</div>

<h3 class="none"><a id="h12-4-2"></a><span class="secno">12.4.2</span> SC.W、SC.D命令を実装する</h3>
<p>32ビット幅、64ビット幅のSC命令を実装します。SC.W命令はmemunitモジュールで書き込みマスクを設定しているため、amounitモジュールでSC.W命令とSC.D命令を区別する必要はありません。</p>
<p>SC命令が成功、失敗したときに結果を返すための状態を<code class="inline-code" translate="no" >State</code>型に追加します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.sc.State">リスト12.27</a></span>)。</p>
<div id="amounit.veryl.sc.State" class="caption-code">
<span class="caption">リスト12.27: リスト12.27: SC命令用の状態の定義 (amounit.veryl)</span>
<pre class="list language-State" translate="no"><em class="lineno">1: </em>    enum State {
<em class="lineno">2: </em>        Init,
<em class="lineno">3: </em>        WaitReady,
<em class="lineno">4: </em>        WaitValid,
<em class="lineno">5: </em>        <b>SCSuccess,</b>
<em class="lineno">6: </em>        <b>SCFail,</b>
<em class="lineno">7: </em>    }
</pre>
</div>
<p>それぞれの状態で結果を返し、新しく要求を受け入れるようにします(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.sc.assign_slave">リスト12.28</a></span>)。<code class="inline-code" translate="no" >State::SCSuccess</code>はSC命令に成功してストアが終わったときに結果を返します。成功したら<code class="inline-code" translate="no" >0</code>、失敗したら<code class="inline-code" translate="no" >1</code>を返します。</p>
<div id="amounit.veryl.sc.assign_slave" class="caption-code">
<span class="caption">リスト12.28: リスト12.28: slaveにSC命令の結果を割り当てる (amounit.veryl)</span>
<pre class="list language-assign_slave" translate="no"><em class="lineno">1: </em>    State::SCSuccess: {
<em class="lineno">2: </em>        slave.ready  = master.rvalid;
<em class="lineno">3: </em>        slave.rvalid = master.rvalid;
<em class="lineno">4: </em>        slave.rdata  = 0;
<em class="lineno">5: </em>    }
<em class="lineno">6: </em>    State::SCFail: {
<em class="lineno">7: </em>        slave.ready  = 1;
<em class="lineno">8: </em>        slave.rvalid = 1;
<em class="lineno">9: </em>        slave.rdata  = 1;
<em class="lineno">10: </em>    }
</pre>
</div>
<p>SC命令を受け入れるときに予約セットを確認し、アドレスが予約セットのアドレスと異なる場合は状態を<code class="inline-code" translate="no" >State::SCFail</code>に移動します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.sc.accept_request_ff">リスト12.29</a></span>)。成功、失敗に関係なく、予約セットを空にします。</p>
<div id="amounit.veryl.sc.accept_request_ff" class="caption-code">
<span class="caption">リスト12.29: リスト12.29: accept_request_ff関数で予約セットを確認する (amounit.veryl)</span>
<pre class="list language-accept_request_ff" translate="no"><em class="lineno">1: </em>    AMOOp::SC: {
<em class="lineno">2: </em>        // reset reserved
<em class="lineno">3: </em>        let prev            : logic = is_addr_reserved;
<em class="lineno">4: </em>        is_addr_reserved = 0;
<em class="lineno">5: </em>        // check
<em class="lineno">6: </em>        if prev &amp;&amp; slave.addr == reserved_addr {
<em class="lineno">7: </em>            state = if master.ready ? State::SCSuccess : State::WaitReady;
<em class="lineno">8: </em>        } else {
<em class="lineno">9: </em>            state = State::SCFail;
<em class="lineno">10: </em>        }
<em class="lineno">11: </em>    }
</pre>
</div>
<p>SC命令でメモリの<code class="inline-code" translate="no" >ready</code>が<code class="inline-code" translate="no" >1</code>になるのを待っているとき、<code class="inline-code" translate="no" >ready</code>が<code class="inline-code" translate="no" >1</code>になったら状態を<code class="inline-code" translate="no" >State::SCSuccess</code>に移動します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.sc.on_clock">リスト12.30</a></span>)。また、命令の実行が終了したときに新しく要求を受け入れるようにします。</p>
<div id="amounit.veryl.sc.on_clock" class="caption-code">
<span class="caption">リスト12.30: リスト12.30: SC命令の状態遷移 (amounit.veryl)</span>
<pre class="list language-on_clock" translate="no"><em class="lineno">1: </em>    function on_clock () {
<em class="lineno">2: </em>        case state {
<em class="lineno">3: </em>            State::Init     : accept_request_ff();
<em class="lineno">4: </em>            State::WaitReady: if master.ready {
<em class="lineno">5: </em>                <b>if slave_saved.is_amo &amp;&amp; slave_saved.amoop == AMOOp::SC {</b>
<em class="lineno">6: </em>                <b>    state = State::SCSuccess;</b>
<em class="lineno">7: </em>                <b>} else {</b>
<em class="lineno">8: </em>                    state = State::WaitValid;
<em class="lineno">9: </em>                <b>}</b>
<em class="lineno">10: </em>            }
<em class="lineno">11: </em>            State::WaitValid: if master.rvalid {
<em class="lineno">12: </em>                accept_request_ff();
<em class="lineno">13: </em>            }
<em class="lineno">14: </em>            <b>State::SCSuccess: if master.rvalid {</b>
<em class="lineno">15: </em>            <b>    accept_request_ff();</b>
<em class="lineno">16: </em>            <b>}</b>
<em class="lineno">17: </em>            <b>State::SCFail: accept_request_ff();</b>
<em class="lineno">18: </em>            default      : {}
<em class="lineno">19: </em>        }
<em class="lineno">20: </em>    }
</pre>
</div>
<p>SC命令によるメモリへの書き込みを実装します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.sc.accept_request_comb">リスト12.31</a></span>、<span class="listref"><a href="./13-impl-a.html#amounit.veryl.sc.master_comb">リスト12.32</a></span>)。</p>
<div id="amounit.veryl.sc.accept_request_comb" class="caption-code">
<span class="caption">リスト12.31: リスト12.31: accept_request_comb関数で、予約セットをチェックしてからストアを要求する (amounit.veryl)</span>
<pre class="list language-accept_request_comb" translate="no"><em class="lineno">1: </em>    case slave.amoop {
<em class="lineno">2: </em>        AMOOp::LR: assign_master(slave.addr, 0, 0, 0);
<em class="lineno">3: </em>        <b>AMOOp::SC: if is_addr_reserved &amp;&amp; slave.addr == reserved_addr {</b>
<em class="lineno">4: </em>        @&lt;b&gt;     assign_master(slave.addr, 1, slave.wdata, slave.wmask);|
<em class="lineno">5: </em>        @&lt;b&gt; }|
<em class="lineno">6: </em>        default: {}
<em class="lineno">7: </em>    }
</pre>
</div>
<div id="amounit.veryl.sc.master_comb" class="caption-code">
<span class="caption">リスト12.32: リスト12.32: masterに値を割り当てる (amounit.veryl)</span>
<pre class="list language-master_comb" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        reset_master();
<em class="lineno">3: </em>        case state {
<em class="lineno">4: </em>            State::Init     : accept_request_comb();
<em class="lineno">5: </em>            State::WaitReady: if slave_saved.is_amo {
<em class="lineno">6: </em>                case slave_saved.amoop {
<em class="lineno">7: </em>                    AMOOp::LR: assign_master(slave_saved.addr, 0, 0, 0);
<em class="lineno">8: </em>                    <b>AMOOp::SC: assign_master(slave_saved.addr, 1, slave_saved.wdata, slave_saved.wmask);</b>
<em class="lineno">9: </em>                    default  : {}
<em class="lineno">10: </em>                }
<em class="lineno">11: </em>            } else {
<em class="lineno">12: </em>                assign_master(slave_saved.addr, slave_saved.wen, slave_saved.wdata, slave_saved.wmask);
<em class="lineno">13: </em>            }
<em class="lineno">14: </em>            State::WaitValid               : accept_request_comb();
<em class="lineno">15: </em>            <b>State::SCFail, State::SCSuccess: accept_request_comb();</b>
<em class="lineno">16: </em>            default                        : {}
<em class="lineno">17: </em>        }
<em class="lineno">18: </em>    }
</pre>
</div>

<h2 class="numbox"><a id="h12-5"></a><span class="secno">12.5</span> Zaamo拡張の実装</h2>
<p>Zaamo拡張の命令はロード、演算、ストアを行います。本章では、Zaamo拡張の命令を<code class="inline-code" translate="no" >State::Init</code>(、<code class="inline-code" translate="no" >State::AMOLoadReady</code>)、<code class="inline-code" translate="no" >State::AMOLoadValid</code>(、<code class="inline-code" translate="no" >State::AMOStoreReady</code>)、<code class="inline-code" translate="no" >State::AMOStoreValid</code>という状態遷移で処理するように実装します。</p>
<p><code class="inline-code" translate="no" >State</code>型に新しい状態を定義してください(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.State">リスト12.33</a></span>)。</p>
<div id="amounit.veryl.zaamo.State" class="caption-code">
<span class="caption">リスト12.33: リスト12.33: Zaamo拡張の命令用の状態の定義 (amounit.veryl)</span>
<pre class="list language-State" translate="no"><em class="lineno">1: </em>    enum State {
<em class="lineno">2: </em>        Init,
<em class="lineno">3: </em>        WaitReady,
<em class="lineno">4: </em>        WaitValid,
<em class="lineno">5: </em>        SCSuccess,
<em class="lineno">6: </em>        SCFail,
<em class="lineno">7: </em>        <b>AMOLoadReady,</b>
<em class="lineno">8: </em>        <b>AMOLoadValid,</b>
<em class="lineno">9: </em>        <b>AMOStoreReady,</b>
<em class="lineno">10: </em>        <b>AMOStoreValid,</b>
<em class="lineno">11: </em>    }
</pre>
</div>
<p>簡単にZalrsc拡張と区別するために、Zaamo拡張による要求かどうかを判定する関数(<code class="inline-code" translate="no" >is_Zaamo</code>)をcore_data_ifインターフェースに作成します(<span class="listref"><a href="./13-impl-a.html#core_data_if.veryl.zaamo.is_Zaamo">リスト12.34</a></span>、<span class="listref"><a href="./13-impl-a.html#core_data_if.veryl.zaamo.master">リスト12.35</a></span>)。modportにimport宣言を追加してください。</p>
<div id="core_data_if.veryl.zaamo.is_Zaamo" class="caption-code">
<span class="caption">リスト12.34: リスト12.34: is_Zaamo関数の定義 (core_data_if.veryl)</span>
<pre class="list language-is_Zaamo" translate="no"><em class="lineno">1: </em>    function is_Zaamo () -&gt; logic {
<em class="lineno">2: </em>        return is_amo &amp;&amp; (amoop != AMOOp::LR &amp;&amp; amoop != AMOOp::SC);
<em class="lineno">3: </em>    }
</pre>
</div>
<div id="core_data_if.veryl.zaamo.master" class="caption-code">
<span class="caption">リスト12.35: リスト12.35: masterにis_Zaamo関数をimportする (core_data_if.veryl)</span>
<pre class="list language-master" translate="no"><em class="lineno">1: </em>    amoop   : output,
<em class="lineno">2: </em>    funct3  : output,
<em class="lineno">3: </em>    <b>is_Zaamo: import,</b>
<em class="lineno">4: </em>}
</pre>
</div>
<p>ロードした値と<code class="inline-code" translate="no" >wdata</code>、フラグを利用して、ストアする値を生成する関数を作成します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.calc_amo">リスト12.36</a></span>)。32ビット演算のとき、下位32ビットと上位32ビットのどちらを使うかをアドレスによって判別しています。</p>
<div id="amounit.veryl.zaamo.calc_amo" class="caption-code">
<span class="caption">リスト12.36: リスト12.36: Zaamo拡張の命令の計算を行う関数の定義 (amounit.veryl)</span>
<pre class="list language-calc_amo" translate="no"><em class="lineno">1: </em>    // AMO ALU
<em class="lineno">2: </em>    function calc_amo::&lt;W: u32&gt; (
<em class="lineno">3: </em>        amoop: input AMOOp   ,
<em class="lineno">4: </em>        wdata: input logic&lt;W&gt;,
<em class="lineno">5: </em>        rdata: input logic&lt;W&gt;,
<em class="lineno">6: </em>    ) -&gt; logic&lt;W&gt; {
<em class="lineno">7: </em>        let lts: logic = $signed(wdata) &lt;: $signed(rdata);
<em class="lineno">8: </em>        let ltu: logic = wdata &lt;: rdata;
<em class="lineno">9: </em>
<em class="lineno">10: </em>        return case amoop {
<em class="lineno">11: </em>            AMOOp::SWAP: wdata,
<em class="lineno">12: </em>            AMOOp::ADD : rdata + wdata,
<em class="lineno">13: </em>            AMOOp::XOR : rdata ^ wdata,
<em class="lineno">14: </em>            AMOOp::AND : rdata &amp; wdata,
<em class="lineno">15: </em>            AMOOp::OR  : rdata | wdata,
<em class="lineno">16: </em>            AMOOp::MIN : if lts ? wdata : rdata,
<em class="lineno">17: </em>            AMOOp::MAX : if !lts ? wdata : rdata,
<em class="lineno">18: </em>            AMOOp::MINU: if ltu ? wdata : rdata,
<em class="lineno">19: </em>            AMOOp::MAXU: if !ltu ? wdata : rdata,
<em class="lineno">20: </em>            default    : 0,
<em class="lineno">21: </em>        };
<em class="lineno">22: </em>    }
<em class="lineno">23: </em>
<em class="lineno">24: </em>    // Zaamo拡張の命令のwdataを生成する
<em class="lineno">25: </em>    function gen_amo_wdata (
<em class="lineno">26: </em>        req  : modport core_data_if::all_input,
<em class="lineno">27: </em>        rdata: input   UIntX                  ,
<em class="lineno">28: </em>    ) -&gt; UIntX {
<em class="lineno">29: </em>        case req.funct3 {
<em class="lineno">30: </em>            3'b010: { // word
<em class="lineno">31: </em>                let low    : logic  = req.addr[2] == 0;
<em class="lineno">32: </em>                let rdata32: UInt32 = if low ? rdata[31:0] : rdata[63:32];
<em class="lineno">33: </em>                let wdata32: UInt32 = if low ? req.wdata[31:0] : req.wdata[63:32];
<em class="lineno">34: </em>                let result : UInt32 = calc_amo::&lt;32&gt;(req.amoop, wdata32, rdata32);
<em class="lineno">35: </em>                return if low ? {rdata[63:32], result} : {result, rdata[31:0]};
<em class="lineno">36: </em>            }
<em class="lineno">37: </em>            3'b011 : return calc_amo::&lt;64&gt;(req.amoop, req.wdata, rdata); // double
<em class="lineno">38: </em>            default: return 0;
<em class="lineno">39: </em>        }
<em class="lineno">40: </em>    }
</pre>
</div>
<p>ロードした値が命令の結果になるため、値を保持するためのレジスタを作成します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.reg">リスト12.37</a></span>、<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.reset">リスト12.38</a></span>)。</p>
<div id="amounit.veryl.zaamo.reg" class="caption-code">
<span class="caption">リスト12.37: リスト12.37: ロードしたデータを格納するレジスタの定義 (amounit.veryl)</span>
<pre class="list language-reg" translate="no"><em class="lineno">1: </em>    // amo
<em class="lineno">2: </em>    var zaamo_fetched_data: UIntX;
</pre>
</div>
<div id="amounit.veryl.zaamo.reset" class="caption-code">
<span class="caption">リスト12.38: リスト12.38: レジスタのリセット (amounit.veryl)</span>
<pre class="list language-reset" translate="no"><em class="lineno">1: </em>        reserved_addr      = 0;
<em class="lineno">2: </em>        <b>zaamo_fetched_data = 0;</b>
<em class="lineno">3: </em>    }
</pre>
</div>
<p>メモリアクセスが終了したら、ロードした値を返します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.assign_slave_comb">リスト12.39</a></span>)。</p>
<div id="amounit.veryl.zaamo.assign_slave_comb" class="caption-code">
<span class="caption">リスト12.39: リスト12.39: 命令の結果を返す (amounit.veryl)</span>
<pre class="list language-assign_slave_comb" translate="no"><em class="lineno">1: </em>    State::AMOStoreValid: {
<em class="lineno">2: </em>        slave.ready  = master.rvalid;
<em class="lineno">3: </em>        slave.rvalid = master.rvalid;
<em class="lineno">4: </em>        slave.rdata  = zaamo_fetched_data;
<em class="lineno">5: </em>    }
</pre>
</div>
<p>状態に基づいて、メモリへのロード、ストア要求を割り当てます(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.accept_request_comb">リスト12.40</a></span>、<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.assign_master_comb">リスト12.41</a></span>)。</p>
<div id="amounit.veryl.zaamo.accept_request_comb" class="caption-code">
<span class="caption">リスト12.40: リスト12.40: accept_request_comb関数で、まずロード要求を行う (amounit.veryl)</span>
<pre class="list language-accept_request_comb" translate="no"><em class="lineno">1: </em>    default: <b>if slave.is_Zaamo()</b> {
<em class="lineno">2: </em>        <b>assign_master(slave.addr, 0, 0, 0);</b>
<em class="lineno">3: </em>    }
</pre>
</div>
<div id="amounit.veryl.zaamo.assign_master_comb" class="caption-code">
<span class="caption">リスト12.41: リスト12.41: 状態に基づいてロード、ストア要求を行う (amounit.veryl)</span>
<pre class="list language-assign_master_comb" translate="no"><em class="lineno">1: </em>    State::AMOLoadReady                      : assign_master      (slave_saved.addr, 0, 0, 0);
<em class="lineno">2: </em>    State::AMOLoadValid, State::AMOStoreReady: {
<em class="lineno">3: </em>        let rdata        : UIntX = if state == State::AMOLoadValid ? master.rdata : zaamo_fetched_data;
<em class="lineno">4: </em>        let wdata        : UIntX = gen_amo_wdata(slave_saved, rdata);
<em class="lineno">5: </em>        assign_master(slave_saved.addr, 1, wdata, slave_saved.wmask);
<em class="lineno">6: </em>    }
<em class="lineno">7: </em>    State::AMOStoreValid: accept_request_comb();
</pre>
</div>
<p><code class="inline-code" translate="no" >master</code>、<code class="inline-code" translate="no" >slave</code>の状態によって<code class="inline-code" translate="no" >state</code>を遷移します(<span class="listref"><a href="./13-impl-a.html#amounit.veryl.zaamo.accept_request_ff">リスト12.42</a></span>)。</p>
<div id="amounit.veryl.zaamo.accept_request_ff" class="caption-code">
<span class="caption">リスト12.42: リスト12.42: accept_request_ff関数で、masterのreadyによって次のstateを決める (amounit.veryl)</span>
<pre class="list language-accept_request_ff" translate="no"><em class="lineno">1: </em>    default: <b>if slave.is_Zaamo()</b> {
<em class="lineno">2: </em>        <b>state = if master.ready ? State::AMOLoadValid : State::AMOLoadReady;</b>
<em class="lineno">3: </em>    }
</pre>
</div>
<div id="amounit.veryl.zaamo.on_clock" class="caption-code">
<span class="caption">リスト12.43: リスト12.43: Zaamo拡張の命令の状態の遷移 (amounit.veryl)</span>
<pre class="list language-on_clock" translate="no"><em class="lineno">1: </em>    State::AMOLoadReady: if master.ready {
<em class="lineno">2: </em>        state = State::AMOLoadValid;
<em class="lineno">3: </em>    }
<em class="lineno">4: </em>    State::AMOLoadValid: if master.rvalid {
<em class="lineno">5: </em>        zaamo_fetched_data = master.rdata;
<em class="lineno">6: </em>        state              = if slave.ready ? State::AMOStoreValid : State::AMOStoreReady;
<em class="lineno">7: </em>    }
<em class="lineno">8: </em>    State::AMOStoreReady: if master.ready {
<em class="lineno">9: </em>        state = State::AMOStoreValid;
<em class="lineno">10: </em>    }
<em class="lineno">11: </em>    State::AMOStoreValid: if master.rvalid {
<em class="lineno">12: </em>        accept_request_ff();
<em class="lineno">13: </em>    }
</pre>
</div>
<p>riscv-testsの<code class="inline-code" translate="no" >rv64ua-p-</code>から始まるテストを実行し、成功することを確認してください。</p>
        </main>
        <nav class="page-navi">
          <a href="12-impl-mmio.html" class="page-prev">&#9664;</a>
          <a href="14-impl-c.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
