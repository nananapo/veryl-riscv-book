<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>Memory-mapped I/Oの実装 | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="A拡張の実装" href="13-impl-a.html">
    <link rel="prev" title="例外の実装" href="11-impl-exception.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき</a></li>
<li class="toc-part">第I部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">1 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">2 例外の実装</a></li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">3 Memory-mapped I/Oの実装</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./12-impl-mmio.html#h3-1">3.1 Memory-mapped I/Oとは何か？</a></li>
        <li class="toc-section"><a href="./12-impl-mmio.html#h3-2">3.2 定数の定義</a></li>
        <li class="toc-section"><a href="./12-impl-mmio.html#h3-3">3.3 mmio_controllerモジュールの作成</a></li>
        <li class="toc-section"><a href="./12-impl-mmio.html#h3-4">3.4 RAMの接続</a></li>
        <li class="toc-section"><a href="./12-impl-mmio.html#h3-5">3.5 ROMの実装</a></li>
        <li class="toc-section"><a href="./12-impl-mmio.html#h3-6">3.6 デバッグ用の入出力デバイスの実装</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./13-impl-a.html">4 A拡張の実装</a></li>
    <li class="toc-chapter"><a href="./14-impl-c.html">5 C拡張の実装</a></li>
  </ul>
</li>
<li class="toc-part">第II部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">6 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">7 M-modeの実装 (2. 割り込みの実装)</a></li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">8 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">9 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">10 S-modeの実装 (2. 仮想記憶システム)</a></li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">11 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">12 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h3"></a><span class="secno">第3章</span> <br/>Memory-mapped I/Oの実装</h1>

<h2 class="numbox"><a id="h3-1"></a><span class="secno">3.1</span> Memory-mapped I/Oとは何か？</h2>
<div id="mmio" class="image">
<img src="images/12-impl-mmio/mmio.png" alt="メモリマップドIOの例" class="img" style="width:40%" />
<p class="caption">
図3.1: メモリマップドIOの例
</p>
</div>
<p>これまでの実装では、CPUに内蔵された1つの大きなメモリ空間、1つのメモリデバイス(memoryモジュール)に命令データを格納、実行し、データのロードストア命令も同じメモリに対して実行してきました。</p>
<p>一般に流通するコンピュータは複数のデバイスに接続されています。CPUが起動すると、読み込み専用の小さなメモリ(ROM)に格納されたプログラムから命令の実行を開始します。プログラムは周辺デバイスの初期化などを行ったあと、動かしたいアプリケーションの命令やデータをRAMに展開して、制御をアプリケーションに移します。</p>
<p>CPUがデバイスにアクセスする方法にはCSRやメモリ空間を経由する方法があります。一般的な方法はメモリ空間を通じてデバイスにアクセスする方法であり、この方式のことを<b>メモリマップドIO</b>(Memory-mapped I/O, <b>MMIO</b>)と呼びます。メモリ空間の一部を、デバイスにアクセスするための空間として扱うことを、メモリ(またはアドレス)に<b>マップ</b>すると呼びます。RAMとROMもメモリデバイスであり、異なるアドレスにマップされています。</p>
<p>本章ではCPUのメモリ部分をRAM(Random Access Memory)<sup><a id="fnb-about-ram" href="#fn-about-ram" class="noteref" epub:type="noteref">*1</a></sup>とROM(Read Only Memory)に分割し、アクセスするアドレスに応じてアクセスするデバイスを切り替える機能を実装します。また、デバッグ用の入出力デバイス(64ビットのレジスタ)も追加します。デバイスとメモリ空間の対応は図<span class="imgref"><a href="./12-impl-mmio.html#mmio">図3.1</a></span>のように設定します。図<span class="imgref"><a href="./12-impl-mmio.html#mmio">図3.1</a></span>のようにメモリがどのように配置されているかを示す図のことを<b>メモリマップ</b>(Memory map)と呼びます。あるメモリ空間の先頭アドレスのことをベースアドレス(base address)と呼ぶことがあります。</p>
<div class="footnote-list">
<div class="footnote" id="fn-about-ram" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>本章では実際のRAMデバイスへのアクセスを実装せずmemoryモジュールで代用します。FPGAに合成するときに実際のデバイスへのアクセスに置き換えます。</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h3-2"></a><span class="secno">3.2</span> 定数の定義</h2>
<p>eeiパッケージに定義しているメモリの定数をRAM用の定数に変更します。また、新しくRAMのベースアドレス、メモリバスのデータ幅、ROMのメモリマップを示す定数を定義してください(<span class="listref"><a href="./12-impl-mmio.html#eei.veryl.memtoram.const">リスト3.1</a></span>)。デバッグ入出力デバイス(レジスタ)の位置は、topモジュールのポートで定義します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.port">リスト3.9</a></span>)。</p>
<div id="eei.veryl.memtoram.const" class="caption-code">
<span class="caption">リスト3.1: リスト3.1: メモリマップの定義 (eei.veryl)</span>
<pre class="list language-const">    // メモリ<b>バス</b>のデータ幅
    const MEM<b>BUS</b>_DATA_WIDTH: u32 = 64;
    <del>// メモリのアドレス幅</del>
    <del>const MEM_ADDR_WIDTH: u32 = 16;</del>

    // RAM
    const RAM_ADDR_WIDTH: u32  = 16;
    const RAM_DATA_WIDTH: u32  = 64;
    const MMAP_RAM_BEGIN: Addr = 'h8000_0000 as Addr;

    // ROM
    const ROM_ADDR_WIDTH: u32  = 9;
    const ROM_DATA_WIDTH: u32  = 64;
    const MMAP_ROM_BEGIN: Addr = 'h1000 as Addr;
    const MMAP_ROM_END  : Addr = MMAP_ROM_BEGIN + 'h3ff as Addr;
</pre>
</div>
<p><code class="inline-code">MEM_DATA_WIDTH</code>、<code class="inline-code">MEM_ADDR_WIDTH</code>を使っている部分を<code class="inline-code">MEMBUS_DATA_WIDTH</code>、<code class="inline-code">XLEN</code>に置き換えます。<code class="inline-code">MEMBUS_DATA_WIDTH</code>と<code class="inline-code">XLEN</code>を使うmembus_ifインターフェースに別名<code class="inline-code">Membus</code>をつけて利用します(<span class="listref"><a href="./12-impl-mmio.html#membus_if.veryl.memtoram.Membus">リスト3.2</a></span><span class="listref"><a href="./12-impl-mmio.html#core.veryl.memtoram.port">リスト3.3</a></span>)。</p>
<div id="membus_if.veryl.memtoram.Membus" class="caption-code">
<span class="caption">リスト3.2: リスト3.2: 定数名を変更する (membus_if.veryl)</span>
<pre class="list language-Membus">alias interface Membus = membus_if::&lt;eei::MEMBUS_DATA_WIDTH, eei::XLEN&gt;;
</pre>
</div>
<div id="core.veryl.memtoram.port" class="caption-code">
<span class="caption">リスト3.3: リスト3.3: Membusに置き換える (core.veryl)</span>
<pre class="list language-port">module core (
    clk     : input   clock                          ,
    rst     : input   reset                          ,
    i_membus: modport membus_if::&lt;ILEN, XLEN&gt;::master,
    d_membus: modport <b>Membus</b>::master                 ,
    led     : output  UIntX                          ,
) {
</pre>
</div>
<div id="memunit.veryl.memtoram.port" class="caption-code">
<span class="caption">リスト3.4: リスト3.4: Membusに置き換える (memunit.veryl)</span>
<pre class="list language-port">    membus: modport <b>Membus</b>::master, // メモリとのinterface
</pre>
</div>
<div id="memunit.veryl.memtoram.var" class="caption-code">
<span class="caption">リスト3.5: リスト3.5: 定数名を変更する (memunit.veryl)</span>
<pre class="list language-var">    var req_wen  : logic                       ;
    var req_addr : Addr                        ;
    var req_wdata: logic&lt;MEM<b>BUS</b>_DATA_WIDTH&gt;    ;
    var req_wmask: logic&lt;MEM<b>BUS</b>_DATA_WIDTH / 8&gt;;

    const W   : u32                      = XLEN;
    let D   : logic&lt;MEM<b>BUS</b>_DATA_WIDTH&gt; = membus.rdata;
    let sext: logic                    = ctrl.funct3[2] == 1'b0;
</pre>
</div>
<p>topモジュールでインスタンス化しているmembus_ifインターフェースのジェネリックパラメータを変更します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.membus">リスト3.6</a></span>)。</p>
<div id="top.veryl.memtoram.membus" class="caption-code">
<span class="caption">リスト3.6: リスト3.6: ジェネリックパラメータを変更する / Membusに置き換える (top.veryl)</span>
<pre class="list language-membus">    inst membus  : membus_if::&lt;<b>RAM</b>_DATA_WIDTH, <b>RAM</b>_ADDR_WIDTH&gt;;
    inst i_membus: membus_if::&lt;ILEN, XLEN&gt;; // 命令フェッチ用
    inst d_membus: <b>Membus</b>; // ロードストア命令用
</pre>
</div>
<p>addr_to_memaddr関数をジェネリック関数にして、呼び出すときにRAMのパラメータを使用するように変更します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.addr_to_memaddr">リスト3.7</a></span>、<span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.arb">リスト3.8</a></span>、)。</p>
<div id="top.veryl.memtoram.addr_to_memaddr" class="caption-code">
<span class="caption">リスト3.7: リスト3.7: addr_to_memaddr関数をジェネリック関数に変更する (top.veryl)</span>
<pre class="list language-addr_to_memaddr">    // アドレスをデータ単位でのアドレスに変換する
    function addr_to_memaddr<b>::&lt;DATA_WIDTH: u32, ADDR_WIDTH: u32&gt;</b> (
        addr: input logic&lt;XLEN&gt;,
    ) -&gt; logic&lt;<b>ADDR_WIDTH</b>&gt; {
        return addr[$clog2(<b>DATA_WIDTH</b> / 8)+:<b>ADDR_WIDTH</b>];
    }
</pre>
</div>
<div id="top.veryl.memtoram.arb" class="caption-code">
<span class="caption">リスト3.8: リスト3.8: ジェネリックパラメータを指定する (top.veryl)</span>
<pre class="list language-arb">        membus.valid = i_membus.valid | d_membus.valid;
        if d_membus.valid {
            membus.addr  = addr_to_memaddr<b>::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;</b>(d_membus.addr);
            membus.wen   = d_membus.wen;
            membus.wdata = d_membus.wdata;
            membus.wmask = d_membus.wmask;
        } else {
            membus.addr  = addr_to_memaddr<b>::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;</b>(i_membus.addr);
            membus.wen   = 0; // 命令フェッチは常に読み込み
            membus.wdata = 'x;
            membus.wmask = 'x;
        }
</pre>
</div>
<p>メモリに読み込むHEXファイルを指定するパラメータの名前を変更します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.port">リスト3.9</a></span>、<span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.inst">リスト3.10</a></span>)。</p>
<div id="top.veryl.memtoram.port" class="caption-code">
<span class="caption">リスト3.9: リスト3.9: パラメータ名を変更する (top.veryl)</span>
<pre class="list language-port">module top #(
    param RAM_FILEPATH_IS_ENV: bit    = 1              ,
    param RAM_FILEPATH       : string = &quot;RAM_FILE_PATH&quot;,
) (
    clk          : input clock,
    rst          : input reset,
    MMAP_DBG_ADDR: input Addr ,
</pre>
</div>
<div id="top.veryl.memtoram.inst" class="caption-code">
<span class="caption">リスト3.10: リスト3.10: パラメータ名を変更する (top.veryl)</span>
<pre class="list language-inst">    inst ram: memory::&lt;<b>RAM</b>_DATA_WIDTH, <b>RAM</b>_ADDR_WIDTH&gt; #(
        FILEPATH_IS_ENV: <b>RAM</b>_FILEPATH_IS_ENV,
        FILEPATH       : <b>RAM</b>_FILEPATH       ,
    ) (
</pre>
</div>
<p>シミュレータ用のC++プログラムも変更します(<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.memtoram.arg">リスト3.11</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.memtoram.env">リスト3.12</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.memtoram.save">リスト3.13</a></span>)。</p>
<div id="tb_verilator.cpp.memtoram.arg" class="caption-code">
<span class="caption">リスト3.11: リスト3.11: 引数の名称を変える (tb_verilator.cpp)</span>
<pre class="list language-arg">    if (argc &lt; 2) {
        std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; <b>RAM</b>_FILE_PATH [CYCLE]&quot; &lt;&lt; std::endl;
        return 1;
    }
</pre>
</div>
<div id="tb_verilator.cpp.memtoram.env" class="caption-code">
<span class="caption">リスト3.12: リスト3.12: 環境変数名を変える (tb_verilator.cpp)</span>
<pre class="list language-env">    // 環境変数でメモリの初期化用ファイルを指定する
    const char* original_env = getenv(&quot;<b>RAM</b>_FILE_PATH&quot;);
    setenv(&quot;<b>RAM</b>_FILE_PATH&quot;, memory_file_path.c_str(), 1);
</pre>
</div>
<div id="tb_verilator.cpp.memtoram.save" class="caption-code">
<span class="caption">リスト3.13: リスト3.13: 環境変数名を変える (tb_verilator.cpp)</span>
<pre class="list language-save">    // 環境変数を元に戻す
    if (original_env != nullptr){
        setenv(&quot;<b>RAM</b>_FILE_PATH&quot;, original_env, 1);
    }
</pre>
</div>

<h2 class="numbox"><a id="h3-3"></a><span class="secno">3.3</span> mmio_controllerモジュールの作成</h2>
<p>アクセスするアドレスに応じてアクセス先のデバイスを切り替えるモジュールを実装します。</p>
<p><code class="inline-code">src/mmio_controller.veryl</code>を作成し、次のように記述します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.emptymmio">リスト3.14</a></span>)。</p>
<div id="mmio_controller.veryl.emptymmio" class="caption-code">
<span class="caption">リスト3.14: リスト3.14: mmio_controller.veryl</span>
<pre class="list language-emptymmio">import eei::*;

module mmio_controller (
    clk     : input   clock        ,
    rst     : input   reset        ,
    req_core: modport Membus::slave,
) {

    enum Device {
        UNKNOWN,
    }

    inst req_saved: Membus;

    var last_device : Device;
    var is_requested: logic ;

    // masterを0でリセットする
    function reset_membus_master (
        master: modport Membus::master_output,
    ) {
        master.valid = 0;
        master.addr  = 0;
        master.wen   = 0;
        master.wdata = 0;
        master.wmask = 0;
    }

    // すべてのデバイスのmasterをリセットする
    function reset_all_device_masters () {}

    // アドレスからデバイスを取得する
    function get_device (
        addr: input Addr,
    ) -&gt; Device {
        return Device::UNKNOWN;
    }

    // デバイスのmasterにreqの情報を割り当てる
    function assign_device_master (
        req: modport Membus::all_input,
    ) {}

    // デバイスのrvalid、rdataをreqに割り当てる
    function assign_device_slave (
        device: input   Device          ,
        req   : modport Membus::response,
    ) {
        req.rvalid = 1;
        req.rdata  = 0;
    }

    // デバイスのreadyを取得する
    function get_device_ready (
        device: input Device,
    ) -&gt; logic {
        return 1;
    }

    // デバイスのrvalidを取得する
    function get_device_rvalid (
        device: input Device,
    ) -&gt; logic {
        return 1;
    }

    // req_coreの割り当て
    always_comb {
        req_core.ready  = 0;
        req_core.rvalid = 0;
        req_core.rdata  = 0;

        if req_saved.valid {
            if is_requested {
                // 結果を返す
                assign_device_slave(last_device, req_core);
                req_core.ready      = get_device_rvalid(last_device);
            }
        } else {
            req_core.ready = 1;
        }
    }

    // デバイスのmasterの割り当て
    always_comb {
        reset_all_device_masters();
        if req_saved.valid {
            if is_requested {
                if get_device_rvalid(last_device) {
                    // 新しく要求を受け入れる
                    if req_core.ready &amp;&amp; req_core.valid {
                        assign_device_master(req_core);
                    }
                }
            } else {
                // デバイスにreq_savedを割り当てる
                assign_device_master(req_saved);
            }
        } else {
            // 新しく要求を受け入れる
            if req_core.ready &amp;&amp; req_core.valid {
                assign_device_master(req_core);
            }
        }
    }

    // 新しく要求を受け入れる
    function accept_request () {
        req_saved.valid = req_core.ready &amp;&amp; req_core.valid;
        if req_core.ready &amp;&amp; req_core.valid {
            last_device  = get_device(req_core.addr);
            is_requested = get_device_ready(last_device);
            // reqを保存
            req_saved.addr  = req_core.addr;
            req_saved.wen   = req_core.wen;
            req_saved.wdata = req_core.wdata;
            req_saved.wmask = req_core.wmask;
        }
    }

    function on_clock () {
        if req_saved.valid {
            if is_requested {
                if get_device_rvalid(last_device) {
                    accept_request();
                }
            } else {
                is_requested = get_device_ready(last_device);
            }
        } else {
            accept_request();
        }
    }

    function on_reset () {
        last_device         = Device::UNKNOWN;
        is_requested        = 0;
        reset_membus_master(req_saved);
    }

    always_ff {
        if_reset {
            on_reset();
        } else {
            on_clock();
        }
    }
}
</pre>
</div>
<p>mmio_controllerモジュールの関数の引数にmembus_ifインターフェースを使うために、新しくmodportを宣言します(<span class="listref"><a href="./12-impl-mmio.html#membus_if.veryl.emptymmio.modport">リスト3.15</a></span>)。</p>
<div id="membus_if.veryl.emptymmio.modport" class="caption-code">
<span class="caption">リスト3.15: リスト3.15: modport宣言を追加する (membus_if.veryl)</span>
<pre class="list language-modport">    modport all_input {
        ..input
    }

    modport response {
        rvalid: output,
        rdata : output,
    }

    modport slave_output {
        ready: output,
        ..same(response)
    }

    modport master_output {
        valid: output,
        addr : output,
        wen  : output,
        wdata: output,
        wmask: output,
    }
</pre>
</div>
<p>mmio_controllerモジュールは<code class="inline-code">req_core</code>からメモリアクセス要求を受け付け、アクセス対象のモジュールからの結果を返すモジュールです。</p>
<p><code class="inline-code">Device</code>型は実装しているデバイスを表現するための列挙型です(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.emptymmio.Device">リスト3.16</a></span>)。まだデバイスを接続していないので、不明なデバイス(<code class="inline-code">Device::UNKNOWN</code>)だけ定義しています。</p>
<div id="mmio_controller.veryl.emptymmio.Device" class="caption-code">
<span class="caption">リスト3.16: リスト3.16: Device型の定義 (mmio_controller.veryl)</span>
<pre class="list language-Device">    enum Device {
        UNKNOWN,
    }
</pre>
</div>
<p>reset_membus_master、reset_all_device_masters関数はインターフェースの値の割り当てを<code class="inline-code">0</code>でリセットするためのユーティリティ関数です。名前がget_device_、assign_deviceから始まる関数は、デバイスの状態を取得したり、インターフェースに値を割り当てる関数です。get_device関数はアドレスに対応する<code class="inline-code">Device</code>を取得する関数です。</p>
<p>always_comb、always_ffブロックはこれらの関数を利用してメモリアクセスを制御します。</p>
<p>always_ffブロックは、メモリアクセス要求の処理中ではない場合とメモリアクセスが終わった場合にメモリアクセス要求を受け入れます。要求を受け入れるとき、<code class="inline-code">req_core</code>の値を<code class="inline-code">req_saved</code>に保存します。</p>
<p>always_combブロックはデバイスにアクセスし<code class="inline-code">req_core</code>に結果を返します。<code class="inline-code">is_requested</code>は、メモリアクセス要求を処理している場合に既にデバイスが要求を受け入れたかを示すフラグです。新しく要求を受け入れるときと<code class="inline-code">is_requested</code>が<code class="inline-code">0</code>のときにデバイスに要求を割り当て、<code class="inline-code">is_requested</code>が<code class="inline-code">1</code>かつ<code class="inline-code">rvalid</code>が<code class="inline-code">1</code>のときに結果を返します。</p>
<p>まだアクセス先のデバイスを実装していないため、常に<code class="inline-code">0</code>を読み込み、<code class="inline-code">ready</code>と<code class="inline-code">rvalid</code>は常に<code class="inline-code">1</code>にして、書き込みは無視します。</p>

<h2 class="numbox"><a id="h3-4"></a><span class="secno">3.4</span> RAMの接続</h2>

<h3 class="none"><a id="h3-4-1"></a><span class="secno">3.4.1</span> mmio_controllerモジュールにRAMを追加する</h3>
<p>mmio_controllerモジュールにRAMとのインターフェースを実装します。</p>
<p><code class="inline-code">Device</code>型にRAMを追加して、アドレスにRAMをマップします(@&lt;list&gt;{mmio_controller.veryl.ram.Device}、&lt;list&gt;{mmio_controller.veryl.ram.get_device})。</p>
<div id="mmio_controller.veryl.ram.Device" class="caption-code">
<span class="caption">リスト3.17: リスト3.17: Device型にRAMを追加する (mmio_controller.veryl)</span>
<pre class="list language-Device">    enum Device {
        UNKNOWN,
        RAM,
    }
</pre>
</div>
<div id="mmio_controller.veryl.ram.get_device" class="caption-code">
<span class="caption">リスト3.18: リスト3.18: get_device関数でRAMの範囲を定義する (mmio_controller.veryl)</span>
<pre class="list language-get_device">    function get_device (
        addr: input Addr,
    ) -&gt; Device {
        <b>if addr &gt;= MMAP_RAM_BEGIN {</b>
        <b>    return Device::RAM;</b>
        <b>}</b>
        return Device::UNKNOWN;
    }
</pre>
</div>
<p>RAMとのインターフェースを追加し、reset_all_device_masters関数に要求をリセットするコードを追加します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.ram.port">リスト3.19</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.ram.reset_all">リスト3.20</a></span>)。</p>
<div id="mmio_controller.veryl.ram.port" class="caption-code">
<span class="caption">リスト3.19: リスト3.19: RAMとのインターフェースを追加する (mmio_controller.veryl)</span>
<pre class="list language-port">module mmio_controller (
    clk       : input   clock         ,
    rst       : input   reset         ,
    req_core  : modport Membus::slave ,
    <b>ram_membus: modport Membus::master,</b>
) {
</pre>
</div>
<div id="mmio_controller.veryl.ram.reset_all" class="caption-code">
<span class="caption">リスト3.20: リスト3.20: インターフェースの要求部分をリセットする (mmio_controller.veryl)</span>
<pre class="list language-reset_all">    function reset_all_device_masters () {
        <b>reset_membus_master(ram_membus);</b>
    }
</pre>
</div>
<p><code class="inline-code">ready</code>、<code class="inline-code">rvalid</code>を取得する関数にRAMを登録します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.ram.get_device_ready">リスト3.21</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.ram.get_device_rvalid">リスト3.22</a></span>)。</p>
<div id="mmio_controller.veryl.ram.get_device_ready" class="caption-code">
<span class="caption">リスト3.21: リスト3.21: インターフェースのreadyを返す (mmio_controller.veryl)</span>
<pre class="list language-get_device_ready">    function get_device_ready (
        device: input Device,
    ) -&gt; logic {
        <b>case device {</b>
        <b>    Device::RAM: return ram_membus.ready;</b>
        <b>    default    : {}</b>
        <b>}</b>
        return 1;
    }
</pre>
</div>
<div id="mmio_controller.veryl.ram.get_device_rvalid" class="caption-code">
<span class="caption">リスト3.22: リスト3.22: インターフェースのrvalidを返す (mmio_controller.veryl)</span>
<pre class="list language-get_device_rvalid">    function get_device_rvalid (
        device: input Device,
    ) -&gt; logic {
        <b>case device {</b>
        <b>    Device::RAM: return ram_membus.rvalid;</b>
        <b>    default    : {}</b>
        <b>}</b>
        return 1;
    }
</pre>
</div>
<p>RAMの<code class="inline-code">rvalid</code>、<code class="inline-code">rdata</code>を<code class="inline-code">req_core</code>に割り当てます(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.ram.assign_device_slave">リスト3.23</a></span>)。</p>
<div id="mmio_controller.veryl.ram.assign_device_slave" class="caption-code">
<span class="caption">リスト3.23: リスト3.23: RAMへのアクセス結果をreqに割り当てる (mmio_controller.veryl)</span>
<pre class="list language-assign_device_slave">    function assign_device_slave (
        device: input   Device          ,
        req   : modport Membus::response,
    ) {
        req.rvalid = 1;
        req.rdata  = 0;
        <b>case device {</b>
        <b>    Device::RAM: req &lt;&gt; ram_membus;</b>
        <b>    default    : {}</b>
        <b>}</b>
    }
</pre>
</div>
<p>RAMのインターフェースに要求を割り当てます(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.ram.assign_device_master">リスト3.24</a></span>)。ここでRAMのベースアドレスを引いたアドレスを割り当てることで、<code class="inline-code">MMAP_RAM_BEGIN</code>が<code class="inline-code">0</code>になるようにしています。</p>
<div id="mmio_controller.veryl.ram.assign_device_master" class="caption-code">
<span class="caption">リスト3.24: リスト3.24: RAMにreqを割り当ててアクセス要求する (mmio_controller.veryl)</span>
<pre class="list language-assign_device_master">    function assign_device_master (
        req: modport Membus::all_input,
    ) {
        <b>case get_device(req.addr) {</b>
        <b>    Device::RAM: {</b>
        <b>        ram_membus      &lt;&gt; req;</b>
        <b>        ram_membus.addr -= MMAP_RAM_BEGIN;</b>
        <b>    }</b>
        <b>    default: {}</b>
        <b>}</b>
    }
</pre>
</div>

<h3 class="none"><a id="h3-4-2"></a><span class="secno">3.4.2</span> RAMとmmio_controllerモジュールを接続する</h3>
<p>topモジュールにmmio_controllerモジュールをインスタンス化し、RAMとmmio_controllerモジュール、mmio_controllerモジュールとcoreモジュールを接続します。</p>
<p>RAMとmmio_controllerモジュールを接続するインターフェース(<code class="inline-code">mmio_ram_membus</code>)、coreモジュールとmmio_controllerモジュールを接続するインターフェース(<code class="inline-code">mmio_membus</code>)を定義し、<code class="inline-code">membus</code>を<code class="inline-code">ram_membus</code>に改名します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.ram.interface">リスト3.25</a></span>、<span class="listref"><a href="./12-impl-mmio.html#top.veryl.ram.ram">リスト3.26</a></span>)。</p>
<div id="top.veryl.ram.interface" class="caption-code">
<span class="caption">リスト3.25: リスト3.25: インターフェースの定義 / インスタンス名を変更する (top.veryl)</span>
<pre class="list language-interface">    <b>inst mmio_membus    : Membus;</b>
    <b>inst mmio_ram_membus: Membus;</b>
    inst <b>ram_</b>membus     : membus_if::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;;
</pre>
</div>
<div id="top.veryl.ram.ram" class="caption-code">
<span class="caption">リスト3.26: リスト3.26: ポート名を変更する (top.veryl)</span>
<pre class="list language-ram">    inst ram: memory::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt; #(
        FILEPATH_IS_ENV: RAM_FILEPATH_IS_ENV,
        FILEPATH       : RAM_FILEPATH       ,
    ) (
        clk               ,
        rst               ,
        <b>membus:</b> <b>ram_</b>membus,
    );
</pre>
</div>
<p>coreモジュールからRAMへのメモリアクセスを調停する処理を、coreモジュールからmmio_controllerモジュールへのアクセスを調停する処理に変更します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.ram.arb">リスト3.27</a></span>)。</p>
<div id="top.veryl.ram.arb" class="caption-code">
<span class="caption">リスト3.27: リスト3.27: 調停する対称をmmio_membusに変更する (top.veryl)</span>
<pre class="list language-arb">    // <b>mmio_controller</b>へのメモリアクセスを調停する
    always_ff {
        if_reset {
            memarb_last_i     = 0;
            memarb_last_iaddr = 0;
        } else {
            if <b>mmio_</b>membus.ready {
                memarb_last_i     = !d_membus.valid;
                memarb_last_iaddr = i_membus.addr;
            }
        }
    }

    always_comb {
        i_membus.ready  = <b>mmio_</b>membus.ready &amp;&amp; !d_membus.valid;
        i_membus.rvalid = <b>mmio_</b>membus.rvalid &amp;&amp; memarb_last_i;
        i_membus.rdata  = if memarb_last_iaddr[2] == 0 ? <b>mmio_</b>membus.rdata[31:0] : mmio_|membus.rdata[63:32];

        d_membus.ready  = <b>mmio_</b>membus.ready;
        d_membus.rvalid = <b>mmio_</b>membus.rvalid &amp;&amp; !memarb_last_i;
        d_membus.rdata  = <b>mmio_</b>membus.rdata;

        <b>mmio_</b>membus.valid = i_membus.valid | d_membus.valid;
        if d_membus.valid {
            <b>mmio_</b>membus.addr  = <b>d_membus.addr</b>;
            <b>mmio_</b>membus.wen   = d_membus.wen;
            <b>mmio_</b>membus.wdata = d_membus.wdata;
            <b>mmio_</b>membus.wmask = d_membus.wmask;
        } else {
            <b>mmio_</b>membus.addr  = <b>i_membus.addr</b>;
            <b>mmio_</b>membus.wen   = 0; // 命令フェッチは常に読み込み
            <b>mmio_</b>membus.wdata = 'x;
            <b>mmio_</b>membus.wmask = 'x;
        }
    }
</pre>
</div>
<p>mmio_controllerをインスタンス化し、RAMと接続します。(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.ram.inst">リスト3.28</a></span>、<span class="listref"><a href="./12-impl-mmio.html#top.veryl.ram.connect">リスト3.29</a></span>)。RAMのアドレスへの変換は調停処理から接続部分に移動しています。</p>
<div id="top.veryl.ram.inst" class="caption-code">
<span class="caption">リスト3.28: リスト3.28: mmio_controllerモジュールをインスタンス化する (top.veryl)</span>
<pre class="list language-inst">    inst mmioc: mmio_controller (
        clk                        ,
        rst                        ,
        req_core  : mmio_membus    ,
        ram_membus: mmio_ram_membus,
    );
</pre>
</div>
<div id="top.veryl.ram.connect" class="caption-code">
<span class="caption">リスト3.29: リスト3.29: mmio_controllerモジュールとRAMを接続する (top.veryl)</span>
<pre class="list language-connect">    always_comb {
        // mmio &lt;&gt; RAM
        ram_membus.valid       = mmio_ram_membus.valid;
        mmio_ram_membus.ready  = ram_membus.ready;
        ram_membus.addr        = addr_to_memaddr::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;(mmio_ram_membus.addr);
        ram_membus.wen         = mmio_ram_membus.wen;
        ram_membus.wdata       = mmio_ram_membus.wdata;
        ram_membus.wmask       = mmio_ram_membus.wmask;
        mmio_ram_membus.rvalid = ram_membus.rvalid;
        mmio_ram_membus.rdata  = ram_membus.rdata;
    }
</pre>
</div>

<h3 id="changepc" class="none"><a id="h3-4-3"></a><span class="secno">3.4.3</span> PCの初期値の変更</h3>
<p>PCの初期値を<code class="inline-code">MMAP_RAM_BEGIN</code>にすることで、RAMのベースアドレスからプログラムの実行を開始するように変更します。eeiパッケージに<code class="inline-code">INITIAL_PC</code>を定義し、PCのリセット時に利用します(<span class="listref"><a href="./12-impl-mmio.html#eei.veryl.ram.pc">リスト3.30</a></span>、<span class="listref"><a href="./12-impl-mmio.html#core.veryl.ram.pc">リスト3.31</a></span>)。</p>
<div id="eei.veryl.ram.pc" class="caption-code">
<span class="caption">リスト3.30: リスト3.30: PCの初期値を定義する (eei.veryl)</span>
<pre class="list language-pc">    // pc on reset
    const INITIAL_PC: Addr = MMAP_RAM_BEGIN;
</pre>
</div>
<div id="core.veryl.ram.pc" class="caption-code">
<span class="caption">リスト3.31: リスト3.31: PCの初期値を設定する (core.veryl)</span>
<pre class="list language-pc">    always_ff {
        if_reset {
            if_pc           = <b>INITIAL_PC</b>;
            if_is_requested = 0;
            if_pc_requested = 0;
            if_fifo_wvalid  = 0;
            if_fifo_wdata   = 0;
        } else {
</pre>
</div>
<p>riscv-testsを実行してRAMにアクセスできているか確認します。今のところriscv-testsはアドレス<code class="inline-code">0</code>から配置されるようにリンクしているため、riscv-testsの<code class="inline-code">env/p/link.ld</code>を変更します(<span class="listref"><a href="./12-impl-mmio.html#link.ld.ram.riscv-tests">リスト3.32</a></span>)。</p>
<div id="link.ld.ram.riscv-tests" class="caption-code">
<span class="caption">リスト3.32: リスト3.32: プログラムの先頭のアドレスを変更する (riscv-tests/env/p/link.ld)</span>
<pre class="list language-riscv-tests">OUTPUT_ARCH( &quot;riscv&quot; )
ENTRY(_start)

SECTIONS
{
  . = <b>0x00000000</b>; <span class="balloon">← 先頭を0x80000000に変更する (戻す)</span>
</pre>
</div>
<p>riscv-testsをビルドしなおし、成果物をtestディレクトリに配置してください。ビルドしなおしたので、HEXファイルを再度生成します(<span class="listref"><a href="./12-impl-mmio.html#terminal.ram.recompile">リスト3.33</a></span>)。</p>
<div id="terminal.ram.recompile" class="cmd-code">
<span class="caption">リスト3.33: リスト3.33: </span>
<pre class="list language-recompile">$ <span class="userinput">cd test</span>
$ <span class="userinput">find share/ -type f -not -name &quot;*.dump&quot; -exec riscv64-unknown-elf-objcopy -O binary {</span> {}.bin \;}
$ <span class="userinput">find share/ -type f -name &quot;*.bin&quot; -exec sh -c &quot;python3 bin2hex.py 8 {</span> &gt; {}.hex&quot; \;}
</pre>
</div>
<p>riscv-testsの終了判定用のアドレスを<code class="inline-code">MMAP_RAM_BEGIN</code>基準のアドレスに変更します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.ram.riscvtests">リスト3.34</a></span>)。</p>
<div id="top.veryl.ram.riscvtests" class="caption-code">
<span class="caption">リスト3.34: リスト3.34: .tohostのアドレスを変更する (top.veryl)</span>
<pre class="list language-riscvtests">    #[ifdef(TEST_MODE)]
    always_ff {
        let RISCVTESTS_TOHOST_ADDR: Addr = <b>MMAP_RAM_BEGIN +</b> 'h1000 as Addr;
        if d_membus.valid &amp;&amp; d_membus.ready &amp;&amp; d_membus.wen == 1 &amp;&amp; d_membus.addr == RISCVTESTS_TOHOST_ADDR &amp;&amp; d_membus.wdata[lsb] == 1'b1 {
            test_success = d_membus.wdata == 1;
            if d_membus.wdata == 1 {
                $display(&quot;riscv-tests success!&quot;);
            } else {
                $display(&quot;riscv-tests failed!&quot;);
                $error  (&quot;wdata : %h&quot;, d_membus.wdata);
            }
            $finish();
        }
    }
</pre>
</div>
<p>riscv-testsを実行し、RAMにアクセスできてテストに成功することを確認してください。</p>

<h2 class="numbox"><a id="h3-5"></a><span class="secno">3.5</span> ROMの実装</h2>

<h3 class="none"><a id="h3-5-1"></a><span class="secno">3.5.1</span> mmio_controllerモジュールにROMを追加する</h3>
<p>mmio_controllerモジュールにROMとのインターフェースを実装します。</p>
<p><code class="inline-code">Device</code>型にROMを追加して、アドレスにROMをマップします(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.Device">リスト3.35</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.get_device">リスト3.36</a></span>)。</p>
<div id="mmio_controller.veryl.rom.Device" class="caption-code">
<span class="caption">リスト3.35: リスト3.35: Device型にROMを変更する (mmio_controller.veryl)</span>
<pre class="list language-Device">    enum Device {
        UNKNOWN,
        RAM,
        <b>ROM,</b>
    }
</pre>
</div>
<div id="mmio_controller.veryl.rom.get_device" class="caption-code">
<span class="caption">リスト3.36: リスト3.36: get_device関数でROMの範囲を定義する (mmio_controller.veryl)</span>
<pre class="list language-get_device">    function get_device (
        addr: input Addr,
    ) -&gt; Device {
        <b>if MMAP_ROM_BEGIN &lt;= addr &amp;&amp; addr &lt;= MMAP_ROM_END {</b>
        <b>    return Device::ROM;</b>
        <b>}</b>
        if addr &gt;= MMAP_RAM_BEGIN {
            return Device::RAM;
        }
        return Device::UNKNOWN;
    }
</pre>
</div>
<p>ROMとのインターフェースを追加します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.port">リスト3.37</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.reset_all">リスト3.38</a></span>)。reset_all_device_masters関数でインターフェースをリセットします。</p>
<div id="mmio_controller.veryl.rom.port" class="caption-code">
<span class="caption">リスト3.37: リスト3.37: ROMとのインターフェースを追加する (mmio_controller.veryl)</span>
<pre class="list language-port">module mmio_controller (
    clk       : input   clock         ,
    rst       : input   reset         ,
    req_core  : modport Membus::slave ,
    ram_membus: modport Membus::master,
    <b>rom_membus: modport Membus::master,</b>
) {
</pre>
</div>
<div id="mmio_controller.veryl.rom.reset_all" class="caption-code">
<span class="caption">リスト3.38: リスト3.38: インターフェースの要求部分をリセットする (mmio_controller.veryl)</span>
<pre class="list language-reset_all">    function reset_all_device_masters () {
        reset_membus_master(ram_membus);
        <b>reset_membus_master(rom_membus);</b>
    }
</pre>
</div>
<p><code class="inline-code">ready</code>、<code class="inline-code">rvalid</code>を取得する関数にROMを登録します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.get_device_ready">リスト3.39</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.get_device_rvalid">リスト3.40</a></span>)。</p>
<div id="mmio_controller.veryl.rom.get_device_ready" class="caption-code">
<span class="caption">リスト3.39: リスト3.39: インターフェースのreadyを返す (mmio_controller.veryl)</span>
<pre class="list language-get_device_ready">        case device {
            Device::RAM: return ram_membus.ready;
            <b>Device::ROM: return rom_membus.ready;</b>
            default    : {}
        }
</pre>
</div>
<div id="mmio_controller.veryl.rom.get_device_rvalid" class="caption-code">
<span class="caption">リスト3.40: リスト3.40: インターフェースのrvalidを返す (mmio_controller.veryl)</span>
<pre class="list language-get_device_rvalid">        case device {
            Device::RAM: return ram_membus.rvalid;
            <b>Device::ROM: return rom_membus.rvalid;</b>
            default    : {}
        }
</pre>
</div>
<p>ROMの<code class="inline-code">rvalid</code>、<code class="inline-code">rdata</code>を<code class="inline-code">req_core</code>に割り当てます(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.assign_device_slave">リスト3.41</a></span>)。</p>
<div id="mmio_controller.veryl.rom.assign_device_slave" class="caption-code">
<span class="caption">リスト3.41: リスト3.41: assign_device_slave関数でROMの結果をreqに割り当てる (mmio_controller.veryl)</span>
<pre class="list language-assign_device_slave">        case device {
            Device::RAM: req &lt;&gt; ram_membus;
            <b>Device::ROM: req &lt;&gt; rom_membus;</b>
            default    : {}
        }
</pre>
</div>
<p>ROMのインターフェースに要求を割り当てます(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.rom.assign_device_master">リスト3.42</a></span>)。RAMと同じようにメモリマップのベースアドレスを引いたアドレスを割り当てます。</p>
<div id="mmio_controller.veryl.rom.assign_device_master" class="caption-code">
<span class="caption">リスト3.42: リスト3.42: get_device関数でROMにreqを割り当ててアクセス要求する (mmio_controller.veryl)</span>
<pre class="list language-assign_device_master">        case get_device(req.addr) {
            Device::RAM: {
                ram_membus      &lt;&gt; req;
                ram_membus.addr -= MMAP_RAM_BEGIN;
            }
            <b>Device::ROM: {</b>
            <b>    rom_membus      &lt;&gt; req;</b>
            <b>    rom_membus.addr -= MMAP_ROM_BEGIN;</b>
            <b>}</b>
            default: {}
        }
</pre>
</div>

<h3 class="none"><a id="h3-5-2"></a><span class="secno">3.5.2</span> ROMの初期値のパラメータを作成する</h3>
<p>topモジュールにROMの初期値を指定するパラメータを定義します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.rom.assign_device_master">リスト3.43</a></span>)。</p>
<div id="top.veryl.rom.assign_device_master" class="caption-code">
<span class="caption">リスト3.43: リスト3.43: パラメータを定義する (top.veryl)</span>
<pre class="list language-assign_device_master">module top #(
    param RAM_FILEPATH_IS_ENV: bit    = 1              ,
    param RAM_FILEPATH       : string = &quot;RAM_FILE_PATH&quot;,
    <b>param ROM_FILEPATH_IS_ENV: bit    = 1              ,</b>
    <b>param ROM_FILEPATH       : string = &quot;ROM_FILE_PATH&quot;,</b>
) (
</pre>
</div>
<p>RAMと同じように、シミュレータ用のプログラムでROMのHEXファイルのパスを指定するようにします。1番目の引数をROM用のHEXファイルのパスに変更し、環境変数<code class="inline-code">ROM_FILE_PATH</code>をその値に設定します(<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.rom.arg">リスト3.44</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.rom.path">リスト3.45</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.rom.cycles">リスト3.46</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.rom.setenv">リスト3.47</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.rom.back">リスト3.48</a></span>)。</p>
<div id="tb_verilator.cpp.rom.arg" class="caption-code">
<span class="caption">リスト3.44: リスト3.44: 引数の名称を変える (tb_verilator.cpp)</span>
<pre class="list language-arg">    if (argc &lt; <b>3</b>) {
        std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; <b>ROM_FILE_PATH</b> RAM_FILE_PATH [CYCLE]&quot; &lt;&lt; std::endl;
        return 1;
    }
</pre>
</div>
<div id="tb_verilator.cpp.rom.path" class="caption-code">
<span class="caption">リスト3.45: リスト3.45: ROMのHEXファイルのパスを生成する (tb_verilator.cpp)</span>
<pre class="list language-path">    // メモリの初期値を格納しているファイル名
    <b>std::string rom_file_path = argv[1];</b>
    std::string ram_file_path = argv[<b>2</b>];
    try {
        // 絶対パスに変換する
        <b>rom_file_path = fs::absolute(rom_file_path).string();</b>
        <b>ram_file_path = fs::absolute(ram_file_path).string();</b>
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; &quot;Invalid memory file path : &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        return 1;
    }
</pre>
</div>
<div id="tb_verilator.cpp.rom.cycles" class="caption-code">
<span class="caption">リスト3.46: リスト3.46: 引数の数が変わったのでインデックスを変更する (tb_verilator.cpp)</span>
<pre class="list language-cycles">    unsigned long long cycles = 0;
    if (argc &gt;= <b>4</b>) {
        std::string cycles_string = argv[<b>3</b>];
        try {
            cycles = stoull(cycles_string);
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; &quot;Invalid number: &quot; &lt;&lt; argv[<b>3</b>] &lt;&lt; std::endl;
            return 1;
        }
    }
</pre>
</div>
<div id="tb_verilator.cpp.rom.setenv" class="caption-code">
<span class="caption">リスト3.47: リスト3.47: 環境変数を変更する (tb_verilator.cpp)</span>
<pre class="list language-setenv">    <b>const char* original_env_rom = getenv(&quot;ROM_FILE_PATH&quot;);</b>
    const char* original_env_ram = getenv(&quot;RAM_FILE_PATH&quot;);
    <b>setenv(&quot;ROM_FILE_PATH&quot;, rom_file_path.c_str(), 1);</b>
    setenv(&quot;RAM_FILE_PATH&quot;, ram_file_path.c_str(), 1);
</pre>
</div>
<div id="tb_verilator.cpp.rom.back" class="caption-code">
<span class="caption">リスト3.48: リスト3.48: 環境変数を元に戻す (tb_verilator.cpp)</span>
<pre class="list language-back">    <b>if (original_env_rom != nullptr){</b>
    <b>    setenv(&quot;ROM_FILE_PATH&quot;, original_env_rom, 1);</b>
    <b>}</b>
    if (original_env_ram != nullptr){
        setenv(&quot;RAM_FILE_PATH&quot;, original_env_ram, 1);
    }
</pre>
</div>
<p>テストを実行するためのPythonプログラムでROMのHEXファイルを指定できるようにします(<span class="listref"><a href="./12-impl-mmio.html#test.py.rom.arg">リスト3.49</a></span>、<span class="listref"><a href="./12-impl-mmio.html#test.py.rom.test">リスト3.50</a></span>、<span class="listref"><a href="./12-impl-mmio.html#test.py.rom.walk">リスト3.51</a></span>)。デフォルト値はカレントディレクトリの<code class="inline-code">bootrom.hex</code>にしておきます。</p>
<div id="test.py.rom.arg" class="caption-code">
<span class="caption">リスト3.49: リスト3.49: 引数--romを追加する (test/test.py)</span>
<pre class="list language-arg">parser.add_argument(&quot;--rom&quot;, default=&quot;bootrom.hex&quot;, help=&quot;hex file of rom&quot;)
</pre>
</div>
<div id="test.py.rom.test" class="caption-code">
<span class="caption">リスト3.50: リスト3.50: シミュレータにROMのHEXファイルのパスを渡す (test/test.py)</span>
<pre class="list language-test">def test(<b>romhex, </b>file_name):
    result_file_path = os.path.join(args.output_dir, file_name.replace(os.sep, &quot;_&quot;) + &quot;.txt&quot;)
    cmd = <b>f&quot;{args.sim_path} {romhex} {file_name} 0&quot;</b>
    success = False
</pre>
</div>
<div id="test.py.rom.walk" class="caption-code">
<span class="caption">リスト3.51: リスト3.51: test関数にROMのHEXファイルのパスを渡す (test/test.py)</span>
<pre class="list language-walk">    for hexpath in dir_walk(args.dir):
        f, s = test(<b>os.path.abspath(args.rom),</b> os.path.abspath(hexpath))
        res_strs.append((&quot;PASS&quot; if s else &quot;FAIL&quot;) + &quot; : &quot; + f)
        res_statuses.append(s)
</pre>
</div>

<h3 class="none"><a id="h3-5-3"></a><span class="secno">3.5.3</span> ROMとmmio_controllerモジュールを接続する</h3>
<p>ROMをインスタンス化してmmio_controllerモジュールと接続します。</p>
<p>ROMとmmio_controllerモジュールを接続するインターフェース(<code class="inline-code">mmio_rom_membus</code>)、ROMのインターフェース(<code class="inline-code">rom_membus</code>)を定義します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.rom.interface">リスト3.52</a></span>)。</p>
<div id="top.veryl.rom.interface" class="caption-code">
<span class="caption">リスト3.52: リスト3.52: ROMのインターフェースの定義 (top.veryl)</span>
<pre class="list language-interface">    inst mmio_membus    : Membus;
    inst mmio_ram_membus: Membus;
    <b>inst mmio_rom_membus: Membus;</b>
    inst ram_membus     : membus_if::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;;
    <b>inst rom_membus     : membus_if::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt;;</b>
</pre>
</div>
<p>ROMをインスタンス化します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.rom.inst">リスト3.53</a></span>)。パラメータにはtopモジュールのパラメータを割り当てます。</p>
<div id="top.veryl.rom.inst" class="caption-code">
<span class="caption">リスト3.53: リスト3.53: ROMをインスタンス化する (top.veryl)</span>
<pre class="list language-inst">    inst rom: memory::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt; #(
        FILEPATH_IS_ENV: ROM_FILEPATH_IS_ENV,
        FILEPATH       : ROM_FILEPATH       ,
    ) (
        clk               ,
        rst               ,
        membus: rom_membus,
    );
</pre>
</div>
<p>mmio_controllerモジュールに<code class="inline-code">rom_membus</code>を接続します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.rom.mmioc">リスト3.54</a></span>)。</p>
<div id="top.veryl.rom.mmioc" class="caption-code">
<span class="caption">リスト3.54: リスト3.54: ROMのインターフェースを接続する (top.veryl)</span>
<pre class="list language-mmioc">    inst mmioc: mmio_controller (
        clk                        ,
        rst                        ,
        req_core  : mmio_membus    ,
        ram_membus: mmio_ram_membus,
        <b>rom_membus: mmio_rom_membus,</b>
    );
</pre>
</div>
<p>mmio_controllerモジュールとROMを接続します。アドレスの変換のためにaddr_to_memaddr関数を使用しています(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.rom.connect">リスト3.55</a></span>)。</p>
<div id="top.veryl.rom.connect" class="caption-code">
<span class="caption">リスト3.55: リスト3.55: mmio_controllerモジュールとROMを接続する (top.veryl)</span>
<pre class="list language-connect">    always_comb {
        // mmio &lt;&gt; ROM
        rom_membus.valid       = mmio_rom_membus.valid;
        mmio_rom_membus.ready  = rom_membus.ready;
        rom_membus.addr        = addr_to_memaddr::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt;(mmio_rom_membus.addr);
        rom_membus.wen         = 0;
        rom_membus.wdata       = 0;
        rom_membus.wmask       = 0;
        mmio_rom_membus.rvalid = rom_membus.rvalid;
        mmio_rom_membus.rdata  = rom_membus.rdata;
    }
</pre>
</div>

<h3 class="none"><a id="h3-5-4"></a><span class="secno">3.5.4</span> ROMからRAMにジャンプする</h3>
<p>PCの初期値をROMのベースアドレスに変更し、ROMからRAMにジャンプする仕組みを実現します。</p>
<p>一般的にCPUの電源をつけると、CPUはROMのようなメモリデバイスに入ったソフトウェアから実行を開始します。そのソフトウェアは次に実行するソフトウェアを外部記憶装置から読み取り、RAMにソフトウェアを適切にコピー、配置して実行します。</p>
<p>本章ではRAM、ROMともに<code class="inline-code">$readmemh</code>システムタスクで初期化するように実装しているので、RAMのベースアドレスにジャンプするだけのプログラムをROMに設定します。</p>
<p>ROMに設定するためのHEXファイルを作成します(<span class="listref"><a href="./12-impl-mmio.html#bootrom.hex.rom">リスト3.56</a></span>)。</p>
<div id="bootrom.hex.rom" class="caption-code">
<span class="caption">リスト3.56: リスト3.56: RAMの開始アドレスにジャンプするプログラム (bootrom.hex)</span>
<pre class="list language-rom">00409093080000b7 // 0: lui x1, 0x08000 4: slli x1, x1, 4
0000000000008067 // 8: jalr x0, 0(x1)  c:
0000000000000000 // zero

</pre>
</div>
<p>PCの初期値をROMのベースアドレスに変更します(<span class="listref"><a href="./12-impl-mmio.html#eei.veryl.rom.pc">リスト3.57</a></span>)。</p>
<div id="eei.veryl.rom.pc" class="caption-code">
<span class="caption">リスト3.57: リスト3.57: PCの初期値の変更 (eei.veryl)</span>
<pre class="list language-pc">    const INITIAL_PC: Addr = <b>MMAP_ROM_BEGIN</b>;
</pre>
</div>
<p>riscv-testsを実行し、ROM(<code class="inline-code">0x1000</code>)から実行を開始してRAM(<code class="inline-code">0x80000000</code>)にジャンプしてテストを開始していることを確かめてください。</p>

<h2 class="numbox"><a id="h3-6"></a><span class="secno">3.6</span> デバッグ用の入出力デバイスの実装</h2>
<p>CPUが文字を送信したり受信するためのデバッグ用の入出力デバイスを実装します。今のところriscv-testsの結果を受け取るためのアドレスをRAMのベースアドレス + <code class="inline-code">0x1000</code>にしていますが、この処理もデバイスに実装します。</p>
<p>本章では、デバッグ用の入出力デバイスに次のような64ビットレジスタを実装します。</p>
<dl>
<dt>上位20ビットが<code class="inline-code">20'h01010</code>な値を書き込み</dt>
<dd>
    下位8ビットを文字として解釈し<code class="inline-code">$write</code>システムタスクで出力します。
</dd>
<dt>上位20ビットが<code class="inline-code">20'h01010</code>ではないLSBが<code class="inline-code">1</code>な値を書き込み</dt>
<dd>
    今までのriscv-testsの終了判定処理を行います。
</dd>
<dt>読み込み</dt>
<dd>
    C++プログラムの関数を利用して1文字入力を受け取ります。
    有効な入力の場合は上位20ビットが<code class="inline-code">20'h01010</code>、無効な入力の場合は<code class="inline-code">0</code>になります。
</dd>
</dl>

<h3 class="none"><a id="h3-6-1"></a><span class="secno">3.6.1</span> デバイスのアドレスを設定する</h3>
<p><span class="listref"><a href="./12-impl-mmio.html#top.veryl.memtoram.port">リスト3.9</a></span>でデバイスのアドレスをポートで設定できるようにしたので、<code class="inline-code">tb_verilator.cpp</code>で環境変数の値をデバイスのアドレスに設定するようにします。</p>
<p>環境変数<code class="inline-code">DBG_ADDR</code>を読み込み、<code class="inline-code">DBG_ADDR</code>ポートに設定します(<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.debugout.Device">リスト3.58</a></span>)。</p>
<div id="tb_verilator.cpp.debugout.Device" class="caption-code">
<span class="caption">リスト3.58: リスト3.58: DBG_ADDRポートに環境変数の値を設定する (tb_verilator.cpp)</span>
<pre class="list language-Device">    // デバッグ用の入出力デバイスのアドレスを取得する
    <b>const char* dbg_addr_c = getenv(&quot;DBG_ADDR&quot;);</b>
    <b>const unsigned long long DBG_ADDR = dbg_addr_c == nullptr ? 0 : std::strtoull(dbg_addr_c, nullptr, 0);</b>

    // top
    Vcore_top *dut = new Vcore_top();
    <b>dut-&gt;MMAP_DBG_ADDR = DBG_ADDR;</b>
</pre>
</div>

<h3 class="none"><a id="h3-6-2"></a><span class="secno">3.6.2</span> mmio_controllerモジュールにデバイスを追加する</h3>
<p>mmio_controllerモジュールにデバイスを追加します。</p>
<p><code class="inline-code">Device</code>型に<code class="inline-code">Device::DEBUG</code>を追加します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.Device">リスト3.59</a></span>)。</p>
<div id="mmio_controller.veryl.debugout.Device" class="caption-code">
<span class="caption">リスト3.59: リスト3.59: Device型にデバッグ用の入出力デバイスを追加する (mmio_controller.veryl)</span>
<pre class="list language-Device">    enum Device {
        UNKNOWN,
        RAM,
        ROM,
        <b>DEBUG,</b>
    }
</pre>
</div>
<p>ポートにインターフェースとデバイスのアドレスを追加します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.port">リスト3.60</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.reset_all">リスト3.61</a></span>)。</p>
<div id="mmio_controller.veryl.debugout.port" class="caption-code">
<span class="caption">リスト3.60: リスト3.60: DBG_ADDR、インターフェースを追加する (mmio_controller.veryl)</span>
<pre class="list language-port">module mmio_controller (
    clk       : input   clock         ,
    rst       : input   reset         ,
    <b>DBG_ADDR  : input   Addr          ,</b>
    req_core  : modport Membus::slave ,
    ram_membus: modport Membus::master,
    rom_membus: modport Membus::master,
    <b>dbg_membus: modport Membus::master,</b>
) {
</pre>
</div>
<div id="mmio_controller.veryl.debugout.reset_all" class="caption-code">
<span class="caption">リスト3.61: リスト3.61: インターフェースの要求部分をリセットする (mmio_controller.veryl)</span>
<pre class="list language-reset_all">    function reset_all_device_masters () {
        reset_membus_master(ram_membus);
        reset_membus_master(rom_membus);
        <b>reset_membus_master(dbg_membus);</b>
    }
</pre>
</div>
<p>デバイスの位置を設定します。最初にチェックすることで、他のデバイスとアドレスを被らせたとしてもデバッグ用の入出力デバイスを優先します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.get_device">リスト3.62</a></span>)。</p>
<div id="mmio_controller.veryl.debugout.get_device" class="caption-code">
<span class="caption">リスト3.62: リスト3.62: get_device関数でデバイスの範囲を定義する (mmio_controller.veryl)</span>
<pre class="list language-get_device">    function get_device (
        addr: input Addr,
    ) -&gt; Device {
        <b>if DBG_ADDR &lt;= addr &amp;&amp; addr &lt;= DBG_ADDR + 7 {</b>
        <b>    return Device::DEBUG;</b>
        <b>}</b>
        if MMAP_ROM_BEGIN &lt;= addr &amp;&amp; addr &lt;= MMAP_ROM_END {
            return Device::ROM;
        }
        if addr &gt;= MMAP_RAM_BEGIN {
            return Device::RAM;
        }
        return Device::UNKNOWN;
    }
</pre>
</div>
<p>インターフェースを設定します(<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.assign_device_master">リスト3.63</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.assign_device_slave">リスト3.64</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.get_device_ready">リスト3.65</a></span>、<span class="listref"><a href="./12-impl-mmio.html#mmio_controller.veryl.debugout.get_device_rvalid">リスト3.66</a></span>)。この変更はROMを追加したときとほとんど同じです。</p>
<div id="mmio_controller.veryl.debugout.assign_device_master" class="caption-code">
<span class="caption">リスト3.63: リスト3.63: assign_device_master関数の変更 (mmio_controller.veryl)</span>
<pre class="list language-assign_device_master">        case get_device(req.addr) {
            Device::RAM: {
                ram_membus      &lt;&gt; req;
                ram_membus.addr -= MMAP_RAM_BEGIN;
            }
            Device::ROM: {
                rom_membus      &lt;&gt; req;
                rom_membus.addr -= MMAP_ROM_BEGIN;
            }
            <b>Device::DEBUG: {</b>
            <b>    dbg_membus      &lt;&gt; req;</b>
            <b>    dbg_membus.addr -= DBG_ADDR;</b>
            <b>}</b>
            default: {}
        }
</pre>
</div>
<div id="mmio_controller.veryl.debugout.assign_device_slave" class="caption-code">
<span class="caption">リスト3.64: リスト3.64: assign_device_slave関数の変更 (mmio_controller.veryl)</span>
<pre class="list language-assign_device_slave">        case device {
            Device::RAM  : req &lt;&gt; ram_membus;
            Device::ROM  : req &lt;&gt; rom_membus;
            <b>Device::DEBUG: req &lt;&gt; dbg_membus;</b>
            default      : {}
        }
</pre>
</div>
<div id="mmio_controller.veryl.debugout.get_device_ready" class="caption-code">
<span class="caption">リスト3.65: リスト3.65: get_device_ready関数の変更 (mmio_controller.veryl)</span>
<pre class="list language-get_device_ready">        case device {
            Device::RAM  : return ram_membus.ready;
            Device::ROM  : return rom_membus.ready;
            <b>Device::DEBUG: return dbg_membus.ready;</b>
            default      : {}
        }
</pre>
</div>
<div id="mmio_controller.veryl.debugout.get_device_rvalid" class="caption-code">
<span class="caption">リスト3.66: リスト3.66: get_device_rvalid関数の変更 (mmio_controller.veryl)</span>
<pre class="list language-get_device_rvalid">        case device {
            Device::RAM  : return ram_membus.rvalid;
            Device::ROM  : return rom_membus.rvalid;
            <b>Device::DEBUG: return dbg_membus.rvalid;</b>
            default      : {}
        }
</pre>
</div>
<p>topモジュールにデバッグ用の入出力デバイスのインターフェース(<code class="inline-code">dbg_membus</code>)を定義し、mmio_controllerモジュールと接続します(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.debugout.interface">リスト3.67</a></span>、<span class="listref"><a href="./12-impl-mmio.html#top.veryl.debugout.mmioc">リスト3.68</a></span>)。</p>
<div id="top.veryl.debugout.interface" class="caption-code">
<span class="caption">リスト3.67: リスト3.67: インターフェースのインスタンス化 (top.veryl)</span>
<pre class="list language-interface">    inst ram_membus     : membus_if::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;;
    inst rom_membus     : membus_if::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt;;
    <b>inst dbg_membus     : Membus;</b>
</pre>
</div>
<div id="top.veryl.debugout.mmioc" class="caption-code">
<span class="caption">リスト3.68: リスト3.68: インターフェースを接続する (top.veryl)</span>
<pre class="list language-mmioc">    inst mmioc: mmio_controller (
        clk                        ,
        rst                        ,
        DBG_ADDR  : MMAP_DBG_ADDR  ,
        req_core  : mmio_membus    ,
        ram_membus: mmio_ram_membus,
        rom_membus: mmio_rom_membus,
        <b>dbg_membus                 ,</b>
    );
</pre>
</div>

<h3 class="none"><a id="h3-6-3"></a><span class="secno">3.6.3</span> 出力を実装する</h3>
<p><code class="inline-code">dbg_membus</code>を使い、デバッグ出力処理を実装します。既存のriscv-testsの終了検知処理を次のように書き換えます(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.debugout.io">リスト3.69</a></span>)。</p>
<div id="top.veryl.debugout.io" class="caption-code">
<span class="caption">リスト3.69: リスト3.69: riscv-testsの終了検知処理をデバッグ用の入出力デバイスに変更する (top.veryl)</span>
<pre class="list language-io">    // デバッグ用のIO
    always_ff {
        dbg_membus.ready  = 1;
        dbg_membus.rvalid = dbg_membus.valid;
        if dbg_membus.valid {
            if dbg_membus.wen {
                if dbg_membus.wdata[MEMBUS_DATA_WIDTH - 1-:20] == 20'h01010 {
                    $write(&quot;%c&quot;, dbg_membus.wdata[7:0]);
                } else if dbg_membus.wdata[lsb] == 1'b1 {
                    #[ifdef(TEST_MODE)]
                    {
                        test_success = dbg_membus.wdata == 1;
                    }
                    if dbg_membus.wdata == 1 {
                        $display(&quot;test success!&quot;);
                    } else {
                        $display(&quot;test failed!&quot;);
                        $error  (&quot;wdata : %h&quot;, dbg_membus.wdata);
                    }
                    $finish();
                }
            }
        }
    }
</pre>
</div>
<p>常に要求を受け付け、書き込みの時は書き込むデータ(<code class="inline-code">wdata</code>)を確認します。<code class="inline-code">wdata</code>の上位20ビットが<code class="inline-code">20'h01010</code>なら下位8ビットを出力し、LSBが<code class="inline-code">1</code>ならテストの成功判定をして<code class="inline-code">$finish</code>システムタスクを呼び出します。</p>

<h3 id="debugout_howto" class="none"><a id="h3-6-4"></a><span class="secno">3.6.4</span> 出力をテストする</h3>
<p>実装した出力デバイスで文字を出力できることを確認します。</p>
<p>デバッグ用に<code class="inline-code">$display</code>システムタスクで表示している情報が邪魔になるので、デバッグ情報の表示を環境変数<code class="inline-code">PRINT_DEBUG</code>で制御できるようにします(<span class="listref"><a href="./12-impl-mmio.html#core.veryl.debugout.debug">リスト3.70</a></span>)。</p>
<div id="core.veryl.debugout.debug" class="caption-code">
<span class="caption">リスト3.70: リスト3.70: デバッグ出力をdefineで囲う (core.veryl)</span>
<pre class="list language-debug">    ///////////////////////////////// DEBUG /////////////////////////////////
    <b>#[ifdef(PRINT_DEBUG)]</b>
    <b>{</b>
        var clock_count: u64;

        always_ff {
            if_reset {
                clock_count = 1;
            } else {
                clock_count = clock_count + 1;

                $display(&quot;&quot;);
                $display(&quot;# %d&quot;, clock_count);
</pre>
</div>
<p><code class="inline-code">test/debug_output.c</code>を作成し、次のように記述します(<span class="listref"><a href="./12-impl-mmio.html#debug_output.c.debugouttest">リスト3.71</a></span>)。これは<code class="inline-code">Hello,world!</code>と出力するプログラムです。</p>
<div id="debug_output.c.debugouttest" class="caption-code">
<span class="caption">リスト3.71: リスト3.71: Hello,world!を出力するプログラム (test/debug_output.c)</span>
<pre class="list language-debugouttest">#define DEBUG_REG ((volatile unsigned long long*)0x40000000)

void main(void) {
    int strlen = 13;
    unsigned char str[13];

    str[0]  = 'H';
    str[1]  = 'e';
    str[2]  = 'l';
    str[3]  = 'l';
    str[4]  = 'o';
    str[5]  = ',';
    str[6]  = 'w';
    str[7]  = 'o';
    str[8]  = 'r';
    str[9]  = 'l';
    str[10] = 'd';
    str[11] = '!';
    str[12] = '\n';

    for (int i = 0; i &lt; strlen; i++) {
        unsigned long long c = str[i];
        *DEBUG_REG = c | (0x01010ULL &lt;&lt; 44);
    }
    *DEBUG_REG = 1;
}
</pre>
</div>
<p><code class="inline-code">DEBUG_OUTPUT</code>は出力デバイスのアドレスです。ここに<code class="inline-code">0x01010</code>を44ビット左シフトした値と文字をOR演算した値を書き込むことで文字を出力します。最後に<code class="inline-code">1</code>を書き込み、テストを終了しています。</p>
<p>main関数をそのままコンパイルしてRAMに配置すると、スタックポインタ(stack pointer, sp)の値が適切に設定されていないのでうまく動きません。スタックポインタとは、プログラムが一時的に利用する値を格納しておくためのメモリ(スタック)のアドレスへのポインタのことです。RISC-Vの規約ではsp(x2)レジスタをスタックポインタとして利用することが定められています。</p>
<p>そのため、レジスタの値を適切な値にリセットしてmain関数を呼び出す別のプログラムが必要です。<code class="inline-code">test/entry.S</code>を作成し、次のように記述します(<span class="listref"><a href="./12-impl-mmio.html#entry.S.debugouttest">リスト3.72</a></span>)。</p>
<div id="entry.S.debugouttest" class="caption-code">
<span class="caption">リスト3.72: リスト3.72: test/entry.S</span>
<pre class="list language-debugouttest">.global _start
.section .text.init
_start:
    add x1, x0, x0
    la  x2, _stack_bottom
    add x3, x0, x0
    add x4, x0, x0
    add x5, x0, x0
    add x6, x0, x0
    add x7, x0, x0
    add x8, x0, x0
    add x9, x0, x0
    add x10, x0, x0
    add x11, x0, x0
    add x12, x0, x0
    add x13, x0, x0
    add x14, x0, x0
    add x15, x0, x0
    add x16, x0, x0
    add x17, x0, x0
    add x18, x0, x0
    add x19, x0, x0
    add x20, x0, x0
    add x21, x0, x0
    add x22, x0, x0
    add x23, x0, x0
    add x24, x0, x0
    add x25, x0, x0
    add x26, x0, x0
    add x27, x0, x0
    add x28, x0, x0
    add x29, x0, x0
    add x30, x0, x0
    add x31, x0, x0
    call main
</pre>
</div>
<p>このアセンブリはsp(x2)レジスタを<code class="inline-code">_stack_bottom</code>のアドレスに設定し、他のレジスタを<code class="inline-code">0</code>でリセットしたあとに<code class="inline-code">main</code>にジャンプします。</p>
<p><code class="inline-code">_stack_bottom</code>は、リンカの設定ファイルに記述します。<code class="inline-code">test/link.ld</code>を作成し、次のように記述します(<span class="listref"><a href="./12-impl-mmio.html#link.ld.debugouttest">リスト3.73</a></span>)。</p>
<div id="link.ld.debugouttest" class="caption-code">
<span class="caption">リスト3.73: リスト3.73: test/link.ld</span>
<pre class="list language-debugouttest">OUTPUT_ARCH( &quot;riscv&quot; )
ENTRY(_start)

SECTIONS
{
  . = 0x80000000;
  .text.init : { *(.text.init) }
  .text : { *(.text*) }
  .data : { *(.data*) }
  .bss : {*(.bss*)}
  .stack : {
    . = ALIGN(0x10);
    _stack_top = .;
    . += 4K;
    _stack_bottom = .;
  }
  _end = .;
}
</pre>
</div>
<p><code class="inline-code">_stack_bottom</code>と<code class="inline-code">_stack_top</code>の間は4KBあるので、スタックのサイズは4KBになります。<code class="inline-code">_start</code>を<code class="inline-code">.text.init</code>に配置し(<span class="listref"><a href="./12-impl-mmio.html#entry.S.debugouttest">リスト3.72</a></span>)、<code class="inline-code">SECTIONS</code>の先頭に<code class="inline-code">.text.init</code>を配置しているため、アドレス<code class="inline-code">0x80000000</code>に<code class="inline-code">_start</code>が配置されます。</p>
<p>これらのファイルを利用し、テストプログラムをコンパイルします(<span class="listref"><a href="./12-impl-mmio.html#term.compile.test.1">リスト3.74</a></span>)。gccの<code class="inline-code">-march</code>フラグではC拡張を抜いたISAを指定しています。このフラグを記述しないと、まだ実装していない命令が含まれたELFファイルにコンパイルされてしまいます。</p>
<div id="term.compile.test.1" class="cmd-code">
<span class="caption">リスト3.74: リスト3.74: テストプログラムをコンパイル、HEXファイルに変換する</span>
<pre class="list language-1">$ <span class="userinput">cd test</span>
$ <span class="userinput">riscv64-unknown-elf-gcc -nostartfiles -nostdlib -mcmodel=medany -T link.ld -march=rv64imad debug_output.c entry.S</span>
$ <span class="userinput">riscv64-unknown-elf-objcopy a.out -O binary test.bin</span>
$ <span class="userinput">python3 bin2hex.py 8 test.bin &gt; test.bin.hex</span> <span class="balloon">← HEXファイルに変換する</span>
</pre>
</div>
<p>シミュレータをビルドし、テストプログラムを実行します(<span class="listref"><a href="./12-impl-mmio.html#term.compile.test.2">リスト3.75</a></span>)。</p>
<div id="term.compile.test.2" class="cmd-code">
<span class="caption">リスト3.75: リスト3.75: テストプログラムを実行する</span>
<pre class="list language-2">$ <span class="userinput">make build sim</span>
$ <span class="userinput">DBG_ADDR=0x40000000 ./obj_dir/sim bootrom.hex test/test.bin.hex</span>
Hello,world!
- ~/core/src/top.sv:62: Verilog $finish
</pre>
</div>
<p><code class="inline-code">Hello,world!</code>と出力されたあと、プログラムが終了しました。</p>

<h3 class="none"><a id="h3-6-5"></a><span class="secno">3.6.5</span> riscv-testsに対応する</h3>
<p>riscv-testsを実行するとき、終了判定用のレジスタの位置を<code class="inline-code">DBG_ADDR</code>に設定するようにします。</p>
<p><code class="inline-code">test/test.py</code>を、ELFファイルを探して自動で<code class="inline-code">DBG_ADDR</code>を設定してテストを実行するプログラムに変更します。</p>
<p>elftools<sup><a id="fnb-elftools_install" href="#fn-elftools_install" class="noteref" epub:type="noteref">*2</a></sup>を使用し、ELFファイルの判定、セクションのアドレスを取得する関数を定義します(<span class="listref"><a href="./12-impl-mmio.html#test.py.debugouttest.import">リスト3.76</a></span>、<span class="listref"><a href="./12-impl-mmio.html#test.py.debugouttest.func">リスト3.77</a></span>)。</p>
<div class="footnote-list">
<div class="footnote" id="fn-elftools_install" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>pipでインストールできます</p></div>
</div><!--/.footnote-list-->
<div id="test.py.debugouttest.import" class="caption-code">
<span class="caption">リスト3.76: リスト3.76: elftoolsのimport (test/test.py)</span>
<pre class="list language-import">from elftools.elf.elffile import ELFFile
</pre>
</div>
<div id="test.py.debugouttest.func" class="caption-code">
<span class="caption">リスト3.77: リスト3.77: ELFの判定、セクションのアドレスを取得する関数の定義 (test/test.py)</span>
<pre class="list language-func">def is_elf(filepath):
    try:
        with open(filepath, 'rb') as f:
            magic_number = f.read(4)
            return magic_number == b'\x7fELF'
    except:
        return False

def get_section_address(filepath, section_name):
    try:
        with open(filepath, 'rb') as f:
            elffile = ELFFile(f)
            for section in elffile.iter_sections():
                if section.name == section_name:
                    return section.header['sh_addr']
            return 0
    except:
        return 0
</pre>
</div>
<p>デバッグ用の入出力デバイスのセクション名を指定する引数を作成します(<span class="listref"><a href="./12-impl-mmio.html#test.py.debugouttest.args">リスト3.78</a></span>)。また、テストするファイルの拡張子を指定していた引数を、ELFファイルに付加することでHEXファイルのパスを得るための引数に変更します。</p>
<div id="test.py.debugouttest.args" class="caption-code">
<span class="caption">リスト3.78: リスト3.78: オプションを追加する (test/test.py)</span>
<pre class="list language-args">parser.add_argument(&quot;-e&quot;, &quot;--extension&quot;, default=&quot;<b>.bin.</b>hex&quot;, help=&quot;<b>hex</b> file extension&quot;)
<b>parser.add_argument(&quot;-d&quot;, &quot;--debug_label&quot;, default=&quot;.tohost&quot;, help=&quot;debug device label&quot;)</b>
</pre>
</div>
<p>dir_walk関数を、ELFファイルを探す関数に変更します(<span class="listref"><a href="./12-impl-mmio.html#test.py.debugouttest.dir_walk">リスト3.79</a></span>)。</p>
<div id="test.py.debugouttest.dir_walk" class="caption-code">
<span class="caption">リスト3.79: リスト3.79: dir_walk関数でELFファイルを探す (test/test.py)</span>
<pre class="list language-dir_walk">if entry.is_file():
    if not <b>is_elf(entry.path)</b>:
        continue
    if len(args.files) == 0:
        yield entry.path
</pre>
</div>
<p>シミュレータの実行で<code class="inline-code">DBG_ADDR</code>を指定するようにします(<span class="listref"><a href="./12-impl-mmio.html#test.py.debugouttest.test">リスト3.80</a></span>、<span class="listref"><a href="./12-impl-mmio.html#test.py.debugouttest.for">リスト3.81</a></span>)。</p>
<div id="test.py.debugouttest.test" class="caption-code">
<span class="caption">リスト3.80: リスト3.80: DBG_ADDRをシミュレータに渡す (test/test.py)</span>
<pre class="list language-test">def test(<b>dbg_addr,</b> romhex, file_name):
    result_file_path = os.path.join(args.output_dir, file_name.replace(os.sep, &quot;_&quot;) + &quot;.txt&quot;)
    <b>env = f&quot;DBG_ADDR={dbg_addr} &quot;</b>
    cmd = f&quot;{args.sim_path} {romhex} {file_name} 0&quot;
    success = False
    with open(result_file_path, &quot;w&quot;) as f:
        no = f.fileno()
        p = subprocess.Popen(<b>&quot; &quot;.join([env, &quot;exec&quot;, cmd])</b>, shell=True, stdout=no, stderr=no)
</pre>
</div>
<div id="test.py.debugouttest.for" class="caption-code">
<span class="caption">リスト3.81: リスト3.81: DBG_ADDRをtest関数に渡す (test/test.py)</span>
<pre class="list language-for">for <b>elf</b>path in dir_walk(args.dir):
    <b>hexpath = elfpath + args.extension</b>
    <b>if not os.path.exists(hexpath):</b>
    <b>    print(&quot;SKIP :&quot;, elfpath)</b>
    <b>    continue</b>
    <b>dbg_addr = get_section_address(elfpath, args.debug_label)</b>
    f, s = test(<b>dbg_addr,</b> os.path.abspath(args.rom), os.path.abspath(hexpath))
    res_strs.append((&quot;PASS&quot; if s else &quot;FAIL&quot;) + &quot; : &quot; + f)
    res_statuses.append(s)
</pre>
</div>
<p><code class="inline-code">VERILATOR_FLAGS=&quot;-DTEST_MODE&quot;</code>をつけてシミュレータをビルドし、riscv-testsが正常終了することを確かめてください。</p>

<h3 class="none"><a id="h3-6-6"></a><span class="secno">3.6.6</span> 入力を実装する</h3>
<p><code class="inline-code">dbg_membus</code>を使い、デバッグ入力処理を実装します。</p>
<p>まず、<code class="inline-code">src/tb_verilator.cpp</code>に、標準入力から1文字取得する関数を定義します(<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.debuginput.get_input_dpic">リスト3.82</a></span>)。入力がない場合は<code class="inline-code">0</code>、ある場合は上位20ビットを<code class="inline-code">0x01010</code>にした値を返します。</p>
<div id="tb_verilator.cpp.debuginput.get_input_dpic" class="caption-code">
<span class="caption">リスト3.82: リスト3.82: 標準入力を1文字取得する関数の定義 (src/tb_verilator.cpp)</span>
<pre class="list language-get_input_dpic">extern &quot;C&quot; const unsigned long long get_input_dpic() {
    unsigned char c = 0;
    ssize_t bytes_read = read(STDIN_FILENO, &amp;c, 1);

    if (bytes_read == 1) {
        return static_cast&lt;unsigned long long&gt;(c) | (0x01010ULL &lt;&lt; 44);
    }
    return 0;
}
</pre>
</div>
<p>ここで、read関数の呼び出しでシミュレータを止めず(<code class="inline-code">O_NONBLOCK</code>)、シェルが入力をバッファリングしなくする(<code class="inline-code">~ICANON</code>)ために設定を変えるコードを挿入します。また、シェルが文字列をローカルエコー(入力した文字列を表示)しないようにします(<code class="inline-code">~ECHO</code>)(<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.debuginput.include">リスト3.83</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.debuginput.termios">リスト3.84</a></span>、<span class="listref"><a href="./12-impl-mmio.html#tb_verilator.cpp.debuginput.set">リスト3.85</a></span>)。</p>
<div id="tb_verilator.cpp.debuginput.include" class="caption-code">
<span class="caption">リスト3.83: リスト3.83: includeを追加する (src/tb_verilator.cpp)</span>
<pre class="list language-include">#include &lt;fcntl.h&gt;
#include &lt;termios.h&gt;
#include &lt;signal.h&gt;
</pre>
</div>
<div id="tb_verilator.cpp.debuginput.termios" class="caption-code">
<span class="caption">リスト3.84: リスト3.84: 設定を変更、復元する関数の定義 (src/tb_verilator.cpp)</span>
<pre class="list language-termios">struct termios old_setting;

void restore_termios_setting(void) {
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;old_setting);
}

void sighandler(int signum) {
    restore_termios_setting();
    exit(signum);
}

void set_nonblocking(void) {
    struct termios new_setting;

    if (tcgetattr(STDIN_FILENO, &amp;old_setting) == -1) {
        perror(&quot;tcgetattr&quot;);
        return;
    }
    new_setting = old_setting;
    new_setting.c_lflag &amp;= ~(ICANON | ECHO);
    if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_setting) == -1) {
        perror(&quot;tcsetattr&quot;);
        return;
    }
    signal(SIGINT, sighandler);
    signal(SIGTERM, sighandler);
    signal(SIGQUIT, sighandler);
    atexit(restore_termios_setting);

    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    if (flags == -1) {
        perror(&quot;fcntl(F_GETFL)&quot;);
        return;
    }
    if (fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror(&quot;fcntl(F_SETFL)&quot;);
        return;
    }
}
</pre>
</div>
<div id="tb_verilator.cpp.debuginput.set" class="caption-code">
<span class="caption">リスト3.85: リスト3.85: 設定を変える関数をmain関数から呼び出す (src/tb_verilator.cpp)</span>
<pre class="list language-set">int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);

    if (argc &lt; 3) {
        std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; ROM_FILE_PATH RAM_FILE_PATH [CYCLE]&quot; &lt;&lt; std::endl;
        return 1;
    }

    <b>#ifdef ENABLE_DEBUG_INPUT</b>
        <b>set_nonblocking();</b>
    <b>#endif</b>
</pre>
</div>
<p><code class="inline-code">src/util.veryl</code>にget_input_dpic関数を呼び出す関数を実装します(<span class="listref"><a href="./12-impl-mmio.html#util.veryl.debuginput">リスト3.86</a></span>)。</p>
<div id="util.veryl.debuginput" class="caption-code">
<span class="caption">リスト3.86: リスト3.86: get_input関数を定義する (src/util.veryl)</span>
<pre class="list language-debuginput">embed (inline) sv{{{
    package svutil;
        ...
        <b>import &quot;DPI-C&quot; context function longint get_input_dpic();</b>
        <b>function longint get_input();</b>
        <b>    return get_input_dpic();</b>
        <b>endfunction</b>
    endpackage
}}}

package util {
    ...
    <b>function get_input () -&gt; u64 {</b>
    <b>    return $sv::svutil::get_input();</b>
    <b>}</b>
}
</pre>
</div>
<p>デバッグ用の入出力デバイスのロードで<code class="inline-code">util::get_input</code>の結果を返すようにします(<span class="listref"><a href="./12-impl-mmio.html#top.veryl.debuginput.io">リスト3.87</a></span>)。このコードは合成できないので、有効化オプション<code class="inline-code">ENABLE_DEBUG_INPUT</code>をつけます。</p>
<div id="top.veryl.debuginput.io" class="caption-code">
<span class="caption">リスト3.87: リスト3.87: 読み込みでget_input関数を呼び出す (src/top.veryl)</span>
<pre class="list language-io">    always_ff {
        dbg_membus.ready  = 1;
        dbg_membus.rvalid = dbg_membus.valid;
        if dbg_membus.valid {
            if dbg_membus.wen {
                ...
            <b>} else {</b>
            <b>    #[ifdef(ENABLE_DEBUG_INPUT)]</b>
            <b>    {</b>
            <b>        dbg_membus.rdata = util::get_input();</b>
            <b>    }</b>
            }
        }
    }
</pre>
</div>

<h3 class="none"><a id="h3-6-7"></a><span class="secno">3.6.7</span> 入力をテストする</h3>
<p>実装した入出力デバイスで文字を入出力できることを確認します。</p>
<p><code class="inline-code">test/debug_input.c</code>を作成し、次のように記述します(<span class="listref"><a href="./12-impl-mmio.html#debug_input.c.debuginput">リスト3.88</a></span>)。これは入力された文字に<code class="inline-code">1</code>を足した値を出力するプログラムです。</p>
<div id="debug_input.c.debuginput" class="caption-code">
<span class="caption">リスト3.88: リスト3.88: test/debug_input.c</span>
<pre class="list language-debuginput">#define DEBUG_REG ((volatile unsigned long long*)0x40000000)

void main(void) {
    while (1) {
        unsigned long long c = *DEBUG_REG;
        if (c &amp; (0x01010ULL &lt;&lt; 44) == 0) {
            continue;
        }
        c = c &amp; 255;
        *DEBUG_REG = (c + 1) | (0x01010ULL &lt;&lt; 44);
    }
}
</pre>
</div>
<p>プログラムをコンパイルしてシミュレータを実行し、入力した文字が1文字ずれて表示されることを確認してください(<code class="inline-code">term-run-change-input</code>)。</p>
<div id="term-run-change-input" class="cmd-code">
<span class="caption">リスト3.89: リスト3.89: テストプログラムを実行する</span>
<pre class="list">$ <span class="userinput">make build sim VERILATOR_FLAGS=&quot;-DENABLE_DEBUG_INPUT&quot;</span> <span class="balloon">← 入力を有効にしてシミュレータをビルド</span>
$ <span class="userinput">./obj_dir/sim bootrom.hex test/test.bin.hex</span> <span class="balloon">← (事前にHEXファイルを作成しておく</span>
bcd<span class="balloon">← abcと入力して改行</span>
   efg<span class="balloon">← defと入力する</span>
</pre>
</div>
        </main>
        <nav class="page-navi">
          <a href="11-impl-exception.html" class="page-prev">&#9664;</a>
          <a href="13-impl-a.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
