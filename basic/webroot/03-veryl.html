<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>ハードウェア記述言語 Veryl | Verylで作るCPU</title>
    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="RV32Iの実装" href="04-impl-rv32i.html">
    <link rel="prev" title="環境構築" href="02-setup.html">
    <meta name="generator" content="Re:VIEW Starter">
  </head>
  <body>
    <div class="page-outer">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>
<ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき / はじめに</a></li>
<li class="toc-part">第I部 RV32I/RV64Iの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./02-setup.html">1 環境構築</a></li>
    <li class="toc-chapter"><a href="./03-veryl.html">2 ハードウェア記述言語 Veryl</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="#h2-1">2.1 ハードウェア記述言語</a></li>
        <li class="toc-section"><a href="#h2-2">2.2 Verylの基本文法, 機能</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./04-impl-rv32i.html">3 RV32Iの実装</a></li>
    <li class="toc-chapter"><a href="./04a-zicsr.html">4 Zicsr拡張の実装</a></li>
    <li class="toc-chapter"><a href="./04b-riscvtests.html">5 riscv-testsによるテスト</a></li>
    <li class="toc-chapter"><a href="./05-impl-rv64i.html">6 RV64Iの実装</a></li>
    <li class="toc-chapter"><a href="./05a-pipeline.html">7 CPUのパイプライン処理化</a></li>
    <li class="toc-chapter"><a href="./05b-synth.html">8 CPUを合成する</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99-postface.html">あとがき / おわりに</a></li>
    <li class="toc-chapter"><a href="./bib.html">参考文献</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
<h1 class="boldlines center twolines"><a id="h2"></a><span class="secno">第2章</span> <br/>ハードウェア記述言語 Veryl</h1>

<h2 id="hdl" class="numbox"><a id="h2-1"></a><span class="secno">2.1</span> ハードウェア記述言語</h2>
<p>CPUを記述するといっても、いったいどうやって記述するのでしょうか?まずは、論理回路を構成する方法から考えます。</p>

<h3 class="none"><a id="h2-1-1"></a><span class="secno">2.1.1</span> 論理回路の構成</h3>
<p><b>論理回路</b>とは、デジタル(例えば0と1だけ)なデータを利用して、データを加工、保持する回路のことです。論理回路は、組み合わせ回路と順序回路に分類することができます。</p>
<p><b>組み合わせ回路</b>とは、入力に対して、一意に出力の決まる回路<a href="bib.html#bib-ronrikairo">[2]</a>のことです。例えば、<span class="imgref"><a href="./03-veryl.html#halfadder">図2.1</a></span>は半加算器です。半加算器とは1ビットの加算を行う回路で、入力X, Yが決まると、出力C, Sが一意に決まります(<span class="tableref"><a href="./03-veryl.html#halfadder.truth">表2.1</a></span>)。</p>
<div id="halfadder" class="image">
<img src="images/03-veryl/halfadder.png" alt="半加算器 (MIL記法)" class="img" style="width:45%" />
<p class="caption">
図2.1: 半加算器 (MIL記法)
</p>
</div>
<div id="halfadder.truth" class="table">
<p class="caption">表2.1: 半加算器 (真理値表)</p>
<table>
<tr class="hline"><th>X</th><th>Y</th><th>C</th><th>S</th></tr>
<tr class="hline"><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr class="hline"><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr class="hline"><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr class="hline"><td>1</td><td>1</td><td>1</td><td>0</td></tr>
</table>
</div>
<p><b>順序回路</b>とは、入力と回路自身の状態によって一意に出力の決まる回路<a href="bib.html#bib-ronrikairo">[2]</a>です。例えば、入力が1になるたびにカウントアップして値を表示するカウンタを考えます(<span class="imgref"><a href="./03-veryl.html#downcounter">図2.2</a></span>)。カウントアップするためには、今のカウンタの値(状態)を保持する必要があります。よって、このカウンタは入力と状態によって一意に出力の決まる順序回路です。</p>
<p>1ビットの値はフリップフロップという回路によって保持することができます。フロップフロップをN個並列に並べると、Nビットの値を保持することができます。フリップフロップを並列に並べた記憶装置のことを、<b>レジスタ</b>(register, 置数器)と呼びます。基本的に、レジスタの値は<b>リセット信号</b>(reset)によって初期化し、<b>クロック信号</b>(clock)に同期したタイミングで変更します。</p>
<div id="downcounter" class="image">
<img src="images/03-veryl/downcounter.png" alt="カウンタ" class="img" style="width:70%" />
<p class="caption">
図2.2: カウンタ
</p>
</div>
<p>論理回路を設計するには、真理値表を作成し、それを実現する論理演算を構成します。入力数や状態数が数十個ならどうにか人力で設計できるかもしれませんが、数千, 数万の入力や状態があるとき、手作業で設計するのはほとんど不可能です。これを設計するために、ハードウェア記述言語を利用します。</p>

<h3 class="none"><a id="h2-1-2"></a><span class="secno">2.1.2</span> ハードウェア記述言語</h3>
<p><b>ハードウェア記述言語</b>(Hardware Description Language, HDL)とは、デジタル回路を設計するための言語です。</p>
<p>例えばHDLであるSystemVerilogを利用すると、半加算器は<span class="listref"><a href="./03-veryl.html#halfadder.sv">リスト2.1</a></span>のように記述することができます。</p>
<div id="halfadder.sv" class="caption-code">
<span class="caption">リスト2.1: リスト2.1: SystemVerilogによる半加算器の記述</span>
<pre class="list language-sv">module HalfAdder(
  input logic x,        // 入力値X
  input logic y,        // 入力値Y
  output logic c,       // 出力値C
  output logic s        // 出力値S
);
  assign c = x &amp; y; // &amp;はAND演算
  assign s = x ^ y; // ^はXOR演算
endmodule
</pre>
</div>
<p>半加算器(HalfAdder)モジュールは、入力としてx, yを受け取り、出力c, sにx, yを使った演算を割り当てます。</p>
<p>また、レジスタを利用した回路を<span class="listref"><a href="./03-veryl.html#counter.sv">リスト2.2</a></span>のように記述することができます。レジスタの値を、リセット信号<code class="inline-code">rst</code>が<code class="inline-code">0</code>になったタイミングで<code class="inline-code">0</code>に初期化し、クロック信号<code class="inline-code">clk</code>が<code class="inline-code">1</code>になったタイミングでカウントアップします。</p>
<div id="counter.sv" class="caption-code">
<span class="caption">リスト2.2: リスト2.2: SystemVerilogによるカウンタの記述</span>
<pre class="list language-sv">module Counter(
  input logic clk, // クロック信号
  input logic rst  // リセット信号
);
  // 32ビットのレジスタの定義
  logic [31:0] count;

  always_ff @(posedge clk, negedge rst) begin
    if (!rst) begin
      // rstが0になったとき、countを0に初期化する
      count &lt;= 0;
    end else begin
      // clkが1になったとき、countの値をcount + 1にする
      count &lt;= count + 1;
    end
  end
endmodule
</pre>
</div>
<p>HDLを使用すると、論理回路を、レジスタの値と入力値を使った組み合わせ回路と、その結果をレジスタに値を格納する操作として記述できます。このような、レジスタからレジスタに、組み合わせ回路を通したデータを転送する抽象度のことを<b>レジスタ転送レベル</b>(Register Transfer Level, RTL)と呼びます。</p>
<p>HDLで記述された論理回路は、<b>合成系</b>によって、RTLから実際の回路のデータに変換(<b>合成</b>)されます。</p>

<h3 class="none"><a id="h2-1-3"></a><span class="secno">2.1.3</span> Veryl</h3>
<p>メジャーなHDLといえば、Verilog HDL, SystemVerilogなどが挙げられます<sup><a id="fnb-vhdl" href="#fn-vhdl" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-vhdl" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>VHDLが無いじゃないかと思った方、すみません。VHDLのことを私はよく知らないので無いことにしました。</p></div>
</div><!--/.footnote-list-->
<p>Verilog HDL(Verilog)は1980年代に開発された言語であり、最近のプログラミング言語と比べると機能が少なく、冗長な記述が必要です。SystemVerilogはVerilogのスーパーセットです。言語機能が増えて便利になっていますが、スーパーセットであることから、あまり推奨されない古い書き方が可能だったり、(バグの原因となるような)良くない仕様<sup><a id="fnb-nettype" href="#fn-nettype" class="noteref" epub:type="noteref">*2</a></sup>を受け継いでいます。</p>
<div class="footnote-list">
<div class="footnote" id="fn-nettype" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>例えば、未定義の変数が1ビット幅の信号線として解釈される仕様があります。ヤバすぎる</p></div>
</div><!--/.footnote-list-->
<p>本書では、CPUの実装にVerylというHDLを使用します。Verylは2022年12月に公開された言語です。Verylの抽象度は、Verilogと同じくレジスタ転送レベルです。Verylの文法や機能は、Verilog, SystemVerilogに似通ったものになっています。しかし、if式やcase式,クロックとリセットの抽象化,ジェネリクスなど、痒い所に手が届く機能が提供されており、高い生産性を発揮します。</p>
<p>Verylプログラムは、コンパイラ(トランスパイラ)によって、自然で読みやすいSystemVerilogプログラムに変換されます。よって、Verylは旧来のSystemVerilogの環境と共存することができ、SystemVerilogの資産を利用することができます。</p>
<div class="miniblock miniblock-caution">
<p class="miniblock-caption">注意</p>
<p>本書は2024/10/19時点のVeryl(バージョン0.13.1)について、本書で利用する範囲の文法, 機能を解説しています。Verylはまだ開発途上(正式版, 安定版がリリースされていない)状態の言語です。破壊的変更が入り、記載しているコードが使えなくなる可能性があります。</p>
<p>本書に記載しているコードの中には、バージョン0.13.1では不具合によって実行できないものがあります。不具合の回避手段についてはサポートページ<sup><a id="fnb-support" href="#fn-support" class="noteref" epub:type="noteref">*3</a></sup>をご覧ください。また、最新のVerylに対応した解説はweb版, pdf版を確認してください。</p>
</div>
<div class="footnote-list">
<div class="footnote" id="fn-support" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*3] </span>https://github.com/nananapo/veryl-riscv-book/wiki/techbookfest17-support-page</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h2-2"></a><span class="secno">2.2</span> Verylの基本文法, 機能</h2>
<p>それでは、Verylの書き方を簡単に学んでいきましょう。Verylのドキュメントは<a href="https://doc.veryl-lang.org/book/ja/" class="link">https://doc.veryl-lang.org/book/ja/</a>に存在します。また、<a href="https://doc.veryl-lang.org/playground/" class="link">Veryl Playground</a>では、VerylプログラムのSystemVerilogプログラムへのトランスパイルを試すことができます。</p>

<h3 class="none"><a id="h2-2-1"></a><span class="secno">2.2.1</span> コメント, 空白</h3>
<p>Verylでは次のようにコメントを記述することができます(<span class="listref"><a href="./03-veryl.html#code.comment">リスト2.3</a></span>)。</p>
<div id="code.comment" class="caption-code">
<span class="caption">リスト2.3: リスト2.3: コメント</span>
<pre class="list language-comment">  // 1行のコメント
  /* 範囲コメント */
</pre>
</div>

<h3 class="none"><a id="h2-2-2"></a><span class="secno">2.2.2</span> 値, リテラル</h3>
<p>論理回路では、デジタルな値を扱います。デジタルな値は<code class="inline-code">0</code>と<code class="inline-code">1</code>の二値(2-state)で表現されますが、一般的なハードウェア記述言語では、<code class="inline-code">0</code>と<code class="inline-code">1</code>に<code class="inline-code">x</code>, <code class="inline-code">z</code>を加えた四値(4-state)が利用されます(<span class="tableref"><a href="./03-veryl.html#table.fourstate">表2.2</a></span>)。</p>
<div id="table.fourstate" class="table">
<p class="caption">表2.2: 4-stateの値</p>
<table>
<tr class="hline"><th>値</th><th>意味</th><th>真偽</th></tr>
<tr class="hline"><td>0</td><td>0</td><td>偽</td></tr>
<tr class="hline"><td>1</td><td>1</td><td>真</td></tr>
<tr class="hline"><td>x</td><td>unknown</td><td>偽</td></tr>
<tr class="hline"><td>z</td><td>high-inpedance</td><td>偽</td></tr>
</table>
</div>
<p><b>不定値</b>(unknown value)とは、0か1のどちらか分からない値です。不定値は、未初期化のレジスタの値の表現に利用されたり、不定値との演算の結果として生成されます。<b>ハイインピーダンス</b>(high-inpedance)とは、どのレジスタ, 信号とも接続されていないことを表す値です。物理的なハードウェア上では、全ての値は0か1の二値として解釈されます。不定値とハイインピーダンスはシミュレーションのときにのみ利用されます。</p>
<p>1ビットの四値を表現するための型は<b>logic</b>です。Nビットのlogic型は<b>logic&lt;N&gt;</b>のように記述することができます。1ビットの二値を表現する型は<b>bit</b>です。基本的に、レジスタや信号の定義にbit型は利用せず、logic型を利用します。</p>
<p>logic, bit型は、デフォルトで符号が無い型として扱われます。符号付き型として扱いたいときは、型名の前に<b>signed</b>キーワードを追加します(<span class="listref"><a href="./03-veryl.html#code.signed_keyword">リスト2.4</a></span>)。</p>
<div id="code.signed_keyword" class="caption-code">
<span class="caption">リスト2.4: リスト2.4: 符号付き型</span>
<pre class="list language-signed_keyword">signed logic&lt;4&gt; // 4ビットの符号付きlogic型
signed bit&lt;2&gt; // 2ビットの符号付きbit型
</pre>
</div>
<p>32, 64ビットのbit型を表す型が定義されています(<span class="tableref"><a href="./03-veryl.html#ui3264">表2.3</a></span>)。</p>
<div id="ui3264" class="table">
<p class="caption">表2.3: 整数型</p>
<table>
<tr class="hline"><th>型名</th><th>等価な型</th></tr>
<tr class="hline"><td>u32</td><td>bit&lt;32&gt;</td></tr>
<tr class="hline"><td>u64</td><td>bit&lt;64&gt;</td></tr>
<tr class="hline"><td>i32</td><td>signed bit&lt;32&gt;</td></tr>
<tr class="hline"><td>i64</td><td>signed bit&lt;64&gt;</td></tr>
</table>
</div>
<p>数値は<span class="listref"><a href="./03-veryl.html#code.num_literal">リスト2.5</a></span>のように記述することができます。</p>
<div id="code.num_literal" class="caption-code">
<span class="caption">リスト2.5: リスト2.5: 数値リテラル</span>
<pre class="list language-num_literal">4'b0101 // 4ビットの数値 (2進数表記)
4'bxxzz // 4ビットの数値 (2進数表記)

12'o34xz // 12ビットの数値 (8進数表記)
32'h89abcdef // 32ビットの数値 (16進数表記)

123 // 10進数の数値
32'd12345 // 32ビットの数値 (10進数表記)

// 数値リテラルの好きな場所に_を挿入できる
1_2_34_567

// x, zは大文字でも良い
4'bxXzZ

// 全ビット0, 1, x, zにする
'0
'1
'x
'z

// 指定したビット幅だけ0, 1, x, zにする
8'0 // 8ビット0
8'1 // 8ビット1
8'x // 8ビットx
8'z // 8ビットz

// 幅を指定しない場合、幅が自動で推定される
'hffff // 16ビット
'h1fff // 13ビット
</pre>
</div>
<p>文字列は<b>string</b>型で表現することができます。文字列の値は<span class="listref"><a href="./03-veryl.html#string.literal">リスト2.6</a></span>のように記述することができます。</p>
<div id="string.literal" class="caption-code">
<span class="caption">リスト2.6: リスト2.6: 文字列リテラル</span>
<pre class="list language-literal">&quot;Hello World!&quot; // 文字列リテラル 
&quot;abcdef\nabc&quot;  // エスケープシーケンスを含む文字列リテラル
&quot;あうあうあー&quot;  // 日本語も入力できる
</pre>
</div>

<h3 class="none"><a id="h2-2-3"></a><span class="secno">2.2.3</span> module</h3>
<p>HDLによる論理回路は<b>モジュール</b>(Module)というコンポーネントで構成されます。例えば、半加算器のモジュールは次のように定義できます(<span class="listref"><a href="./03-veryl.html#halfadder.veryl">リスト2.7</a></span>).</p>
<div id="halfadder.veryl" class="caption-code">
<span class="caption">リスト2.7: リスト2.7: 半加算器(HalfAdder)モジュール</span>
<pre class="list language-veryl">module HalfAdder (
    x: input  logic, // 1ビットのlogic型の入力
    y: input  logic, // 1ビットのlogic型の入力
    s: output logic, // 1ビットのlogic型の出力
    c: output logic, // 1ビットのlogic型の出力
) {
    always_comb {
        s = x ^ y; // sにx XOR yを割り当てる
        c = x &amp; y; // cにx AND yを割り当てる
    }
}
</pre>
</div>
<p>HalfAdderモジュールには、入力変数として<code class="inline-code">x</code>, <code class="inline-code">y</code>、出力変数として<code class="inline-code">s</code>. <code class="inline-code">c</code>が宣言されています。入出力の変数のことを<b>接続ポート</b>、または単に<b>ポート</b>と呼びます。</p>
<p>入力ポートを定義するとき、モジュール名の後の括弧の中に、<code class="inline-code">変数名 : input 型名</code>と記述します。出力ポートを宣言するときは<code class="inline-code">input</code>の代わりに<code class="inline-code">output</code>と記述します。複数のポートを宣言するとき、宣言の末尾にカンマ(<code class="inline-code">,</code>)を記述します。</p>

<h4><a id="h2-2-3-1"></a>変数の宣言, 代入</h4>
<p>HalfAdderモジュールでは、<b>always_comb</b>ブロックで出力変数<code class="inline-code">s</code>, <code class="inline-code">c</code>に値を代入しています。変数への代入は<code class="inline-code">変数名 = 式;</code>で行います。</p>
<p>always_combブロック内で値を代入すると、代入される式は組み合わせ回路になります。</p>
<p>always_combブロックの中での代入の代わりに、<b>assign</b>文でも代入することができます(<span class="listref"><a href="./03-veryl.html#assign">リスト2.8</a></span>)。</p>
<div id="assign" class="caption-code">
<span class="caption">リスト2.8: リスト2.8: assign文による代入</span>
<pre class="list">// 下のalways_combと同じ意味になる
assign s = a ^ c;
assign c = a &amp; c;

// always_combによる代入
always_comb {
        s = a ^ c;
        c = a &amp; c;
}
</pre>
</div>
<p>通常のプログラミング言語での代入とは、スタック領域やレジスタに存在する変数に値を格納することです。これに対して、always_combブロックの中での代入やassign文による代入は変数に式(値)を<b>束縛</b>します。変数に式が束縛されると、式が評価(計算)された値が変数に1度だけ代入されるのではなく、変数の値は常に式の計算結果になります。</p>
<p>具体例で考えてみます。例えば、1ビットの変数xに1ビットの変数yをassign文で割り当てます(<span class="listref"><a href="./03-veryl.html#assign.wave">リスト2.9</a></span>)。</p>
<div id="assign.wave" class="caption-code">
<span class="caption">リスト2.9: リスト2.9: xにyを割り当てる</span>
<pre class="list language-wave">assign x = y;
</pre>
</div>
<p>yの値が時間経過により0, 1, 0, 1, 0というように遷移したとします。このとき、xの値はyが変わるのと同時に変化します。<span class="imgref"><a href="./03-veryl.html#assign_wave">図2.3</a></span>は、横軸が時間で、xとyの値を線の高低で表しています。<span class="imgref"><a href="./03-veryl.html#assign_wave">図2.3</a></span>のような図を波形図(waveform, 波形)と呼びます。</p>
<p>xにyではなくa + bを割り当てるとすると、aかbの変化をトリガーにxの値も変化します。</p>
<div id="assign_wave" class="image">
<img src="images/03-veryl/assign_wave.png" alt="xはyの値の変化に追従する" class="img" style="width:60%" />
<p class="caption">
図2.3: xはyの値の変化に追従する
</p>
</div>
<p>モジュールの中では、<b>var</b>文によって新しく変数を宣言することができます(<span class="listref"><a href="./03-veryl.html#var.stmt">リスト2.10</a></span>)。</p>
<div id="var.stmt" class="caption-code">
<span class="caption">リスト2.10: リスト2.10: 変数の宣言</span>
<pre class="list language-stmt">// var 変数名 : 型名;
var value : logic&lt;32&gt;;
</pre>
</div>
<p>var文によって宣言した変数は、assign文, またはalways_comb内での代入によって、式を束縛することができます。</p>
<p><b>let</b>文を使うと、変数の宣言と値の代入を同時に行うことができます。</p>
<div id="let.stmt" class="caption-code">
<span class="caption">リスト2.11: リスト2.11: 変数の宣言と代入</span>
<pre class="list language-stmt">// let 変数名 : 型名 = 式;
let value : logic&lt;32&gt; = 100 + a;
</pre>
</div>

<h4><a id="h2-2-3-2"></a>レジスタの定義, 代入</h4>
<p>変数を宣言するとき、変数に式が束縛されない場合、変数はレジスタとして解釈できます(<span class="listref"><a href="./03-veryl.html#reg.define">リスト2.12</a></span>)。</p>
<div id="reg.define" class="caption-code">
<span class="caption">リスト2.12: リスト2.12: レジスタの定義</span>
<pre class="list language-define">// var レジスタ名 : 型名;
var reg_value : logic&lt;32&gt;;

// always_combブロックの中での代入や、assign文での代入をしない
</pre>
</div>
<p>本書では、レジスタのことを変数,または変数のことをレジスタと呼ぶことがあります。</p>
<p>レジスタの値はクロック信号に同期したタイミングで変更し、リセット信号に同期したタイミングで初期化します(例:<span class="imgref"><a href="./03-veryl.html#register_wave">図2.4</a></span>)。本書では、クロック信号が<b>立ち上がる</b>(0から1に変わる)タイミングでレジスタの値を変更し、リセット信号が<b>立ち下がる</b>(1から0に変わる)タイミングでレジスタの値を初期化することとします。</p>
<div id="register_wave" class="image">
<img src="images/03-veryl/register_wave.png" alt="レジスタ(value)の値はクロック信号(clk)が立ち上がるタイミングで変わる" class="img" style="width:50%" />
<p class="caption">
図2.4: レジスタ(value)の値はクロック信号(clk)が立ち上がるタイミングで変わる
</p>
</div>
<p>レジスタの値は、<b>always_ff</b>ブロックで初期化, 変更します(<span class="listref"><a href="./03-veryl.html#always_ff.first">リスト2.13</a></span>)。always_ffブロックにはクロック信号名とリセット信号名を指定します。</p>
<div id="always_ff.first" class="caption-code">
<span class="caption">リスト2.13: リスト2.13: レジスタの値の初期化と変更</span>
<pre class="list language-first">// レジスタの定義
var value : logic&lt;32&gt;;

// always_ff(クロック信号名, リセット信号名)
always_ff(clk, rst) {
        if_reset {
                // リセット信号のタイミングで0に初期化する
                value = 0;
        } else {
                // クロック信号のタイミングでカウントアップする
                value = value + 1;
        }
}
</pre>
</div>
<p>クロック信号はclock型, リセット信号はreset型で定義します。モジュールのポートにクロック信号とリセット信号が定義されているとき、always_ffブロックのクロック信号とリセット信号の指定を省略できます(<span class="listref"><a href="./03-veryl.html#always_ff.omit">リスト2.14</a></span>)。</p>
<div id="always_ff.omit" class="caption-code">
<span class="caption">リスト2.14: リスト2.14: クロック信号とリセット信号の推論</span>
<pre class="list language-omit">module ModuleA(
  clk: input clock,
  rst: input reset,
){
        // always_ff(clk, rst)と等しい
        always_ff {}
}
</pre>
</div>
<p>1つのalways_ffブロックで、複数のレジスタの値を変更することができます。always_ffブロックの中で複数のレジスタの値を変更する時、全ての代入は同時に行われます。</p>
<div id="always_ff.nonblocking" class="caption-code">
<span class="caption">リスト2.15: リスト2.15: 代入のタイミングは同じ</span>
<pre class="list language-nonblocking">always_ff {
        if_reset {
                ...
        } else {
                // 2つの代入文が同時に実行される。
                // その結果、AとBの値が入れ替わる
                A = B;
                B = A;
        }
}
</pre>
</div>
<p>2つ以上のalways_ffブロックで、1つの同じレジスタの値を変更することはできません<sup><a id="fnb-clockdomain" href="#fn-clockdomain" class="noteref" epub:type="noteref">*4</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-clockdomain" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*4] </span>正確には可能ですが、本書では扱っていません</p></div>
</div><!--/.footnote-list-->

<h4><a id="h2-2-3-3"></a>モジュールのインスタンス化</h4>
<p>あるモジュールを利用したいとき、モジュールを<b>インスタンス化</b>(instantiate)することにより、モジュールのインスタンスを宣言することができます。</p>
<p>モジュールは、<b>inst</b>キーワードによってインスタンス化することができます(<span class="listref"><a href="./03-veryl.html#module.inst">リスト2.16</a></span>)。</p>
<div id="module.inst" class="caption-code">
<span class="caption">リスト2.16: リスト2.16: ModuleAモジュール内でHalfAdderモジュールをインスタンス化する</span>
<pre class="list language-inst">module ModuleA{
        // モジュールと接続するための変数の宣言
        let x : logic = 0;
        let y : logic = 1;
        var s : logic;
        var c : logic;

        // inst インスタンス名 : モジュール名(ポートとの接続);
        inst ha1 : HalfAdder(
                x: x, // ポートxに変数xを接続する
                y: y,
                s,    // ポート名と変数名が同じとき、ポート名の指定を省略できる 
                c,
        );
}
</pre>
</div>
<p>インスタンス名が違えば、同一のモジュールを2つ以上インスタンス化することができます。</p>

<h4><a id="h2-2-3-4"></a>パラメータ, 定数</h4>
<p>モジュールには変更可能な値(<b>パラメータ</b>)を用意することができ、モジュールをインスタンス化するときにパラメータの値を指定することができます。</p>
<p>モジュールのパラメータは、ポート宣言の前に<b>param</b>キーワードによって宣言することができます(<span class="listref"><a href="./03-veryl.html#module.param.define">リスト2.17</a></span>)。</p>
<div id="module.param.define" class="caption-code">
<span class="caption">リスト2.17: リスト2.17: モジュールのパラメータの宣言</span>
<pre class="list language-define">module ModuleA (
        // param パラメータ名 : 型名 = デフォルト値 
        param WIDTH : u32 = 100, // u32型のパラメータ
        param DATA_TYPE : type = logic, // type型のパラメータには型を指定できる
) (
        // ポートの宣言
) {}
</pre>
</div>
<p>モジュールをインスタンス化するとき、ポートの割り当てと同じようにパラメータの値を割り当てることができます(<span class="listref"><a href="./03-veryl.html#module.param.inst">リスト2.18</a></span>)。</p>
<div id="module.param.inst" class="caption-code">
<span class="caption">リスト2.18: リスト2.18: パラメータの値を指定する</span>
<pre class="list language-inst">inst ma : ModuleA #(
        // パラメータの割り当て
        WIDTH: 10,
        DATA_TYPE: logic&lt;10&gt;
) (
        // ポートの接続
);
</pre>
</div>
<p>パラメータに指定する値は、合成時に確定する値(定数)である必要があります。</p>
<p>モジュール内では、変更不可能なパラメータ(定数)を定義することができます。定数を定義するには<b>const</b>キーワードを使用します(<span class="listref"><a href="./03-veryl.html#const.use">リスト2.19</a></span>)。</p>
<div id="const.use" class="caption-code">
<span class="caption">リスト2.19: リスト2.19: 定数の定義</span>
<pre class="list language-use">// const 定数名 : 型名 = 式;
// 式に変数が含まれてはいけない
const SECRET : u32 = 42;
</pre>
</div>

<h3 class="none"><a id="h2-2-4"></a><span class="secno">2.2.4</span> ユーザー定義型</h3>

<h4><a id="h2-2-4-1"></a>構造体型</h4>
<p>構造体(struct)とは、複数のデータから構成される型です。例えば、<span class="listref"><a href="./03-veryl.html#struct.define">リスト2.20</a></span>のように記述すると、logic&lt;32&gt;とlogic&lt;16&gt;の2つのデータから構成される型を定義することができます。</p>
<div id="struct.define" class="caption-code">
<span class="caption">リスト2.20: リスト2.20: 構造体型の定義</span>
<pre class="list language-define">// struct 型名 { フィールドの定義 }
struct MyPair {
    // 名前 : 型
    word: logic&lt;32&gt;,
    half: logic&lt;16&gt;,
}
</pre>
</div>
<p>構造体の要素(フィールド, field)には、<code class="inline-code">.</code>を介してアクセスすることができます(<span class="listref"><a href="./03-veryl.html#struct.field.access">リスト2.21</a></span>)。</p>
<div id="struct.field.access" class="caption-code">
<span class="caption">リスト2.21: リスト2.21: フィールドへのアクセス, 割り当て</span>
<pre class="list language-access">// 構造体型の変数の宣言
var pair: MyPair;

// フィールドにアクセスする
let w : logic&lt;32&gt; = pair.word;

// フィールドに値を割り当てる
always_comb {
    pair.word = 12345;
}
</pre>
</div>

<h4><a id="h2-2-4-2"></a>列挙型</h4>
<p>複数の値の候補から値を選択できる型を作りたいとき、<b>列挙型</b>(enumerable type)を利用することができます。列挙型の値の候補名のことを<b>バリアント</b>(variant)と呼びます。</p>
<p>例えば、A, B, C, Dのいずれかのバリアントをとる型は次のように定義できます(<span class="listref"><a href="./03-veryl.html#enum.define">リスト2.22</a></span>)。</p>
<div id="enum.define" class="caption-code">
<span class="caption">リスト2.22: リスト2.22: 列挙型の定義</span>
<pre class="list language-define">// enum 型名 : logic&lt;バリアント数を保持できるだけのビット数&gt; { バリアントの定義 }
enum abc : logic&lt;2&gt; {
    // バリアント名 : バリアントを表す値,
    A = 2'd0,
    B = 2'd1,
    C = 2'd2,
    D = 2'd3
}
</pre>
</div>
<p>バリアントを表す値や、バリアントを保持できるだけのビット数は省略することができます(<span class="listref"><a href="./03-veryl.html#enum.omit">リスト2.23</a></span>)。省略された値は自動で推定されます。</p>
<div id="enum.omit" class="caption-code">
<span class="caption">リスト2.23: リスト2.23: 列挙型の省略した定義</span>
<pre class="list language-omit">enum abc {
    A, B, C, D
}
</pre>
</div>

<h4><a id="h2-2-4-3"></a>配列</h4>
<p><code class="inline-code">&lt;&gt;</code>を使用することで、多次元の型を定義することができます(<span class="listref"><a href="./03-veryl.html#logic.md">リスト2.24</a></span>)。</p>
<div id="logic.md" class="caption-code">
<span class="caption">リスト2.24: リスト2.24: 多次元の型</span>
<pre class="list language-md">logic        // 1ビットのlogic
logic&lt;N&gt;     // Nビットのlogic
logic&lt;A, B&gt;  // A * Bの2次元のlogic
</pre>
</div>
<p><code class="inline-code">[]</code>を使用することで、配列を定義することができます(<span class="listref"><a href="./03-veryl.html#array.define">リスト2.25</a></span>)。</p>
<div id="array.define" class="caption-code">
<span class="caption">リスト2.25: リスト2.25: 配列型</span>
<pre class="list language-define">// 型名[個数] で、&quot;型名&quot;型が&quot;個数&quot;個の配列型になる
logic[32]     // 32個のlogicが並ぶ型
logic[4, 8]   // logicが8個並ぶ配列が4個並ぶ配列型
</pre>
</div>

<h4><a id="h2-2-4-4"></a>型に別名をつける</h4>
<p><b>type</b>キーワードを使うと、型に別名を付けることができます(type.define)。</p>
<div id="type.define" class="caption-code">
<span class="caption">リスト2.26: リスト2.26: 型に別名を付ける</span>
<pre class="list language-define">// type 名前 = 型;
type ptr        = logic&lt;32&gt;;
type ptr_array  = ptr&lt;32&gt;
</pre>
</div>

<h3 class="none"><a id="h2-2-5"></a><span class="secno">2.2.5</span> 式, 文, 宣言</h3>

<h4><a id="h2-2-5-1"></a>演算子</h4>
<p>Verylでは、次の演算子を使用することができます(<span class="listref"><a href="./03-veryl.html#operator">リスト2.27</a></span>)。</p>
<p>TODO</p>
<div id="operator" class="caption-code">
<span class="caption">リスト2.27: リスト2.27: 単項演算子, 二項演算子</span>
<pre class="list">これはdocからのコピペ

// 単項算術演算
a = +1;
a = -1;

// 単項論理演算
a = !1;
a = ~1;

// 単項集約演算
a = &amp;1;
a = |1;
a = ^1;
a = ~&amp;1;
a = ~|1;
a = ~^1;
a = ^~1;

// 二項算術演算
a = 1 ** 1;
a = 1 * 1;
a = 1 / 1;
a = 1 % 1;
a = 1 + 1;
a = 1 - 1;

// シフト演算
a = 1 &lt;&lt; 1;
a = 1 &gt;&gt; 1;
a = 1 &lt;&lt;&lt; 1;
a = 1 &gt;&gt;&gt; 1;

// 比較演算
a = 1 &lt;: 1;
a = 1 &lt;= 1;
a = 1 &gt;: 1;
a = 1 &gt;= 1;
a = 1 == 1;
a = 1 != 1;
a = 1 === 1;
a = 1 !== 1;
a = 1 ==? 1;
a = 1 !=? 1;

// ビット演算
a = 1 &amp; 1;
a = 1 ^ 1;
a = 1 ~^ 1;
a = 1 ^~ 1;
a = 1 | 1;

// 二項論理演算
a = 1 &amp;&amp; 1;
a = 1 || 1;
</pre>
</div>

<h4><a id="h2-2-5-2"></a>ビット選択</h4>
<div id="bitsel" class="image">
<img src="images/03-veryl/bitsel.png" alt="ビット選択" class="img" style="width:50%" />
<p class="caption">
図2.5: ビット選択
</p>
</div>
<p>変数の任意のビットを切り出すには<code class="inline-code">[]</code>を使用します(<span class="imgref"><a href="./03-veryl.html#bitsel">図2.5</a></span>)。範囲の指定には<code class="inline-code">[:]</code>を使用します。最上位ビット(most significant bit)は<b>msb</b>キーワード,最下位ビット(least significant bit)は<b>lsb</b>キーワードで指定することができます。選択する場所の指定には式を使うことができます。</p>

<h4><a id="h2-2-5-3"></a>if, switch, case</h4>
<p>TODO式と文</p>

<h4><a id="h2-2-5-4"></a>連結, repeat</h4>
<p>ビット列や文字列を連結したいときは<code class="inline-code">\{}</code>を使用することができます(<span class="listref"><a href="./03-veryl.html#renketu">リスト2.28</a></span>)。<code class="inline-code">+</code>では連結できない(値の足し算になる)ことに注意してください。</p>
<div id="renketu" class="caption-code">
<span class="caption">リスト2.28: リスト2.28: 連結</span>
<pre class="list">{12'h123, 32'habcd0123} // 44'h123_abcde0123になる
{&quot;Hello&quot;, &quot; &quot;, &quot;World!&quot;} // &quot;Hello World!&quot;になる
</pre>
</div>
<p>同じビット列, 文字列を繰り返して連結したいとき、<b>repeat</b>キーワードを使用します(<span class="listref"><a href="./03-veryl.html#repeat">リスト2.29</a></span>)。</p>
<div id="repeat" class="caption-code">
<span class="caption">リスト2.29: リスト2.29: repeatを使って、連結を繰り返す</span>
<pre class="list">{4'0011 repeat 3, 4'b1111} // 16'b0011_0011_0011_1111になる
{&quot;Happy&quot; repeat 3} // &quot;HappyHappyHappy&quot;になる
</pre>
</div>

<h4><a id="h2-2-5-5"></a>for ..=</h4>
<p>TODO</p>

<h4><a id="h2-2-5-6"></a>function</h4>
<p>TODO</p>

<h4><a id="h2-2-5-7"></a>initial, final</h4>
<p><b>initial</b>ブロックの中の文は、シミュレーションの開始時に実行されます。<b>final</b>ブロックの中の文は、シミュレーションの終了時に実行されます。</p>
<div id="initial.final" class="caption-code">
<span class="caption">リスト2.30: リスト2.30: initial, finalブロック</span>
<pre class="list language-final">module ModuleA {
    initial {
                // シミュレーション開始時に実行される
    }
    final {
                // シミュレーション終了時に実行される
    }
}
</pre>
</div>

<h3 class="none"><a id="h2-2-6"></a><span class="secno">2.2.6</span> interface</h3>
<p>TODO</p>
<p>楽に済ますよ</p>
<p>定義, パラメータも使えます</p>
<p>modportでらくちんの例</p>
<p>インスタンス化する例</p>

<h3 class="none"><a id="h2-2-7"></a><span class="secno">2.2.7</span> package</h3>
<p>TODO</p>
<p>const, type, function</p>
<p>import</p>

<h3 class="none"><a id="h2-2-8"></a><span class="secno">2.2.8</span> ジェネリクス</h3>
<p>TODO</p>
<ul>
<li>function
</li>
<li>module
</li>
<li>interface
</li>
<li>package
</li>
</ul>

<h3 class="none"><a id="h2-2-9"></a><span class="secno">2.2.9</span> その他の機能</h3>

<h4><a id="h2-2-9-1"></a>SystemVerilogとの連携</h4>
<p>VerylはSystemVerilogのモジュールやパッケージ, インターフェースを利用することができます。SystemVerilogのリソースにアクセスすには<b>$sv::</b>キーワードを使用します。</p>
<div id="sv.use" class="caption-code">
<span class="caption">リスト2.31: リスト2.31: SystemVerilogの要素を利用する</span>
<pre class="list language-use">module ModuleA {
        // SystemVerilogプログラムでsvpackageとして
        // 定義されているパッケージを利用する
        let x = $sv::svpackage::X;
        let y = $sv::svpackage::Y;

        var s: logic;
        var c: logic;

        // SystemVerilogプログラムでHalfAdderとして
        // 定義されているモジュールをインスタンス化する
        inst ha : $sv::HalfAdder(
                x, y, s, c
        );

        // SystemVerilogプログラムでsvinterfaceとして
        // 定義されているインターフェースをインスタンス化する
    inst c: $sv::svinterface;
}
</pre>
</div>
<p>SystemVerilogプログラムを直接埋め込み、含めることができます(<span class="listref"><a href="./03-veryl.html#sv.integrate">リスト2.32</a></span>)。</p>
<div id="sv.integrate" class="caption-code">
<span class="caption">リスト2.32: リスト2.32: SystemVerilogプログラムを埋め込む</span>
<pre class="list language-integrate">// SystemVerilogプログラムを直接埋め込む
embed (inline) sv{{{
    module ModuleA(
                output logic a
        );
                assign a = 0;
    endmodule
}}}

// SystemVerilogプログラムのファイルを展開する
// パスは相対パス
include(inline, &quot;filename.sv&quot;);
</pre>
</div>

<h4><a id="h2-2-9-2"></a>システム関数 / システムタスク</h4>
<p>SystemVerilogに標準で用意されている関数(システム関数, システムタスク)を利用することができます。システム関数(system function), システムタスク(system task)の名前は、<code class="inline-code">$</code>から始まります。本書で利用するシステム関数, システムタスクを<span class="tableref"><a href="./03-veryl.html#systemtasks">表2.4</a></span>に列挙します。それぞれの使用例は次の通りです(<span class="listref"><a href="./03-veryl.html#systemtask.use">リスト2.33</a></span>)。</p>
<p>システム関数, システムタスクを利用するときは、通常の関数呼び出しのように使用します。</p>
<div id="systemtask.use" class="caption-code">
<span class="caption">リスト2.33: リスト2.33: システム関数, システムタスクの使用例</span>
<pre class="list language-use">const w1 : u32 = $clog2(32); // 5
const w2 : u32 = $clog2(35); // 6

var array : logic&lt;4,8&gt;;
const s1 : u32 = $size(array); // 4
const s2 : u32 = $bits(array); // 32

var uvalue : u32;
let svalue : i32 = $signed(uvalue) + 1;

initial {
        $readmemh(&quot;file.hex&quot;, array);
        $display(&quot;Hello World!&quot;);
        $error(&quot;Error!&quot;);
        $finish();
}
</pre>
</div>
<div id="systemtasks" class="table">
<p class="caption">表2.4: 本書で使用するシステム関数, システムタスク</p>
<table>
<tr class="hline"><th>関数名</th><th>機能</th><th>戻り値</th></tr>
<tr class="hline"><td>$clog2</td><td>値のlog2のceilを求める</td><td>数値</td></tr>
<tr class="hline"><td>$size</td><td>配列のサイズを求める</td><td>数値</td></tr>
<tr class="hline"><td>$bits</td><td>値の幅を求める</td><td>数値</td></tr>
<tr class="hline"><td>$signed</td><td>値を符号付きとして扱う</td><td>符号付きの値</td></tr>
<tr class="hline"><td>$readmemh</td><td>レジスタにファイルのデータを代入する</td><td>なし</td></tr>
<tr class="hline"><td>$display</td><td>文字列を出力する</td><td>なし</td></tr>
<tr class="hline"><td>$error</td><td>エラー出力する</td><td>なし</td></tr>
<tr class="hline"><td>$finish</td><td>シミュレーションを終了する</td><td>なし</td></tr>
</table>
</div>

<h4><a id="h2-2-9-3"></a>標準ライブラリ</h4>
<p>Verylには、よく使うモジュールなどが標準ライブラリと準備されています。標準ライブラリは<a href="https://std.veryl-lang.org/" class="link">https://std.veryl-lang.org/</a>で確認することができます。</p>
<p>本書では標準ライブラリを使用していないため、説明は割愛します。</p>

        </main>
        <nav class="page-navi">
          <a href="02-setup.html" class="page-prev">&#9664;</a>
          <a href="04-impl-rv32i.html" class="page-next">&#9654;</a>
        </nav>
        <footer>
        </footer>
      </div>
    </div>
  </body>
</html>
<!-- layout.html5.erb -->
