<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>ハードウェア記述言語 Veryl | Verylで作るCPU</title>
    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="RV32Iの実装" href="04-impl-rv32i.html">
    <link rel="prev" title="環境構築" href="02-setup.html">
    <meta name="generator" content="Re:VIEW Starter">
  </head>
  <body>
    <div class="page-outer">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>
<ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき / はじめに</a></li>
<li class="toc-part">第I部 RV32I/RV64Iの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./02-setup.html">1 環境構築</a></li>
    <li class="toc-chapter"><a href="./03-veryl.html">2 ハードウェア記述言語 Veryl</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="#h2-1">2.1 ハードウェア記述言語</a></li>
        <li class="toc-section"><a href="#h2-2">2.2 Verylの基本文法, 機能</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./04-impl-rv32i.html">3 RV32Iの実装</a></li>
    <li class="toc-chapter"><a href="./04a-zicsr.html">4 Zicsr拡張の実装</a></li>
    <li class="toc-chapter"><a href="./04b-riscvtests.html">5 riscv-testsによるテスト</a></li>
    <li class="toc-chapter"><a href="./05-impl-rv64i.html">6 RV64Iの実装</a></li>
    <li class="toc-chapter"><a href="./05a-pipeline.html">7 CPUのパイプライン処理化</a></li>
    <li class="toc-chapter"><a href="./05b-synth.html">8 CPUを合成する</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99-postface.html">あとがき / おわりに</a></li>
    <li class="toc-chapter"><a href="./bib.html">参考文献</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
<h1 class="boldlines center twolines"><a id="h2"></a><span class="secno">第2章</span> <br/>ハードウェア記述言語 Veryl</h1>

<h2 id="hdl" class="numbox"><a id="h2-1"></a><span class="secno">2.1</span> ハードウェア記述言語</h2>
<p>CPUを記述するといっても、いったいどうやって記述するのでしょうか?まずは、論理回路を構成する方法から考えます。</p>

<h3 class="none"><a id="h2-1-1"></a><span class="secno">2.1.1</span> 論理回路の構成</h3>
<p><b>論理回路</b>とは、デジタル(例えば0と1だけ)なデータを利用して、データを加工、保持する回路のことです。論理回路は、組み合わせ回路と順序回路に分類することができます。</p>
<p><b>組み合わせ回路</b>とは、入力に対して、一意に出力の決まる回路<a href="bib.html#bib-ronrikairo">[2]</a>のことです。例えば、<span class="imgref"><a href="./03-veryl.html#halfadder">図2.1</a></span>は半加算器です。半加算器とは1ビットの加算を行う回路で、入力X, Yが決まると、出力C, Sが一意に決まります(<span class="tableref"><a href="./03-veryl.html#halfadder.truth">表2.1</a></span>)。</p>
<div id="halfadder" class="image">
<img src="images/03-veryl/halfadder.png" alt="半加算器 (MIL記法)" class="img" style="width:45%" />
<p class="caption">
図2.1: 半加算器 (MIL記法)
</p>
</div>
<div id="halfadder.truth" class="table">
<p class="caption">表2.1: 半加算器 (真理値表)</p>
<table>
<tr class="hline"><th>X</th><th>Y</th><th>C</th><th>S</th></tr>
<tr class="hline"><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr class="hline"><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr class="hline"><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr class="hline"><td>1</td><td>1</td><td>1</td><td>0</td></tr>
</table>
</div>
<p><b>順序回路</b>とは、入力と回路自身の状態によって一意に出力の決まる回路<a href="bib.html#bib-ronrikairo">[2]</a>です。例えば、入力が1になるたびにカウントアップして値を表示するカウンタを考えます(<span class="imgref"><a href="./03-veryl.html#downcounter">図2.2</a></span>)。カウントアップするためには、今のカウンタの値(状態)を保持する必要があります。よって、このカウンタは入力と状態によって一意に出力の決まる順序回路です。</p>
<p>1ビットの値はフリップフロップという回路によって保持することができます。フロップフロップをN個並列に並べると、Nビットの値を保持することができます。フリップフロップを並列に並べた記憶装置のことを、<b>レジスタ</b>(register, 置数器)と呼びます。基本的に、レジスタの値はリセット信号によって初期化し、クロック信号に同期したタイミングで変更します。</p>
<div id="downcounter" class="image">
<img src="images/03-veryl/downcounter.png" alt="カウンタ" class="img" style="width:70%" />
<p class="caption">
図2.2: カウンタ
</p>
</div>
<p>論理回路を設計するには、真理値表を作成し、それを実現する論理演算を構成します。入力数や状態数が数十個ならどうにか人力で設計できるかもしれませんが、数千, 数万の入力や状態があるとき、手作業で設計するのはほとんど不可能です。これを設計するために、ハードウェア記述言語を利用します。</p>

<h3 class="none"><a id="h2-1-2"></a><span class="secno">2.1.2</span> ハードウェア記述言語</h3>
<p><b>ハードウェア記述言語</b>(Hardware Description Language, HDL)とは、デジタル回路を設計するための言語です。</p>
<p>例えばHDLであるSystemVerilogを利用すると、半加算器は<span class="listref"><a href="./03-veryl.html#halfadder.sv">リスト2.1</a></span>のように記述することができます。</p>
<div id="halfadder.sv" class="caption-code">
<span class="caption">リスト2.1: リスト2.1: SystemVerilogによる半加算器の記述</span>
<pre class="list language-sv">module HalfAdder(
  input logic x,        // 入力値X
  input logic y,        // 入力値Y
  output logic c,       // 出力地C
  output logic s        // 出力地S
);
  assign s = x ^ y; // ^はXOR演算
  assign c = x &amp; y; // &amp;はAND演算
endmodule
</pre>
</div>
<p>また、レジスタを利用した回路を<span class="listref"><a href="./03-veryl.html#counter.sv">リスト2.2</a></span>のように記述することができます。レジスタの値を、リセット信号<code class="inline-code">rst</code>が<code class="inline-code">0</code>になったタイミングで<code class="inline-code">0</code>に初期化し、クロック信号<code class="inline-code">clk</code>が<code class="inline-code">1</code>になったタイミングでカウントアップします。</p>
<div id="counter.sv" class="caption-code">
<span class="caption">リスト2.2: リスト2.2: SystemVerilogによるカウンタの記述</span>
<pre class="list language-sv">module Counter(
  input logic clk, // クロック信号
  input logic rst  // リセット信号
);
  // 32ビットのレジスタの定義
  logic [31:0] count;

  always_ff @(posedge clk, negedge rst) begin
    if (!rst) begin
      // rstが0になったとき、countを0に初期化する
      count &lt;= 0;
    end else begin
      // clkが1になったとき、countの値をcount + 1にする
      count &lt;= count + 1;
    end
  end
endmodule
</pre>
</div>
<p>HDLを使用すると、論理回路を、レジスタの値と入力値を使った組み合わせ回路と、その結果をレジスタに値を格納する操作として記述できます。このような、レジスタからレジスタに、組み合わせ回路を通したデータを転送する抽象度のことを<b>レジスタ転送レベル</b>(Register Transfer Level, RTL)と呼びます。</p>
<p>HDLで記述された論理回路は、<b>合成系</b>によって、RTLから実際の回路のデータに変換(<b>合成</b>)されます。</p>

<h3 class="none"><a id="h2-1-3"></a><span class="secno">2.1.3</span> Veryl</h3>
<p>メジャーなHDLといえば、Verilog HDL, SystemVerilogなどが挙げられます<sup><a id="fnb-vhdl" href="#fn-vhdl" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-vhdl" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>VHDLが無いじゃないかと思った方、すみません。VHDLのことを私はよく知らないので無いことにしました。</p></div>
</div><!--/.footnote-list-->
<p>Verilog HDL(Verilog)は1980年代に開発された言語であり、最近のプログラミング言語と比べると機能が少なく、冗長な記述が必要です。SystemVerilogはVerilogのスーパーセットです。言語機能が増えて便利になっていますが、スーパーセットであることから、あまり推奨されない古い書き方が可能だったり、(バグの原因となるような)良くない仕様<sup><a id="fnb-nettype" href="#fn-nettype" class="noteref" epub:type="noteref">*2</a></sup>を受け継いでいます。</p>
<div class="footnote-list">
<div class="footnote" id="fn-nettype" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>例えば、未定義の変数が1ビット幅の信号線として解釈される仕様があります。ヤバすぎる</p></div>
</div><!--/.footnote-list-->
<p>本書では、CPUの実装にVerylというHDLを使用します。Verylは2022年12月に公開された言語です。Verylの抽象度は、Verilogと同じくレジスタ転送レベルです。Verylの文法や機能は、Verilog, SystemVerilogに似通ったものになっています。しかし、if式やcase式,クロックとリセットの抽象化,ジェネリクスなど、痒い所に手が届く機能が提供されており、高い生産性を発揮します。</p>
<p>Verylプログラムは、コンパイラ(トランスパイラ)によって、自然で読みやすいSystemVerilogプログラムに変換されます。よって、Verylは旧来のSystemVerilogの環境と共存することができ、SystemVerilogの資産を利用することができます。</p>
<div class="miniblock miniblock-caution">
<p class="miniblock-caption">注意</p>
<p>本書は2024/10/19時点のVeryl(バージョン0.13.1)について、本書で利用する範囲の文法, 機能を解説しています。Verylはまだ開発途上(正式版, 安定版がリリースされていない)状態の言語です。破壊的変更が入り、記載しているコードが使えなくなる可能性があります。</p>
<p>本書に記載しているコードの中には、バージョン0.13.1では不具合によって実行できないものがあります。不具合の回避手段についてはサポートページ<sup><a id="fnb-support" href="#fn-support" class="noteref" epub:type="noteref">*3</a></sup>をご覧ください。また、最新のVerylに対応した解説はweb版, pdf版を確認してください。</p>
</div>
<div class="footnote-list">
<div class="footnote" id="fn-support" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*3] </span>https://github.com/nananapo/veryl-riscv-book/wiki/techbookfest17-support-page</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h2-2"></a><span class="secno">2.2</span> Verylの基本文法, 機能</h2>
<p>それでは、Verylの書き方を簡単に学んでいきましょう。Verylのドキュメントは<a href="https://doc.veryl-lang.org/book/ja/" class="link">https://doc.veryl-lang.org/book/ja/</a>に存在します。また、<a href="https://doc.veryl-lang.org/playground/" class="link">Veryl Playground</a>では、VerylプログラムのSystemVerilogプログラムへのトランスパイルを試すことができます。</p>

<h3 class="none"><a id="h2-2-1"></a><span class="secno">2.2.1</span> コメント, 空白</h3>
<p>Verylでは次のようにコメントを記述することができます(<span class="listref"><a href="./03-veryl.html#code.comment">リスト2.3</a></span>)。</p>
<div id="code.comment" class="caption-code">
<span class="caption">リスト2.3: リスト2.3: コメント</span>
<pre class="list language-comment">  // 1行のコメント
  /* 範囲コメント */
</pre>
</div>

<h3 class="none"><a id="h2-2-2"></a><span class="secno">2.2.2</span> 値, 数値リテラル</h3>
<p>論理回路では、デジタルな値を扱います。デジタルな値は<code class="inline-code">0</code>と<code class="inline-code">1</code>の二値(2-state)で表現されますが、一般的なハードウェア記述言語では、<code class="inline-code">0</code>と<code class="inline-code">1</code>に<code class="inline-code">x</code>, <code class="inline-code">z</code>を加えた四値(4-state)が利用されます(<span class="tableref"><a href="./03-veryl.html#table.fourstate">表2.2</a></span>)。</p>
<div id="table.fourstate" class="table">
<p class="caption">表2.2: 4-stateの値</p>
<table>
<tr class="hline"><th>値</th><th>意味</th><th>真偽</th></tr>
<tr class="hline"><td>0</td><td>0</td><td>偽</td></tr>
<tr class="hline"><td>1</td><td>1</td><td>真</td></tr>
<tr class="hline"><td>x</td><td>unknown</td><td>偽</td></tr>
<tr class="hline"><td>z</td><td>high-inpedance</td><td>偽</td></tr>
</table>
</div>
<p><b>不定値</b>(unknown value)とは、0か1のどちらか分からない値です。不定値は、未初期化のレジスタの値の表現に利用されたり、不定値との演算の結果として生成されます。<b>ハイインピーダンス</b>(high-inpedance)とは、どのレジスタ, 信号とも接続されていないことを表す値です。物理的なハードウェア上では、全ての値は0か1の二値として解釈されます。不定値とハイインピーダンスはシミュレーションのときにのみ利用されます。</p>
<p>1ビットの四値を表現するための型は<b>logic</b>です。Nビットのlogic型は<b>logic&lt;N&gt;</b>のように記述することができます。1ビットの二値を表現する型は<b>bit</b>です。基本的に、レジスタや信号の定義にbit型は利用せず、logic型を利用します。</p>
<p>logic, bit型は、デフォルトで符号が無い型として扱われます。符号付き型として扱いたいときは、型名の前に<b>signed</b>キーワードを追加します(<span class="listref"><a href="./03-veryl.html#code.signed_keyword">リスト2.4</a></span>)。</p>
<div id="code.signed_keyword" class="caption-code">
<span class="caption">リスト2.4: リスト2.4: 符号付き型</span>
<pre class="list language-signed_keyword">signed logic&lt;4&gt; // 4ビットの符号付きlogic型
signed bit&lt;2&gt; // 2ビットの符号付きbit型
</pre>
</div>
<p>32, 64ビットのbit型を表す型が定義されています(<span class="tableref"><a href="./03-veryl.html#ui3264">表2.3</a></span>)。</p>
<div id="ui3264" class="table">
<p class="caption">表2.3: 整数型</p>
<table>
<tr class="hline"><th>型名</th><th>等価な型</th></tr>
<tr class="hline"><td>u32</td><td>bit&lt;32&gt;</td></tr>
<tr class="hline"><td>u64</td><td>bit&lt;64&gt;</td></tr>
<tr class="hline"><td>i32</td><td>signed bit&lt;32&gt;</td></tr>
<tr class="hline"><td>i64</td><td>signed bit&lt;64&gt;</td></tr>
</table>
</div>
<p>数値は<span class="listref"><a href="./03-veryl.html#code.num_literal">リスト2.5</a></span>のように記述することができます。</p>
<div id="code.num_literal" class="caption-code">
<span class="caption">リスト2.5: リスト2.5: 数値リテラル</span>
<pre class="list language-num_literal">4'b0101 // 4ビットの数値 (2進数表記)
4'bxxzz // 4ビットの数値 (2進数表記)

12'o34xz // 12ビットの数値 (8進数表記)
32'h89abcdef // 32ビットの数値 (16進数表記)

123 // 10進数の数値
32'd12345 // 32ビットの数値 (10進数表記)

// 数値リテラルの好きな場所に_を挿入できる
1_2_34_567

// x, zは大文字でも良い
4'bxXzZ

// 全ビット0, 1, x, zにする
'0
'1
'x
'z

// 指定したビット幅だけ0, 1, x, zにする
8'0 // 8ビット0
8'1 // 8ビット1
8'x // 8ビットx
8'z // 8ビットz

// 幅を指定しない場合、幅が自動で推定される
'hffff // 16ビット
'h1fff // 13ビット
</pre>
</div>

<h3 class="none"><a id="h2-2-3"></a><span class="secno">2.2.3</span> module</h3>
<p>HDLによる論理回路は<b>モジュール</b>(Module)というコンポーネントで構成されます。例えば、半加算器のモジュールは次のように定義できます(<span class="listref"><a href="./03-veryl.html#halfadder.veryl">リスト2.6</a></span>).</p>
<div id="halfadder.veryl" class="caption-code">
<span class="caption">リスト2.6: リスト2.6: 半加算器(HalfAdder)モジュール</span>
<pre class="list language-veryl">module HalfAdder (
    x: input  logic, // 1ビットのlogic型の入力
    y: input  logic, // 1ビットのlogic型の入力
    s: output logic, // 1ビットのlogic型の出力
    c: output logic, // 1ビットのlogic型の出力
) {
    always_comb {
        s = x ^ y; // sにx XOR yを割り当てる
        c = x &amp; y; // cにx AND yを割り当てる
    }
}
</pre>
</div>
<p>HaldAdderモジュールには、入力変数として<code class="inline-code">x</code>, <code class="inline-code">y</code>、出力変数として<code class="inline-code">s</code>. <code class="inline-code">c</code>が宣言されています。入出力の変数のことを<b>接続ポート</b>、または単に<b>ポート</b>と呼びます。</p>
<p>入力ポートを定義するとき、モジュール名の後の括弧の中に、<code class="inline-code">変数名 : input 型名</code>と記述します。出力ポートを宣言するときは<code class="inline-code">input</code>の代わりに<code class="inline-code">output</code>と記述します。複数のポートを宣言するとき、宣言の末尾にカンマ(<code class="inline-code">,</code>)を記述します。</p>

<h4><a id="h2-2-3-1"></a>変数の宣言, 代入</h4>
<p>HalfAdderモジュールでは、<b>always_comb</b>ブロックで出力変数<code class="inline-code">s</code>, <code class="inline-code">c</code>に値を割り当てています。変数への値の割り当ては<code class="inline-code">変数名 = 式</code>で行います。</p>
<p>always_combブロック内で値を割り当てると、割り当てる式は組み合わせ回路になります。</p>
<p>always_combの中での割り当ては、<b>assign</b>文でも記述することができます(<span class="listref"><a href="./03-veryl.html#assign">リスト2.7</a></span>)。</p>
<div id="assign" class="caption-code">
<span class="caption">リスト2.7: リスト2.7: assign文による代入</span>
<pre class="list">        // 下のalways_combと同じ意味になる
        assign s = a ^ c;
        assign c = a &amp; c;

        // always_combによる代入
        always_comb {
                s = a ^ c;
                c = a &amp; c;
        }
</pre>
</div>
<p>モジュールの中では、<b>var</b>文によって新しく変数を宣言することができます(<span class="listref"><a href="./03-veryl.html#var.stmt">リスト2.8</a></span>)。</p>
<div id="var.stmt" class="caption-code">
<span class="caption">リスト2.8: リスト2.8: 変数の宣言</span>
<pre class="list language-stmt">        // var 変数名 : 型名;
        var value : logic&lt;32&gt;;
</pre>
</div>
<p><code class="inline-code">var</code>文によって宣言した変数は、<code class="inline-code">assign</code>文, または<code class="inline-code">always_comb</code>内での割り当てによって、値を割り当てることができます。</p>
<p>変数の定義と値の</p>
<ul>
<li>let, var
</li>
<li>always_comb 連続代入, assign
</li>
<li>always_ff, if_reset ノンブロッキング
</li>
</ul>

<h4><a id="h2-2-3-2"></a>モジュールのパラメータ</h4>

<h4><a id="h2-2-3-3"></a>モジュールのインスタンス化</h4>

<h4><a id="h2-2-3-4"></a>initial, final</h4>

<h3 class="none"><a id="h2-2-4"></a><span class="secno">2.2.4</span> 型</h3>

<h4><a id="h2-2-4-1"></a>配列</h4>
<p><code class="inline-code">[]</code>を利用することで、配列を定義することができます。</p>
<p>struct,enum,clock,reset,配列,多次元type</p>

<h3 class="none"><a id="h2-2-5"></a><span class="secno">2.2.5</span> 定数</h3>
<p>const</p>

<h3 class="none"><a id="h2-2-6"></a><span class="secno">2.2.6</span> 式</h3>
<ul>
<li>ビット選択
</li>
<li>式 (演算子)
</li>
<li>if式, case式
</li>
<li>連接, repeat
</li>
<li>msb. lsb
</li>
</ul>

<h3 class="none"><a id="h2-2-7"></a><span class="secno">2.2.7</span> 文</h3>
<ul>
<li>変数 (var, let)
</li>
<li>if, case, for
</li>
<li>function
</li>
</ul>

<h3 class="none"><a id="h2-2-8"></a><span class="secno">2.2.8</span> interface</h3>
<ul>
<li>パラメータ化
</li>
<li>modport
</li>
<li>インスタンス化
</li>
</ul>

<h3 class="none"><a id="h2-2-9"></a><span class="secno">2.2.9</span> package</h3>
<ul>
<li>import
</li>
</ul>

<h3 class="none"><a id="h2-2-10"></a><span class="secno">2.2.10</span> ジェネリクス</h3>
<ul>
<li>function
</li>
<li>module
</li>
<li>interface
</li>
<li>package
</li>
</ul>

<h3 class="none"><a id="h2-2-11"></a><span class="secno">2.2.11</span> その他の機能</h3>
<ul>
<li>$sv
</li>
<li>SystemVerilogの機能 (システムタスク)
</li>
</ul>
<p>$display, readmemh, clog2, size, bits, signed, error, finish</p>
<ul>
<li>標準ライブラリ</li>
</ul>

        </main>
        <nav class="page-navi">
          <a href="02-setup.html" class="page-prev">&#9664;</a>
          <a href="04-impl-rv32i.html" class="page-next">&#9654;</a>
        </nav>
        <footer>
        </footer>
      </div>
    </div>
  </body>
</html>
<!-- layout.html5.erb -->
