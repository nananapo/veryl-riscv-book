<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>ハードウェア記述言語 Veryl | Verylで作るCPU</title>
    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="RV32Iの実装" href="04-impl-rv32i.html">
    <link rel="prev" title="環境構築" href="02-setup.html">
    <meta name="generator" content="Re:VIEW Starter">
  </head>
  <body>
    <div class="page-outer">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>
<ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき / はじめに</a></li>
<li class="toc-part">第I部 RV32I/RV64Iの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./02-setup.html">1 環境構築</a></li>
    <li class="toc-chapter"><a href="./03-veryl.html">2 ハードウェア記述言語 Veryl</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="#h2-1">2.1 ハードウェア記述言語</a></li>
        <li class="toc-section"><a href="#h2-2">2.2 Verylの基本文法, 機能</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./04-impl-rv32i.html">3 RV32Iの実装</a></li>
    <li class="toc-chapter"><a href="./04a-zicsr.html">4 Zicsr拡張の実装</a></li>
    <li class="toc-chapter"><a href="./04b-riscvtests.html">5 riscv-testsによるテスト</a></li>
    <li class="toc-chapter"><a href="./05-impl-rv64i.html">6 RV64Iの実装</a></li>
    <li class="toc-chapter"><a href="./05a-pipeline.html">7 CPUのパイプライン処理化</a></li>
    <li class="toc-chapter"><a href="./05b-synth.html">8 CPUを合成する</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99-postface.html">あとがき / おわりに</a></li>
    <li class="toc-chapter"><a href="./bib.html">参考文献</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
<h1 class="boldlines center twolines"><a id="h2"></a><span class="secno">第2章</span> <br/>ハードウェア記述言語 Veryl</h1>

<h2 id="hdl" class="numbox"><a id="h2-1"></a><span class="secno">2.1</span> ハードウェア記述言語</h2>
<p>CPUを記述するといっても、いったいどうやって記述するのでしょうか?まずは、論理回路を構成する方法から考えます。</p>

<h3 class="none"><a id="h2-1-1"></a><span class="secno">2.1.1</span> 論理回路の構成</h3>
<p><b>論理回路</b>とは、デジタル(例えば0と1だけ)なデータを利用して、データを加工、保持する回路のことです。論理回路は、組み合わせ回路と順序回路に分類することができます。</p>
<p><b>組み合わせ回路</b>とは、入力に対して、一意に出力の決まる回路<a href="bib.html#bib-ronrikairo">[2]</a>のことです。例えば、<span class="imgref"><a href="./03-veryl.html#halfadder">図2.1</a></span>は半加算器です。半加算器とは1ビットの加算を行う回路で、入力X, Yが決まると、出力C, Sが一意に決まります(<span class="tableref"><a href="./03-veryl.html#halfadder.truth">表2.1</a></span>)。</p>
<div id="halfadder" class="image">
<img src="images/03-veryl/halfadder.png" alt="半加算器 (MIL記法)" class="img" style="width:45%" />
<p class="caption">
図2.1: 半加算器 (MIL記法)
</p>
</div>
<div id="halfadder.truth" class="table">
<p class="caption">表2.1: 半加算器 (真理値表)</p>
<table>
<tr class="hline"><th>X</th><th>Y</th><th>C</th><th>S</th></tr>
<tr class="hline"><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr class="hline"><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr class="hline"><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr class="hline"><td>1</td><td>1</td><td>1</td><td>0</td></tr>
</table>
</div>
<p><b>順序回路</b>とは、入力と回路自身の状態によって一意に出力の決まる回路<a href="bib.html#bib-ronrikairo">[2]</a>です。例えば、入力が1になるたびにカウントアップして値を表示するカウンタを考えます(<span class="imgref"><a href="./03-veryl.html#downcounter">図2.2</a></span>)。カウントアップするためには、今のカウンタの値(状態)を保持する必要があります。よって、このカウンタは入力と状態によって一意に出力の決まる順序回路です。</p>
<p>1ビットの値はフリップフロップ(flip-flop, FF)という回路によって保持することができます。フロップフロップをN個並列に並べると、Nビットの値を保持することができます。フリップフロップを並列に並べた記憶装置のことを、<b>レジスタ</b>(register, 置数器)と呼びます。基本的に、レジスタの値は<b>リセット信号</b>(reset signal, reset)によって初期化し、<b>クロック信号</b>(clock signal, clock)に同期したタイミングで変更します。</p>
<div id="downcounter" class="image">
<img src="images/03-veryl/downcounter.png" alt="カウンタ (順序回路の例)" class="img" style="width:70%" />
<p class="caption">
図2.2: カウンタ (順序回路の例)
</p>
</div>
<p>論理回路を設計するには、真理値表を作成し、それを実現する論理演算を構成します。入力数や状態数が数十個ならどうにか人力で設計できるかもしれませんが、数千, 数万の入力や状態があるとき、手作業で設計するのはほとんど不可能です。これを設計するために、ハードウェア記述言語を利用します。</p>

<h3 class="none"><a id="h2-1-2"></a><span class="secno">2.1.2</span> ハードウェア記述言語</h3>
<p><b>ハードウェア記述言語</b>(Hardware Description Language, HDL)とは、デジタル回路を設計するための言語です。</p>
<p>例えばHDLであるSystemVerilogを利用すると、半加算器は<span class="listref"><a href="./03-veryl.html#halfadder.sv">リスト2.1</a></span>のように記述することができます。</p>
<div id="halfadder.sv" class="caption-code">
<span class="caption">リスト2.1: リスト2.1: SystemVerilogによる半加算器の記述</span>
<pre class="list language-sv">module HalfAdder(
  input logic x,        // 入力値X
  input logic y,        // 入力値Y
  output logic c,       // 出力値C
  output logic s        // 出力値S
);
  assign c = x &amp; y; // &amp;はAND演算
  assign s = x ^ y; // ^はXOR演算
endmodule
</pre>
</div>
<p>半加算器(HalfAdder)モジュールは、入力としてx, yを受け取り、出力c, sにx, yを使った演算を割り当てます。</p>
<p>また、レジスタを利用した回路を<span class="listref"><a href="./03-veryl.html#counter.sv">リスト2.2</a></span>のように記述することができます。レジスタの値を、リセット信号<code class="inline-code">rst</code>が<code class="inline-code">0</code>になったタイミングで<code class="inline-code">0</code>に初期化し、クロック信号<code class="inline-code">clk</code>が<code class="inline-code">1</code>になったタイミングでカウントアップします。</p>
<div id="counter.sv" class="caption-code">
<span class="caption">リスト2.2: リスト2.2: SystemVerilogによるカウンタの記述</span>
<pre class="list language-sv">module Counter(
  input logic clk, // クロック信号
  input logic rst  // リセット信号
);
  // 32ビットのレジスタの定義
  logic [31:0] count;

  always_ff @(posedge clk, negedge rst) begin
    if (!rst) begin
      // rstが0になったとき、countを0に初期化する
      count &lt;= 0;
    end else begin
      // clkが1になったとき、countの値をcount + 1にする
      count &lt;= count + 1;
    end
  end
endmodule
</pre>
</div>
<p>HDLを使用すると、論理回路の設計を、レジスタの値と入力値を使った組み合わせ回路と、その結果をレジスタに値を格納する操作の記述によって行うことができます。このような、レジスタからレジスタに、組み合わせ回路を通したデータを転送する抽象度のことを<b>レジスタ転送レベル</b>(Register Transfer Level, RTL)と呼びます。</p>
<p>HDLで記述された論理回路は、<b>合成系</b>によって、RTLから実際の回路のデータに変換(<b>合成</b>)されます。</p>

<h3 class="none"><a id="h2-1-3"></a><span class="secno">2.1.3</span> Veryl</h3>
<p>メジャーなHDLといえば、Verilog HDL, SystemVerilogなどが挙げられます<sup><a id="fnb-vhdl" href="#fn-vhdl" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-vhdl" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>VHDLが無いじゃないかと思った方、すみません。VHDLのことを私はよく知らないので無いことにしました。</p></div>
</div><!--/.footnote-list-->
<p>Verilog HDL(Verilog)は1980年代に開発された言語であり、最近のプログラミング言語と比べると機能が少なく、冗長な記述が必要です。SystemVerilogはVerilogのスーパーセットです。言語機能が増えて便利になっていますが、スーパーセットであることから、あまり推奨されない古い書き方が可能だったり、(バグの原因となるような)良くない仕様<sup><a id="fnb-nettype" href="#fn-nettype" class="noteref" epub:type="noteref">*2</a></sup>を受け継いでいます。</p>
<div class="footnote-list">
<div class="footnote" id="fn-nettype" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>例えば、未定義の変数が1ビット幅の信号線として解釈される仕様があります。ヤバすぎる</p></div>
</div><!--/.footnote-list-->
<p>本書では、CPUの実装にVerylというHDLを使用します。Verylは2022年12月に公開された言語です。Verylの抽象度は、Verilogと同じくレジスタ転送レベルです。Verylの文法や機能は、Verilog, SystemVerilogに似通ったものになっています。しかし、if式やcase式,クロックとリセットの抽象化,ジェネリクスなど、痒い所に手が届く機能が提供されており、高い生産性を発揮します。</p>
<p>Verylのソースコードは、コンパイラ(トランスパイラ)によって、自然で読みやすいSystemVerilogのソースコードに変換されます。よって、Verylは旧来のSystemVerilogの環境と共存することができ、SystemVerilogの資産を利用することができます。</p>
<div class="miniblock miniblock-caution">
<p class="miniblock-caption">注意</p>
<p>本書は2024/11/3時点のVeryl(バージョン0.13.2)について、本書で利用する範囲の文法, 機能を解説しています。Verylはまだ開発途上(正式版, 安定版がリリースされていない)状態の言語です。破壊的変更が入り、記載しているコードが使えなくなる可能性があります。</p>
<p>本書に記載しているコードの中には、バージョン0.13.2では不具合によって実行できないものがある可能性があります。不具合の回避手段についてはサポートページ<sup><a id="fnb-support" href="#fn-support" class="noteref" epub:type="noteref">*3</a></sup>をご覧ください。また、最新のVerylに対応した解説はweb版, pdf版を確認してください。</p>
</div>
<div class="footnote-list">
<div class="footnote" id="fn-support" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*3] </span>https://github.com/nananapo/veryl-riscv-book/wiki/techbookfest17-support-page</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h2-2"></a><span class="secno">2.2</span> Verylの基本文法, 機能</h2>
<p>それでは、Verylの書き方を簡単に学んでいきましょう。Verylのドキュメントは<a href="https://doc.veryl-lang.org/book/ja/" class="link">https://doc.veryl-lang.org/book/ja/</a>に存在します。また、<a href="https://doc.veryl-lang.org/playground/" class="link">Veryl Playground</a>では、VerylのSystemVerilogへのトランスパイルをウェブブラウザ上で試すことができます。</p>

<h3 class="none"><a id="h2-2-1"></a><span class="secno">2.2.1</span> コメント, 空白</h3>
<p>Verylでは次のようにコメントを記述することができます(<span class="listref"><a href="./03-veryl.html#code.comment">リスト2.3</a></span>)。</p>
<div id="code.comment" class="caption-code">
<span class="caption">リスト2.3: リスト2.3: コメント</span>
<pre class="list language-comment">  // 1行のコメント
  /* 範囲コメント */
  /*
     範囲コメントは改行してもOK
  */
</pre>
</div>

<h3 class="none"><a id="h2-2-2"></a><span class="secno">2.2.2</span> 値, リテラル</h3>
<p>論理回路では、デジタルな値を扱います。デジタルな値は<code class="inline-code">0</code>と<code class="inline-code">1</code>の二値(2-state)で表現されますが、一般的なハードウェア記述言語では、<code class="inline-code">0</code>と<code class="inline-code">1</code>に<code class="inline-code">x</code>, <code class="inline-code">z</code>を加えた四値(4-state)が利用されます(<span class="tableref"><a href="./03-veryl.html#table.fourstate">表2.2</a></span>)。</p>
<div id="table.fourstate" class="table">
<p class="caption">表2.2: 4-stateの値</p>
<table>
<tr class="hline"><th>値</th><th>意味</th><th>真偽</th></tr>
<tr class="hline"><td>0</td><td>0</td><td>偽</td></tr>
<tr class="hline"><td>1</td><td>1</td><td>真</td></tr>
<tr class="hline"><td>x</td><td>不定値</td><td>偽</td></tr>
<tr class="hline"><td>z</td><td>ハイインピーダンス</td><td>偽</td></tr>
</table>
</div>
<p><b>不定値</b>(unknown value, <code class="inline-code">x</code>)とは、0か1のどちらか分からない値です。不定値は、未初期化のレジスタの値の表現に利用されたり、不定値との演算の結果として生成されます。<b>ハイインピーダンス</b>(high-inpedance, <code class="inline-code">z</code>)とは、どのレジスタ, 信号とも接続されていないことを表す値です。物理的なハードウェア上では、全ての値は0か1の二値として解釈されます。不定値とハイインピーダンスはシミュレーションのときにのみ利用されます。</p>
<p>1ビットの四値を表現するための型は<b>logic</b>です。Nビットのlogic型は<code class="inline-code">logic&lt;N&gt;</code>と記述することができます。1ビットの二値を表現する型は<b>bit</b>です。基本的に、レジスタや信号の定義にbit型は利用せず、logic型を利用します。</p>
<p>logic, bit型は、デフォルトで符号が無い型として扱われます。符号付き型として扱いたいときは、型名の前に<b>signed</b>キーワードを追加します(<span class="listref"><a href="./03-veryl.html#code.signed_keyword">リスト2.4</a></span>)。</p>
<div id="code.signed_keyword" class="caption-code">
<span class="caption">リスト2.4: リスト2.4: 符号付き型</span>
<pre class="list language-signed_keyword">signed logic&lt;4&gt; // 4ビットの符号付きlogic型
signed bit&lt;2&gt; // 2ビットの符号付きbit型
</pre>
</div>
<p>32, 64ビットのbit型を表す型が定義されています(<span class="tableref"><a href="./03-veryl.html#ui3264">表2.3</a></span>)。</p>
<div id="ui3264" class="table">
<p class="caption">表2.3: 整数型</p>
<table>
<tr class="hline"><th>型名</th><th>等価な型</th></tr>
<tr class="hline"><td>u32</td><td>bit&lt;32&gt;</td></tr>
<tr class="hline"><td>u64</td><td>bit&lt;64&gt;</td></tr>
<tr class="hline"><td>i32</td><td>signed bit&lt;32&gt;</td></tr>
<tr class="hline"><td>i64</td><td>signed bit&lt;64&gt;</td></tr>
</table>
</div>
<p>数値は<span class="listref"><a href="./03-veryl.html#code.num_literal">リスト2.5</a></span>のように記述することができます。</p>
<div id="code.num_literal" class="caption-code">
<span class="caption">リスト2.5: リスト2.5: 数値リテラル</span>
<pre class="list language-num_literal">4'b0101 // 4ビットの数値 (2進数表記)
4'bxxzz // 4ビットの数値 (2進数表記)

12'o34xz // 12ビットの数値 (8進数表記)
32'h89abcdef // 32ビットの数値 (16進数表記)

123 // 10進数の数値
32'd12345 // 32ビットの数値 (10進数表記)

// 数値リテラルの好きな場所に_を挿入できる
1_2_34_567

// x, zは大文字でも良い
4'bxXzZ

// 全ビット0, 1, x, zにする
'0
'1
'x
'z

// 指定したビット幅だけ0, 1, x, zにする
8'0 // 8ビット0
8'1 // 8ビット1
8'x // 8ビットx
8'z // 8ビットz

// 幅を指定しない場合、幅が自動で推定される
'hffff // 16ビット
'h1fff // 13ビット
</pre>
</div>
<p>文字列は<b>string</b>型で表現することができます。文字列の値は<span class="listref"><a href="./03-veryl.html#string.literal">リスト2.6</a></span>のように記述することができます。</p>
<div id="string.literal" class="caption-code">
<span class="caption">リスト2.6: リスト2.6: 文字列リテラル</span>
<pre class="list language-literal">&quot;Hello World!&quot; // 文字列リテラル 
&quot;abcdef\nabc&quot;  // エスケープシーケンスを含む文字列リテラル
</pre>
</div>

<h3 class="none"><a id="h2-2-3"></a><span class="secno">2.2.3</span> module</h3>
<p>論理回路は<b>モジュール</b>(Module)というコンポーネントで構成されます。例えば、半加算器のモジュールは次のように定義できます(<span class="listref"><a href="./03-veryl.html#halfadder.veryl">リスト2.7</a></span>).</p>
<div id="halfadder.veryl" class="caption-code">
<span class="caption">リスト2.7: リスト2.7: 半加算器(HalfAdder)モジュール</span>
<pre class="list language-veryl">module HalfAdder (
        x: input  logic, // 1ビットのlogic型の入力
        y: input  logic, // 1ビットのlogic型の入力
        s: output logic, // 1ビットのlogic型の出力
        c: output logic, // 1ビットのlogic型の出力
) {
        assign s = x ^ y; // sにx XOR yを割り当てる
        assign c = x &amp; y; // cにx AND yを割り当てる
}
</pre>
</div>
<p>HalfAdderモジュールには、入力変数として<code class="inline-code">x</code>, <code class="inline-code">y</code>、出力変数として<code class="inline-code">s</code>. <code class="inline-code">c</code>が宣言されています。入出力の変数のことを<b>接続ポート</b>、または単に<b>ポート</b>と呼びます。</p>
<p>入力ポートを定義するとき、モジュール名の後の括弧の中に、<code class="inline-code">変数名 : input 型名</code>と記述します。出力ポートを宣言するときは<code class="inline-code">input</code>の代わりに<code class="inline-code">output</code>と記述します。複数のポートを宣言するとき、宣言の末尾にカンマ(<code class="inline-code">,</code>)を記述します。</p>

<h4><a id="h2-2-3-1"></a>変数の継続的代入, ブロッキング代入</h4>
<p>HalfAdderモジュールでは、<b>assign</b>文で出力変数<code class="inline-code">s</code>, <code class="inline-code">c</code>に値を代入しています。変数への代入は<code class="inline-code">assign 変数名 = 式;</code>で行います。</p>
<p>通常のプログラミング言語での代入とは、スタック領域やレジスタに存在する変数に値を格納することです。これに対して、assign文による代入は変数に式の結果が<b>継続的代入</b>(continuous assignment)されます。変数に式が継続的代入されると、式が評価(計算)された値が変数に1度だけ代入されるのではなく、変数の値は常に式の計算結果になります。</p>
<p>具体例で考えてみます。例えば、1ビットの変数xに1ビットの変数yをassign文で代入します(<span class="listref"><a href="./03-veryl.html#assign.wave">リスト2.8</a></span>)。</p>
<div id="assign.wave" class="caption-code">
<span class="caption">リスト2.8: リスト2.8: xにyを割り当てる</span>
<pre class="list language-wave">assign x = y;
</pre>
</div>
<p>yの値が時間経過により0, 1, 0, 1, 0と変化したとします。このとき、xの値はyが変わるのと同時に変化します(<span class="imgref"><a href="./03-veryl.html#assign_wave">図2.3</a></span>)。<span class="imgref"><a href="./03-veryl.html#assign_wave">図2.3</a></span>は、横軸が時間で、xとyの値を線の高低で表しています。<span class="imgref"><a href="./03-veryl.html#assign_wave">図2.3</a></span>のような図を<b>波形図</b>(waveform)、または単に<b>波形</b>と呼びます。</p>
<p>xにyではなくa + bを継続的代入すると、aかbの変化をトリガーにxの値が変化します。</p>
<div id="assign_wave" class="image">
<img src="images/03-veryl/assign_wave.png" alt="xはyの値の変化に追従する" class="img" style="width:60%" />
<p class="caption">
図2.3: xはyの値の変化に追従する
</p>
</div>
<p>assign文による代入の代わりに、<b>always_comb</b>ブロックでも代入することができます(<span class="listref"><a href="./03-veryl.html#always_comb.assign">リスト2.9</a></span>)。always_comb内での代入のことを、<b>ブロッキング代入</b>(blocking assignment)と呼びます。</p>
<div id="always_comb.assign" class="caption-code">
<span class="caption">リスト2.9: リスト2.9: always_combブロック内での代入</span>
<pre class="list language-assign">always_comb {
        a = b + 100;
}
</pre>
</div>
<p>assign文による代入と同じように、<span class="listref"><a href="./03-veryl.html#always_comb.assign">リスト2.9</a></span>ではbの変化をトリガーにaの値が変化します。しかし、継続的代入と違い、ブロッキング代入には、代入が完了するまで後続の文の代入をブロックするという違いがあります。</p>
<div id="always_comb.order" class="caption-code">
<span class="caption">リスト2.10: リスト2.10: ブロッキング代入は後続の文の代入をブロックする</span>
<pre class="list language-order">always_comb {
        s = 0;
        a = s; // a = 0
        s = 1;
        b = a; // b = 1
}
</pre>
</div>
<p>例えば、<code class="inline-code">always_comb.order</code>では、aには0が代入されますが、bには1が代入されます。これは、<code class="inline-code">s = 0</code>が完了するまで<code class="inline-code">a = s</code>がブロックされることでaに0が代入され、<code class="inline-code">s = 1</code>が完了するまで<code class="inline-code">b = a</code>がブロックされることでbに1が代入されるためです。最終的に、aは0, bは1, sは1になります。簡単に言ってしまうと、ブロッキング代入文は上から順番に実行されます。</p>
<p>assign文やalways_combブロック内でブロッキング代入される式は、組み合わせ回路になります。</p>

<h4><a id="h2-2-3-2"></a>変数の宣言</h4>
<p>モジュールの中では、<b>var</b>文によって新しく変数を宣言することができます(<span class="listref"><a href="./03-veryl.html#var.stmt">リスト2.11</a></span>)。</p>
<div id="var.stmt" class="caption-code">
<span class="caption">リスト2.11: リスト2.11: 変数の宣言</span>
<pre class="list language-stmt">// var 変数名 : 型名;
var value : logic&lt;32&gt;;
</pre>
</div>
<p>var文によって宣言した変数は、assign文による継続的代入, またはalways_comb内でのブロッキング代入が可能です。</p>
<p><b>let</b>文を使うと、変数の宣言と値の継続的代入を同時に行うことができます。</p>
<div id="let.stmt" class="caption-code">
<span class="caption">リスト2.12: リスト2.12: 変数の宣言と代入</span>
<pre class="list language-stmt">// let 変数名 : 型名 = 式;
let value : logic&lt;32&gt; = 100 + a;
</pre>
</div>

<h4><a id="h2-2-3-3"></a>レジスタの定義, 代入</h4>
<p>変数を宣言するとき、変数に式が継続的代入, ブロッキング代入されない場合、変数はレジスタとして解釈できます(<span class="listref"><a href="./03-veryl.html#reg.define">リスト2.13</a></span>)。</p>
<div id="reg.define" class="caption-code">
<span class="caption">リスト2.13: リスト2.13: レジスタの定義</span>
<pre class="list language-define">// var レジスタ名 : 型名;
var reg_value : logic&lt;32&gt;;

// reg_valueに継続的代入, ブロッキング代入しない
</pre>
</div>
<p>本書では、レジスタのことを変数,または変数のことをレジスタと呼ぶことがあります。</p>
<p>レジスタの値はクロック信号に同期したタイミングで変更し、リセット信号に同期したタイミングで初期化します(例:<span class="imgref"><a href="./03-veryl.html#register_wave">図2.4</a></span>)。本書では、クロック信号が<b>立ち上がる</b>(0から1に変わる)タイミングでレジスタの値を変更し、リセット信号が<b>立ち下がる</b>(1から0に変わる)タイミングでレジスタの値を初期化することとします。</p>
<div id="register_wave" class="image">
<img src="images/03-veryl/register_wave.png" alt="レジスタ(value)の値はクロック信号(clk)が立ち上がるタイミングで変わる" class="img" style="width:50%" />
<p class="caption">
図2.4: レジスタ(value)の値はクロック信号(clk)が立ち上がるタイミングで変わる
</p>
</div>
<p>レジスタの値は、<b>always_ff</b>ブロックで初期化, 変更します(<span class="listref"><a href="./03-veryl.html#always_ff.first">リスト2.14</a></span>)。always_ffブロックにはクロック信号名とリセット信号名を指定します。</p>
<div id="always_ff.first" class="caption-code">
<span class="caption">リスト2.14: リスト2.14: レジスタの値の初期化と変更</span>
<pre class="list language-first">// レジスタの定義
var value : logic&lt;32&gt;;

// always_ff(クロック信号名, リセット信号名)
always_ff(clk, rst) {
        if_reset {
                // リセット信号のタイミングで0に初期化する
                value = 0;
        } else {
                // クロック信号のタイミングでカウントアップする
                value = value + 1;
        }
}
</pre>
</div>
<p>クロック信号はclock型, リセット信号はreset型で定義します。モジュールのポートに１組のクロック信号とリセット信号が定義されているとき、always_ffブロックのクロック信号とリセット信号の指定を省略できます(<span class="listref"><a href="./03-veryl.html#always_ff.omit">リスト2.15</a></span>)。</p>
<div id="always_ff.omit" class="caption-code">
<span class="caption">リスト2.15: リスト2.15: クロック信号とリセット信号の推論</span>
<pre class="list language-omit">module ModuleA(
  clk: input clock,
  rst: input reset,
){
        // always_ff(clk, rst)と等しい
        always_ff {}
}
</pre>
</div>
<p>1つのalways_ffブロックで、複数のレジスタの値を変更することができます。always_ffブロックの中で複数のレジスタの値を変更する時、全ての代入は同時に行われます。この代入は後続の文の代入をブロックしないため、ブロッキング代入の対として<b>ノンブロッキング代入</b>(non-blocking assignment)と呼びます。</p>
<div id="always_ff.nonblocking" class="caption-code">
<span class="caption">リスト2.16: リスト2.16: ノンブロッキング代入のタイミングは同じ</span>
<pre class="list language-nonblocking">always_ff {
        if_reset {
                ...
        } else {
                // 2つの代入文が同時に実行される。
                // その結果、AとBの値が入れ替わる
                A = B;
                B = A;
        }
}
</pre>
</div>
<p>2つ以上のalways_ffブロックで、1つの同じレジスタの値を変更することはできません。</p>
<p>本書では、継続的代入, ブロッキング代入, ノンブロッキング代入を区別せず、どれも代入と呼ぶことがあります。</p>
<p>変数への代入方法と動作を<span class="tableref"><a href="./03-veryl.html#table.assign">表2.4</a></span>にまとめます。大変間違えやすいため、気を付けてください。</p>
<div id="table.assign" class="table">
<p class="caption">表2.4: 変数への代入方法と動作</p>
<table>
<tr class="hline"><th>代入方法</th><th>例</th><th>値の更新タイミング</th></tr>
<tr class="hline"><td>継続的代入</td><td>assign文<br />let文</td><td>式に使用されている変数が更新されたとき</td></tr>
<tr class="hline"><td>ブロッキング代入</td><td>always_comb<br />内の代入</td><td>always_combブロック内の式に使用されている変数が更新<br />されたとき。後続の文の代入をブロックすることに注意</td></tr>
<tr class="hline"><td>ノンブロッキング代入</td><td>always_ff<br />内の代入</td><td>クロック信号, またはリセット信号のタイミング。<br />全てのノンブロッキング代入は同時に代入されることに注意</td></tr>
</table>
</div>

<h4><a id="h2-2-3-4"></a>モジュールのインスタンス化</h4>
<p>あるモジュールを利用したいとき、モジュールを<b>インスタンス化</b>(instantiate)することにより、モジュールのインスタンスを宣言することができます。</p>
<p>モジュールは、<b>inst</b>キーワードによってインスタンス化することができます(<span class="listref"><a href="./03-veryl.html#module.inst">リスト2.17</a></span>)。</p>
<div id="module.inst" class="caption-code">
<span class="caption">リスト2.17: リスト2.17: ModuleAモジュール内でHalfAdderモジュールをインスタンス化する</span>
<pre class="list language-inst">module ModuleA{
        // モジュールと接続するための変数の宣言
        let x : logic = 0;
        let y : logic = 1;
        var s : logic;
        var c : logic;

        // inst インスタンス名 : モジュール名(ポートとの接続);
        inst ha1 : HalfAdder(
                x: x, // ポートxに変数xを接続する
                y: y,
                s,    // ポート名と変数名が同じとき、ポート名の指定を省略できる 
                c,
        );
}
</pre>
</div>
<p>インスタンス名が違えば、同一のモジュールを2つ以上インスタンス化することができます。</p>

<h4><a id="h2-2-3-5"></a>パラメータ, 定数</h4>
<p>モジュールには変更可能な値(<b>パラメータ</b>)を用意することができ、モジュールをインスタンス化するときにパラメータの値を指定することができます。</p>
<p>モジュールのパラメータは、ポート宣言の前の<code class="inline-code">#()</code>の中で<b>param</b>キーワードによって宣言することができます(<span class="listref"><a href="./03-veryl.html#module.param.define">リスト2.18</a></span>)。</p>
<div id="module.param.define" class="caption-code">
<span class="caption">リスト2.18: リスト2.18: モジュールのパラメータの宣言</span>
<pre class="list language-define">module ModuleA #(
        // param パラメータ名 : 型名 = デフォルト値 
        param WIDTH : u32 = 100, // u32型のパラメータ
        param DATA_TYPE : type = logic, // type型のパラメータには型を指定できる
) (
        // ポートの宣言
) {}
</pre>
</div>
<p>モジュールをインスタンス化するとき、ポートの割り当てと同じようにパラメータの値を割り当てることができます(<span class="listref"><a href="./03-veryl.html#module.param.inst">リスト2.19</a></span>)。</p>
<div id="module.param.inst" class="caption-code">
<span class="caption">リスト2.19: リスト2.19: パラメータの値を指定する</span>
<pre class="list language-inst">inst ma : ModuleA #(
        // パラメータの割り当て
        WIDTH: 10,
        DATA_TYPE: logic&lt;10&gt;
) (
        // ポートの接続
);
</pre>
</div>
<p>パラメータに指定する値は、合成時に確定する値(定数)である必要があります。</p>
<p>モジュール内では、変更不可能なパラメータ(定数)を定義することができます。定数を定義するには<b>const</b>キーワードを使用します(<span class="listref"><a href="./03-veryl.html#const.use">リスト2.20</a></span>)。</p>
<div id="const.use" class="caption-code">
<span class="caption">リスト2.20: リスト2.20: 定数の定義</span>
<pre class="list language-use">// const 定数名 : 型名 = 式;
// 式に変数が含まれてはいけない
const SECRET : u32 = 42;
</pre>
</div>

<h3 class="none"><a id="h2-2-4"></a><span class="secno">2.2.4</span> ユーザー定義型</h3>

<h4><a id="h2-2-4-1"></a>構造体型</h4>
<p>構造体(struct)とは、複数のデータから構成される型です。例えば、<span class="listref"><a href="./03-veryl.html#struct.define">リスト2.21</a></span>のように記述すると、logic&lt;32&gt;とlogic&lt;16&gt;の2つのデータから構成される型を定義することができます。</p>
<div id="struct.define" class="caption-code">
<span class="caption">リスト2.21: リスト2.21: 構造体型の定義</span>
<pre class="list language-define">// struct 型名 { フィールドの定義 }
struct MyPair {
        // 名前 : 型
        word: logic&lt;32&gt;,
        half: logic&lt;16&gt;,
}
</pre>
</div>
<p>構造体の要素(フィールド, field)には、<code class="inline-code">.</code>を介してアクセスすることができます(<span class="listref"><a href="./03-veryl.html#struct.field.access">リスト2.22</a></span>)。</p>
<div id="struct.field.access" class="caption-code">
<span class="caption">リスト2.22: リスト2.22: フィールドへのアクセス, 割り当て</span>
<pre class="list language-access">// 構造体型の変数の宣言
var pair: MyPair;

// フィールドにアクセスする
let w : logic&lt;32&gt; = pair.word;

// フィールドに値を割り当てる
always_comb {
        pair.word = 12345;
}
</pre>
</div>

<h4><a id="h2-2-4-2"></a>列挙型</h4>
<p>複数の値の候補から値を選択できる型を作りたいとき、<b>列挙型</b>(enumerable type)を利用することができます。列挙型の値の候補名のことを<b>バリアント</b>(variant)と呼びます。</p>
<p>例えば、A, B, C, Dのいずれかのバリアントをとる型は次のように定義できます(<span class="listref"><a href="./03-veryl.html#enum.define">リスト2.23</a></span>)。</p>
<div id="enum.define" class="caption-code">
<span class="caption">リスト2.23: リスト2.23: 列挙型の定義</span>
<pre class="list language-define">// enum 型名 : logic&lt;バリアント数を保持できるだけのビット数&gt; { バリアントの定義 }
enum abc : logic&lt;2&gt; {
        // バリアント名 : バリアントを表す値,
        A = 2'd0,
        B = 2'd1,
        C = 2'd2,
        D = 2'd3
}
</pre>
</div>
<p>バリアントを表す値や、バリアントを保持できるだけのビット数は省略することができます(<span class="listref"><a href="./03-veryl.html#enum.omit">リスト2.24</a></span>)。省略された値は自動で推定されます。</p>
<div id="enum.omit" class="caption-code">
<span class="caption">リスト2.24: リスト2.24: 列挙型の省略した定義</span>
<pre class="list language-omit">enum abc {
        A, B, C, D
}
</pre>
</div>

<h4><a id="h2-2-4-3"></a>配列</h4>
<p><code class="inline-code">&lt;&gt;</code>を使用することで、多次元の型を定義することができます(<span class="listref"><a href="./03-veryl.html#logic.md">リスト2.25</a></span>)。</p>
<div id="logic.md" class="caption-code">
<span class="caption">リスト2.25: リスト2.25: 多次元の型</span>
<pre class="list language-md">logic        // 1ビットのlogic
logic&lt;N&gt;     // Nビットのlogic
logic&lt;A, B&gt;  // A * Bの2次元のlogic
</pre>
</div>
<p><code class="inline-code">[]</code>を使用することで、配列を定義することができます(<span class="listref"><a href="./03-veryl.html#array.define">リスト2.26</a></span>)。</p>
<div id="array.define" class="caption-code">
<span class="caption">リスト2.26: リスト2.26: 配列型</span>
<pre class="list language-define">// 型名[個数] で、&quot;型名&quot;型が&quot;個数&quot;個の配列型になる
logic[32]     // 32個のlogicが並ぶ型
logic[4, 8]   // logicが8個並ぶ配列が4個並ぶ配列型
</pre>
</div>

<h4><a id="h2-2-4-4"></a>型に別名をつける</h4>
<p><b>type</b>キーワードを使うと、型に別名を付けることができます(type.define)。</p>
<div id="type.define" class="caption-code">
<span class="caption">リスト2.27: リスト2.27: 型に別名を付ける</span>
<pre class="list language-define">// type 名前 = 型;
type ptr        = logic&lt;32&gt;;
type ptr_array  = ptr&lt;32&gt;
</pre>
</div>

<h3 class="none"><a id="h2-2-5"></a><span class="secno">2.2.5</span> 式, 文, 宣言</h3>

<h4><a id="h2-2-5-1"></a>ビット選択</h4>
<div id="bitsel" class="image">
<img src="images/03-veryl/bitsel.png" alt="ビット選択" class="img" style="width:50%" />
<p class="caption">
図2.5: ビット選択
</p>
</div>
<p>変数の任意のビットを切り出すには<code class="inline-code">[]</code>を使用します(<span class="imgref"><a href="./03-veryl.html#bitsel">図2.5</a></span>)。範囲の選択には<code class="inline-code">[:]</code>を使用します。最上位ビット(most significant bit)は<b>msb</b>キーワード,最下位ビット(least significant bit)は<b>lsb</b>キーワードで指定することができます。選択する場所の指定には式を使うことができます。</p>
<p>よく使われる範囲の選択には、別の書き方が用意されています(<span class="listref"><a href="./03-veryl.html#bitsel.range_sel">リスト2.28</a></span>)。</p>
<div id="bitsel.range_sel" class="caption-code">
<span class="caption">リスト2.28: リスト2.28: 範囲の選択</span>
<pre class="list language-range_sel">v[s +: w]   // = v[s+w-1   : s    ]
v[s -: w]   // = v[s       : s-w+1]
v[i step w] // = v[i*(w+1) : i*w  ] = v[i*w +: w]
</pre>
</div>

<h4><a id="h2-2-5-2"></a>演算子</h4>
<p>Verylでは、次の演算子を使用することができます(<span class="tableref"><a href="./03-veryl.html#operator.priority">表2.5</a></span>)。</p>
<div id="operator.priority" class="table">
<p class="caption">表2.5: 演算子と優先度 <a href="bib.html#bib-veryl-doc.operator.precedence">[3]</a></p>
<table>
<tr class="hline"><th>演算子</th><th>結合法則</th><th>優先度</th></tr>
<tr class="hline"><td><code class="inline-code">()  []  ::  .</code></td><td>左</td><td>最優先</td></tr>
<tr class="hline"><td><code class="inline-code">+  -  !  ~  &amp;  ~&amp;  |  ~|  ^  ~^  ^~</code>(単項)</td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">**</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">*  /  %</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">+  -</code> (二項)</td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">&lt;&lt;  &gt;&gt;  &lt;&lt;&lt;  &gt;&gt;&gt;</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">&lt;:  &lt;=  &gt;:  &gt;=</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">==  !=  ===  !==  ==?  !=?</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">&amp;</code> (二項)</td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">^  ~^  ^~</code> (二項)</td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">|</code> (二項)</td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">&amp;&amp;</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">||</code></td><td>左</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">=  +=  -=  *=  /=  %=  &amp;=  ^=  |=  &lt;&lt;=  &gt;&gt;=  &lt;&lt;&lt;=  &gt;&gt;&gt;=</code></td><td>なし</td><td></td></tr>
<tr class="hline"><td><code class="inline-code">{} inside outside if case switch</code></td><td>なし</td><td>最後</td></tr>
</table>
</div>
<p>SystemVerilogを知っている方にSystemVerilogとの差異を説明すると、<code class="inline-code">++</code>,<code class="inline-code">--</code>,<code class="inline-code">:=</code>,<code class="inline-code">:/</code>,<code class="inline-code">&lt;=</code>(代入)が無く、<code class="inline-code">&lt;=</code>,<code class="inline-code">&gt;=</code>がそれぞれ<code class="inline-code">&lt;:</code>,<code class="inline-code">&gt;:</code>に変更されています。また、<code class="inline-code">inside</code>と<code class="inline-code">{{}}</code>の形式が変更され、<code class="inline-code">if</code>, <code class="inline-code">case</code>, <code class="inline-code">switch</code>式が追加されています。</p>
<p>単項, 二項演算子の使用例は次の通りです(<span class="listref"><a href="./03-veryl.html#operator.use">リスト2.29</a></span>)。</p>
<div id="operator.use" class="caption-code">
<span class="caption">リスト2.29: リスト2.29: 単項, 二項演算子 (Verylのドキュメント&lt;a href=&quot;bib.html#bib-veryl-doc.operators&quot;&gt;[4]&lt;/a&gt;の例を改変)</span>
<pre class="list language-use">// 単項算術演算
a = +1;
a = -1; // 正負を反転させる

// 単項論理演算
a = !1; // 否定 (真偽を反転させる)
a = ~1; // ビット反転 (0を1, 1を0にする)

// 単項集約演算
// 集約: 左のビットから順にビット演算する
//   例: k=3'b110のとき、&amp;k = 0
//   まず、k[msb]とk[1]をANDして1を得る。
//   次に、その結果とk[0]をANDして0を得る。
//   この値が&amp;kの結果になる。
a = &amp;1;  // AND
a = |1;  // OR
a = ^1;  // XOR
a = ~&amp;1; // NAND
a = ~|1; // NOR
a = ~^1; // XNOR
a = ^~1; // XNOR

// 二項算術演算
a = k ** p; // kのp乗
a = 1 * 1;  // かけ算
a = 1 / 1;  // 割り算
a = 1 % 1;  // 剰余
a = 1 + 1;  // 足し算
a = 1 - 1;  // 引き算

// シフト演算
// 注意 : 右オペランド(シフト数)は符号無しの数として扱われる
a = k &lt;&lt;  n; // kをnビット左シフトする。空いたビットは0で埋める
a = k &lt;&lt;&lt; n; // &lt;&lt;と同じ
a = k &gt;&gt;  n; // kをnビット右シフトする。空いたビットは0で埋める
a = k &gt;&gt;&gt; n; // kが符号無しのとき&gt;&gt;と同じ。符号付きのとき、空いたビットはmsbで埋める

// 比較演算
a = n &lt;: m;  // nはm未満
a = n &lt;= m;  // nはm以下
a = n &gt;: m;  // nはmよりも大きい (mを含まない)
a = n &gt;= m;  // nはm以上 (mを含む)
a = n == m;  // nはmと等しい (x, zを含む場合、x)
a = n != m;  // nはmと等しくない (x, zを含む場合、x)
a = n === m; // nはmと等しい (x, zを含めて完全に一致)
a = n !== m; // nはmと等しくない (x, zを含めて完全に一致)
a = n ==? m; // ===と同じ。ただし、mに含まれるx,zはワイルドカードになる
a = n !=? m; // !(==?)と同じ

// ビット演算 (ビット単位, bitwise)
a = 1 &amp; 1;  // ビット単位AND
a = 1 ^ 1;  // ビット単位XOR
a = 1 ~^ 1; // ビット単位XNOR
a = 1 ^~ 1; // ビット単位XNOR
a = 1 | 1;  // ビット単位OR

// 二項論理演算
a = x &amp;&amp; y; // xとyの両方が真のとき真
a = x || y; // xまたはyが真のとき真
</pre>
</div>

<h4><a id="h2-2-5-3"></a>if, switch, case</h4>
<p>条件によって動作や値を変えたいとき、<b>if</b>文を使用します (<span class="listref"><a href="./03-veryl.html#if.only">リスト2.30</a></span>)。if文は式にすることができます。if式は必ず値を返す必要があり、elseが必須です。</p>
<div id="if.only" class="caption-code">
<span class="caption">リスト2.30: リスト2.30: if文, if式</span>
<pre class="list language-only">var v1 : logic&lt;32&gt;;
always_comb {
        if WIDTH == 0 {
                // WIDTH == 0のとき
                v1 = 0;
        } else if WIDTH == 1 {
                // WIDTH != 0かつWIDTH == 1のとき
                v1 = 1;
        } else {
                // WIDTH != 0かつWIDTH != 1のとき
                v1 = if WIDTH == 3 { // ifは式にもなる
                        3
                } else {
                        // if式はelseが必須
                        4
                };
        }
}
</pre>
</div>
<p>always_combブロックで変数に継続的代入するとき、if文の全ての場合で継続的代入する必要があることに注意してください(<code class="inline-code">v1</code>は常に代入されています)。</p>
<p><span class="listref"><a href="./03-veryl.html#if.only">リスト2.30</a></span>と同じ意味の文を<b>switch</b>文で書くことができます(<span class="listref"><a href="./03-veryl.html#switch.only">リスト2.31</a></span>)。どの条件にも当てはまらないときの動作は<b>default</b>で指定します。switchは式にすることができます。switch式はは必ず値を返す必要があり、defaultが必須です。</p>
<div id="switch.only" class="caption-code">
<span class="caption">リスト2.31: リスト2.31: switch文, switch式</span>
<pre class="list language-only">var v1: logic&lt;32&gt;;
always_comb {
        switch {
                // WIDTH == 0のとき
                WIDTH == 0: {
                        v1 = 0;
                }
                // WIDTH != 0かつWIDTH == 1のとき
                WIDTH == 1: v1 = 1; // 要素が1つの文の時、{}は省略できる
                // WIDTH != 0かつWIDTH != 1のとき
                default: 
                        // switch式
                        v1 = switch {
                                WIDTH == 3: 3, // カンマで区切る
                                default : 4, // switch式はdefaultが必須
                        };
        }
}
</pre>
</div>
<p><span class="listref"><a href="./03-veryl.html#if.only">リスト2.30</a></span>のように1つの要素(<code class="inline-code">WIDTH</code>)の一致のみが条件のとき、同じ意味の文を<b>case</b>文で書くことができます(<span class="listref"><a href="./03-veryl.html#case.only">リスト2.32</a></span>)。式にできたり、式にdefaultが必須なのはswitch文と同様です。</p>
<div id="case.only" class="caption-code">
<span class="caption">リスト2.32: リスト2.32: case文, case式</span>
<pre class="list language-only">var v1: logic&lt;32&gt;;
always_comb {
        case WIDTH {
                // WIDTH == 0のとき
                0: {
                        v1 = 0;
                }
                // WIDTH != 0かつWIDTH == 1のとき
                1: v1 = 1; // 要素が1つの文の時、{}は省略できる
                // WIDTH != 0かつWIDTH != 1のとき
                default: 
                        // case式
                        v1 = case WIDTH {
                                3: 3, // カンマで区切る
                                default : 4, // case式はdefaultが必須
                        };
        }
}
</pre>
</div>

<h4><a id="h2-2-5-4"></a>連結, repeat</h4>
<p>ビット列や文字列を連結したいときは<code class="inline-code">{}</code>を使用することができます(<span class="listref"><a href="./03-veryl.html#renketu">リスト2.33</a></span>)。<code class="inline-code">+</code>では連結できない(値の足し算になる)ことに注意してください。同じビット列, 文字列を繰り返して連結したいときは<b>repeat</b>キーワードを使用します(<span class="listref"><a href="./03-veryl.html#repeat">リスト2.34</a></span>)。</p>
<div id="renketu" class="caption-code">
<span class="caption">リスト2.33: リスト2.33: 連結</span>
<pre class="list">{12'h123, 32'habcd0123} // 44'h123_abcde0123になる
{&quot;Hello&quot;, &quot; &quot;, &quot;World!&quot;} // &quot;Hello World!&quot;になる
</pre>
</div>
<div id="repeat" class="caption-code">
<span class="caption">リスト2.34: リスト2.34: repeatを使って連結を繰り返す</span>
<pre class="list">// {繰り返したい要素 repeat 繰り返す回数}
{4'0011 repeat 3, 4'b1111} // 16'b0011_0011_0011_1111になる
{&quot;Happy&quot; repeat 3} // &quot;HappyHappyHappy&quot;になる
</pre>
</div>

<h4><a id="h2-2-5-5"></a>文の生成 (if, for)</h4>
<p>if文はalways_ff, always_comb等のブロックの外にも書くことができます(<span class="listref"><a href="./03-veryl.html#generate.if">リスト2.35</a></span>)。このとき、条件式は定数しか使用できません。if文, else if, else文には<code class="inline-code">: ラベル名</code>で名前を付ける必要があります。</p>
<div id="generate.if" class="caption-code">
<span class="caption">リスト2.35: リスト2.35: if文による文の生成</span>
<pre class="list language-if">module ModuleA #(
        param WIDTH : u32 = 0
) (
        value : output logic&lt;32&gt;
) {
        if WIDTH == 0 : width_is_zero {
                assign value = 1;
        } else if WIDTH == 1 : width_is_one {
                assign value = 2;
        } else { // else文のラベルは省略できる
                assign value = 'x;
        }
}
</pre>
</div>
<p>同じ文をなんども繰り返し記述したいとき、<b>for</b>文を活用することができます(<span class="listref"><a href="./03-veryl.html#generate.for">リスト2.36</a></span>)。if文と同様に、for文にもラベルを付ける必要があります。</p>
<p>for文はalways_ff, always_comb等のブロックの中にも書くことができます。その場合、ラベルは不要で、ループ変数に型を付ける必要があります。また、<b>break</b>文によってループを中断することができます。</p>
<div id="generate.for" class="caption-code">
<span class="caption">リスト2.36: リスト2.36: for文による文の生成</span>
<pre class="list language-for">module ModuleA (
        value : output logic&lt;32&gt;
) {
        // in 0..32で、0から31の区間をループする
        // in 0..=31で同じ区間を指定できる
        for i in 0..32 : value_assignment {
                assign value[i] = i % 2;
        }

        var value2 : logic&lt;32&gt;;
        always_comb {
                // ループ変数に型を指定する必要がある
                for i :u32 in  0..=63 {
                        value2[i] = i % 2;
                        if i == 31 {
                                break;
                        }
                }
        }
}
</pre>
</div>

<h4><a id="h2-2-5-6"></a>inside, outside</h4>
<p>値がある範囲に含まれているかという条件を記述したいとき、<b>inside</b>式を利用することができます。<code class="inline-code">inside 式 {範囲}</code>で、式の結果が範囲内にあるかという条件を記述できます(<span class="listref"><a href="./03-veryl.html#inside-outside">リスト2.37</a></span>)。逆に、範囲外にあるという条件は<b>outside</b>式で記述できます。</p>
<div id="inside-outside" class="caption-code">
<span class="caption">リスト2.37: リスト2.37: inside, outside</span>
<pre class="list">inside n {0..10}    // nが0以上10未満のとき1
inside n {0..=10}   // nが0以上10以下のとき1
inside n {0, 1, 3}  // nが0,1,3のいずれかのとき1
inside n {0, 2..10} // nが0、または2以上10未満のとき1

// outsideはinsideの逆
outside n {0..10}   // nが0未満、または10より大きいとき1
outside n {0, 1, 3} // nが0,1,3以外の値のとき1
</pre>
</div>

<h4><a id="h2-2-5-7"></a>function</h4>
<p>何度も記述する操作, 計算は、関数(<b>function</b>)を使うことでまとめて記述することができます(<span class="listref"><a href="./03-veryl.html#function.first">リスト2.38</a></span>)。関数は値を引数で受け取り、<b>return</b>文で値を返します。値を返さないとき、戻り値の型の指定を省略できます。</p>
<p>引数には向きを指定できます。functionの実行を開始するとき、inputとして指定されている実引数の値が仮引数にコピーされます。functionの実行が終了するとき、outputとして指定されている仮引数の値が実引数の変数にコピーされます。</p>
<div id="function.first" class="caption-code">
<span class="caption">リスト2.38: リスト2.38: 関数</span>
<pre class="list language-first">// べき乗を返す関数
function get_power(
        a : input u32,
        b : input u32,
) -&gt; u32 {
        return a ** b;
}

val v1 : logic&lt;32&gt;;
val v2 : logic&lt;32&gt;;

always_comb {
        v1 = get_power(2, 10); // v1 = 1024
        v2 = get_power(3, 3); // v2 = 27
}


// a + 1をbに代入する関数
function assign_plus1(
        a : input  logic&lt;32&gt;,
        b : output logic&lt;32&gt;,
) { // 戻り値はないので省略
        b = a + 1;
}

val v3 : logic&lt;32&gt;;

always_comb {
        assign_plus1(v1, v3); // v3 = v1 + 1
}
</pre>
</div>

<h3 class="none"><a id="h2-2-6"></a><span class="secno">2.2.6</span> interface</h3>
<p>モジュールに何個もポートが存在するとき、ポートの接続は非常に手間のかかる作業になります(<span class="listref"><a href="./03-veryl.html#interface.motivate">リスト2.39</a></span>)。</p>
<div id="interface.motivate" class="caption-code">
<span class="caption">リスト2.39: リスト2.39: モジュールのポートの相互接続</span>
<pre class="list language-motivate">module ModuleA (
        req_a: output logic,
        req_b: output logic,
        req_c: output logic,
){}
module ModuleB (
        resp_a: input logic,
        resp_b: input logic,
        resp_c: input logic,
){}
module Top{
        var a: logic;
        var b: logic;
        var c: logic;
        inst ma : ModuleA (
                req_a:a,
                req_b:b,
                req_c:c,
        );
        inst mb : ModuleB (
                resp_a:a,
                resp_b:b,
                resp_c:c,
        );
}
</pre>
</div>
<p>モジュール間のポートの接続を簡単に行うために、インターフェース(<b>interface</b>)という機能が用意されています。<span class="listref"><a href="./03-veryl.html#interface.motivate">リスト2.39</a></span>のModuleAとModuleBを相互接続するようなインターフェースは次のように定義することができます(<span class="listref"><a href="./03-veryl.html#interface.example">リスト2.40</a></span>)。</p>
<div id="interface.example" class="caption-code">
<span class="caption">リスト2.40: リスト2.40: インターフェースの定義</span>
<pre class="list language-example">// interface インターフェース名 { }
interface iff_ab {
        var a : logic;
        var b : logic;
        var c : logic;

        modport req {
                a: input,
                b: input,
                c: input,
        }
        modport resp {
                a: output,
                b: output,
                c: output,
        }
}
</pre>
</div>
<p><code class="inline-code">iff_ab</code>を利用すると、<span class="listref"><a href="./03-veryl.html#interface.motivate">リスト2.39</a></span>を次のように簡潔に記述することができます(<span class="listref"><a href="./03-veryl.html#interface.good">リスト2.41</a></span>)。</p>
<div id="interface.good" class="caption-code">
<span class="caption">リスト2.41: リスト2.41: インターフェースによる接続</span>
<pre class="list language-good">module ModuleA (
        req : modport iff_ab::req,
){}
module ModuleB (
        resp : modport iff_ab::resp,
){}
module Top{
        // インターフェースのインスタンス化
        inst iab : iff_ab;
        inst ma : ModuleA (req: iab);
        inst mb : ModuleB (resp: iab);
}
</pre>
</div>
<p>インターフェースはポートの宣言と接続を抽象化します。インターフェース内に変数を定義すると、<b>modport</b>文によってポートと向きを宣言することができます。モジュールでのポートの宣言は、<code class="inline-code">ポート名 : modport インターフェース名::modport名</code>という風に記述することができます。modportで宣言されたポートにインターフェースのインスタンスを渡すことにより、ポートの接続を一気に行うことができます。</p>
<p>モジュールと同じようにパラメータを宣言することができます(<span class="listref"><a href="./03-veryl.html#interface.param">リスト2.42</a></span>)。</p>
<div id="interface.param" class="caption-code">
<span class="caption">リスト2.42: リスト2.42: インターフェースの定義</span>
<pre class="list language-param">// interface インターフェース名 #( パラメータの定義 ) { }
interface iff_params # (
        param PARAM_A : u32 = 100,
        param PARAM_B : u64 = 200,
){ }
</pre>
</div>
<p>インターフェース内には、関数の定義やassign, always_comb, always_ffなどの文を記述することができます。</p>

<h3 class="none"><a id="h2-2-7"></a><span class="secno">2.2.7</span> package</h3>
<p>複数のモジュールやインターフェースにまたがって使用したいパラメータや型, 関数はパッケージ(package)に定義することができます(<span class="listref"><a href="./03-veryl.html#package.define">リスト2.43</a></span>)。</p>
<div id="package.define" class="caption-code">
<span class="caption">リスト2.43: リスト2.43: パッケージの定義</span>
<pre class="list language-define">package PackageA {
        const WIDTH : u32 = 1234;
        type foo = logic&lt;WIDTH&gt;;
        function bar () -&gt; u32 {
                return 1234;
        }
}
</pre>
</div>
<p>パッケージに定義した要素には、<code class="inline-code">パッケージ名::要素名</code>でアクセスすることができます(<span class="listref"><a href="./03-veryl.html#package.access">リスト2.44</a></span>)。</p>
<div id="package.access" class="caption-code">
<span class="caption">リスト2.44: リスト2.44: パッケージの要素にアクセスする</span>
<pre class="list language-access">module ModuleA {
        const W : u32 = PackageA::WIDTH;
        var value1 : PackageA::foo;
        let value2 : u32 = PackageA::bar();
}
</pre>
</div>
<p><b>import</b>文を使用すると、パッケージ名の指定を省略することができます(<span class="listref"><a href="./03-veryl.html#package.import">リスト2.45</a></span>)。</p>
<div id="package.import" class="caption-code">
<span class="caption">リスト2.45: リスト2.45: パッケージをimportする</span>
<pre class="list language-import">import PackageA::WIDTH; // 特定の要素をimportする
import PackageA::*; // 全ての要素をimportする
</pre>
</div>

<h3 class="none"><a id="h2-2-8"></a><span class="secno">2.2.8</span> ジェネリクス</h3>
<p>関数, モジュール, インターフェース, パッケージ, 構造体は、<b>ジェネリクス</b>(generics)によってパラメータ化することができます。</p>
<p>例えば、要素に任意の型TやWビットのデータを持つ構造体は、次のように<b>ジェネリックパラメータ</b>(generic parameter)を使うことで定義できます(<span class="listref"><a href="./03-veryl.html#generics.sample">リスト2.46</a></span>)。ジェネリックパラメータに渡される値は、ジェネリクスの定義位置からアクセスすることができる定数である必要があります。</p>
<div id="generics.sample" class="caption-code">
<span class="caption">リスト2.46: リスト2.46: パラメータ化された構造体</span>
<pre class="list language-sample">module ModuleA {
        // ::&lt;&gt;でジェネリックパラメータを定義する
        // constで数値を受け取る
        struct StructA::&lt;W: const&gt; {
            A: logic&lt;W&gt;,
        }

        // 複数のジェネリックパラメータを定義できる
        // typeで型を受け取る
        // デフォルト値を設定できる
        struct StructB::&lt;W: const, T: type, D:const = 100&gt; {
                A: logic&lt;W&gt;,
                B: T,
                C: logic&lt;D&gt;
        }

        // ::&lt;&gt;でジェネリックパラメータを指定する
        type A = StructA::&lt;16&gt;;
        type B = StructB::&lt;17, A&gt;;
        type C = StructB::&lt;18, B, 19&gt;;
}
</pre>
</div>

<h3 class="none"><a id="h2-2-9"></a><span class="secno">2.2.9</span> その他の機能, 文</h3>

<h4><a id="h2-2-9-1"></a>initial, final</h4>
<p><b>initial</b>ブロックの中の文は、シミュレーションの開始時に実行されます。<b>final</b>ブロックの中の文は、シミュレーションの終了時に実行されます。</p>
<div id="initial.final" class="caption-code">
<span class="caption">リスト2.47: リスト2.47: initial, finalブロック</span>
<pre class="list language-final">module ModuleA {
        initial {
                // シミュレーション開始時に実行される
        }
        final {
                // シミュレーション終了時に実行される
        }
}
</pre>
</div>

<h4><a id="h2-2-9-2"></a>SystemVerilogとの連携</h4>
<p>VerylはSystemVerilogのモジュールやパッケージ, インターフェースを利用することができます。SystemVerilogのリソースにアクセスするには<b>$sv::</b>を使用します。</p>
<div id="sv.use" class="caption-code">
<span class="caption">リスト2.48: リスト2.48: SystemVerilogの要素を利用する</span>
<pre class="list language-use">module ModuleA {
        // SystemVerilogでsvpackageとして
        // 定義されているパッケージを利用する
        let x = $sv::svpackage::X;
        let y = $sv::svpackage::Y;

        var s: logic;
        var c: logic;

        // SystemVerilogでHalfAdderとして
        // 定義されているモジュールをインスタンス化する
        inst ha : $sv::HalfAdder(
                x, y, s, c
        );

        // SystemVerilogでsvinterfaceとして
        // 定義されているインターフェースをインスタンス化する
        inst c: $sv::svinterface;
}
</pre>
</div>
<p>SystemVerilogのソースコードを直接埋め込み、含めることができます(<span class="listref"><a href="./03-veryl.html#sv.integrate">リスト2.49</a></span>)。</p>
<div id="sv.integrate" class="caption-code">
<span class="caption">リスト2.49: リスト2.49: SystemVerilog記述を埋め込む</span>
<pre class="list language-integrate">// SystemVerilog記述を直接埋め込む
embed (inline) sv{{{
        module ModuleA(
                output logic a
        );
                assign a = 0;
        endmodule
}}}

// SystemVerilogのソースファイルを展開する
// パスは相対パス
include(inline, &quot;filename.sv&quot;);
</pre>
</div>

<h4><a id="h2-2-9-3"></a>システム関数 / システムタスク</h4>
<p>SystemVerilogに標準で用意されている関数(システム関数, システムタスク)を利用することができます。システム関数(system function), システムタスク(system task)の名前は、<code class="inline-code">$</code>から始まります。本書で利用するシステム関数, システムタスクを<span class="tableref"><a href="./03-veryl.html#systemtasks">表2.6</a></span>に列挙します。それぞれの使用例は次の通りです(<span class="listref"><a href="./03-veryl.html#systemtask.use">リスト2.50</a></span>)。</p>
<p>システム関数, システムタスクを利用するときは、通常の関数呼び出しのように使用します。</p>
<div id="systemtask.use" class="caption-code">
<span class="caption">リスト2.50: リスト2.50: システム関数, システムタスクの使用例</span>
<pre class="list language-use">const w1 : u32 = $clog2(32); // 5
const w2 : u32 = $clog2(35); // 6

var array : logic&lt;4,8&gt;;
const s1 : u32 = $size(array); // 4
const s2 : u32 = $bits(array); // 32

var uvalue : u32;
let svalue : i32 = $signed(uvalue) + 1;

initial {
        $readmemh(&quot;file.hex&quot;, array);
        $display(&quot;Hello World!&quot;);
        $error(&quot;Error!&quot;);
        $finish();
}
</pre>
</div>
<div id="systemtasks" class="table">
<p class="caption">表2.6: 本書で使用するシステム関数, システムタスク</p>
<table>
<tr class="hline"><th>関数名</th><th>機能</th><th>戻り値</th></tr>
<tr class="hline"><td>$clog2</td><td>値のlog2のceilを求める</td><td>数値</td></tr>
<tr class="hline"><td>$size</td><td>配列のサイズを求める</td><td>数値</td></tr>
<tr class="hline"><td>$bits</td><td>値の幅を求める</td><td>数値</td></tr>
<tr class="hline"><td>$signed</td><td>値を符号付きとして扱う</td><td>符号付きの値</td></tr>
<tr class="hline"><td>$readmemh</td><td>レジスタにファイルのデータを代入する</td><td>なし</td></tr>
<tr class="hline"><td>$display</td><td>文字列を出力する</td><td>なし</td></tr>
<tr class="hline"><td>$error</td><td>エラー出力する</td><td>なし</td></tr>
<tr class="hline"><td>$finish</td><td>シミュレーションを終了する</td><td>なし</td></tr>
</table>
</div>

<h4><a id="h2-2-9-4"></a>標準ライブラリ</h4>
<p>Verylには、よく使うモジュールなどが標準ライブラリとして準備されています。標準ライブラリは<a href="https://std.veryl-lang.org/" class="link">https://std.veryl-lang.org/</a>で確認することができます。</p>
<p>本書では標準ライブラリを使用していないため、説明は割愛します。</p>

        </main>
        <nav class="page-navi">
          <a href="02-setup.html" class="page-prev">&#9664;</a>
          <a href="04-impl-rv32i.html" class="page-next">&#9654;</a>
        </nav>
        <footer>
        </footer>
      </div>
    </div>
  </body>
</html>
<!-- layout.html5.erb -->
