import{_ as a,c as n,o as e,af as l,bQ as p}from"./chunks/framework.D5l_65jD.js";const h=JSON.parse('{"title":"U-modeの実装","description":"","frontmatter":{},"headers":[],"relativePath":"basic/22-umode-csr.md","filePath":"basic/22-umode-csr.md"}'),t={name:"basic/22-umode-csr.md"};function c(o,s,r,d,i,u){return e(),n("div",null,[...s[0]||(s[0]=[l(`<h1 id="u-modeの実装" tabindex="-1">U-modeの実装 <a class="header-anchor" href="#u-modeの実装" aria-label="Permalink to “U-modeの実装”">​</a></h1><p>本章ではRISC-Vで最も低い特権レベルであるUserモード(U-mode)を実装します。 U-modeはM-modeに管理されてアプリケーションを動かすための特権レベルであり、 M-modeで利用できていたほとんどのCSR、機能が制限されます。</p><p>本章で実装、変更する主な機能は次の通りです。 それぞれ解説しながら実装していきます。</p><ol><li>mstatusレジスタの一部のフィールド</li><li>CSRのアクセス権限、MRET命令の実行権限の確認</li><li>mcounterenレジスタ</li><li>割り込み条件、トラップの動作</li></ol><h2 id="misa-extensionsの変更" tabindex="-1">misa.Extensionsの変更 <a class="header-anchor" href="#misa-extensionsの変更" aria-label="Permalink to “misa.Extensionsの変更”">​</a></h2><p>U-modeを実装しているかどうかはmisa.ExtensionsのUビットで確認できます。</p><p>misa.ExtensionsのUビットを<code>1</code>にします (リスト1)。</p><p><span class="caption">▼リスト16.1: Uビットを1にする (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> misa    : UIntX  = {<span class="hljs-number">2&#39;d2</span>, <span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> XLEN - <span class="hljs-number">28</span>, <span class="hljs-number">26&#39;b00000</span><span class="custom-hl-bold"><span class="hljs-number">1</span></span><span class="hljs-number">00000001000100000101</span>}; <span class="hljs-comment">// U, M, I, C, A</span>
</code></pre></div><h2 id="mstatus-uxlの実装" tabindex="-1">mstatus.UXLの実装 <a class="header-anchor" href="#mstatus-uxlの実装" aria-label="Permalink to “mstatus.UXLの実装”">​</a></h2><p>U-modeのときのXLENはUXLENと定義されておりmstatus.UXLで確認できます。 仕様上はmstatus.UXLの書き換えでUXLENを変更できるように実装できますが、 本書ではUXLENが常に<code>64</code>になるように実装します。</p><p>mstatus.UXLを<code>64</code>を示す値である<code>2</code>に設定します ( リスト2、 リスト3 )。</p><p><span class="caption">▼リスト16.2: mstatus.UXLの定義 (eei.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// mstatus</span>
<span class="hljs-keyword">const</span> MSTATUS_UXL: UInt64 = <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">32</span>;
</code></pre></div><p><span class="caption">▼リスト16.3: UXLの初期値を設定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        mode     = PrivMode::M;
        mstatus  = <span class="custom-hl-bold">MSTATUS_UXL</span>;
        mtvec    = <span class="hljs-number">0</span>;
</code></pre></div><h2 id="mstatus-twの実装" tabindex="-1">mstatus.TWの実装 <a class="header-anchor" href="#mstatus-twの実装" aria-label="Permalink to “mstatus.TWの実装”">​</a></h2><p>mstatus.TWは、M-modeよりも低い特権レベルでWFI命令を実行するときに時間制限(Timeout Wait)を設けるためのビットです。 mstatus.TWが<code>0</code>のとき時間制限はありません。 <code>1</code>に設定されているとき、CPUの実装固有の時間だけ実行の再開を待ち、 時間制限を過ぎるとIllegal instruction例外を発生させます。</p><p>本書ではmstatus.TWが<code>1</code>のときに無限時間待てることにして、例外の実装を省略します。 mstatus.TWを書き換えられるようにします (リスト4)。</p><p><span class="caption">▼リスト16.4: 書き込みマスクを変更する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">const</span> MSTATUS_WMASK : UIntX = <span class="hljs-number">&#39;h0000_0000_00</span><span class="custom-hl-bold"><span class="hljs-number">2</span></span><span class="hljs-number">0_0088</span> <span class="hljs-keyword">as</span> UIntX;
</code></pre></div><h2 id="mstatus-mppの実装" tabindex="-1">mstatus.MPPの実装 <a class="header-anchor" href="#mstatus-mppの実装" aria-label="Permalink to “mstatus.MPPの実装”">​</a></h2><p>M-mode、U-modeだけが存在する環境でトラップが発生するとき、 CPUはmstatusレジスタのMPPフィールドに現在の特権レベル(を示す値)を保存し、 特権レベルをM-modeに変更します。 また、MRET命令を実行するとmstatus.MPPの特権レベルに移動するようになります。</p><p>これにより、 トラップによるU(M)-modeからM-modeへの遷移、 MRET命令によるM-modeからU-modeへの遷移を実現できます。</p><p>MRET命令を実行するとmstatus.MPPは実装がサポートする最低の特権レベルに設定されます。</p><p>M-modeからU-modeに遷移したいときは、mstatus.MPPをU-modeの値に変更し、 U-modeで実行を開始したいアドレスをmepcレジスタに設定してMRET命令を実行します。</p><p>mstatus.MPPに値を書き込めるようにします (リスト5)。</p><p><span class="caption">▼リスト16.5: 書き込みマスクを変更する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">const</span> MSTATUS_WMASK : UIntX = <span class="hljs-number">&#39;h0000_0000_0020_</span><span class="custom-hl-bold"><span class="hljs-number">18</span></span><span class="hljs-number">88</span> <span class="hljs-keyword">as</span> UIntX;
</code></pre></div><p>MPPには<code>2&#39;b00</code>(U-mode)と<code>2&#39;b11</code>(M-mode)のみ設定できるようにします。 サポートしていない値を書き込もうとする場合は現在の値を維持します ( リスト6、 リスト7 )。</p><p><span class="caption">▼リスト16.6: mstatusの書き込み (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>CsrAddr::MSTATUS : mstatus  = validate_mstatus(mstatus, wdata);
</code></pre></div><p><span class="caption">▼リスト16.7: mstatusレジスタの値を確認する関数 (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> validate_mstatus (
    mstatus: <span class="hljs-keyword">input</span> UIntX,
    wdata  : <span class="hljs-keyword">input</span> UIntX,
) -&gt; UIntX {
    <span class="hljs-keyword">var</span> result: UIntX;
    result = wdata;
    <span class="hljs-comment">// MPP</span>
    <span class="hljs-keyword">if</span> wdata[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>] != PrivMode::M &amp;&amp; wdata[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>] != PrivMode::U {
        result[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>] = mstatus[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>];
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre></div><p>トラップが発生する、トラップから戻るときの遷移先の特権レベルを求めます ( リスト8、 リスト9、 リスト10、 リスト11、 リスト12 )。</p><p><span class="caption">▼リスト16.8: ビットを変数として定義する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="custom-hl-bold"><span class="hljs-keyword">let</span> mstatus_mpp : PrivMode = mstatus[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>] <span class="hljs-keyword">as</span> PrivMode;</span>
<span class="hljs-keyword">let</span> mstatus_mpie: <span class="hljs-keyword">logic</span>    = mstatus[<span class="hljs-number">7</span>];
<span class="hljs-keyword">let</span> mstatus_mie : <span class="hljs-keyword">logic</span>    = mstatus[<span class="hljs-number">3</span>];
</code></pre></div><p><span class="caption">▼リスト16.9: 割り込みの遷移先の特権レベルを示す変数 (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> interrupt_mode: PrivMode = PrivMode::M;
</code></pre></div><p><span class="caption">▼リスト16.10: 例外の遷移先の特権レベルを示す変数 (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> expt_mode  : PrivMode = PrivMode::M;
</code></pre></div><p><span class="caption">▼リスト16.11: MRET命令の遷移先の特権レベルを示す変数 (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> trap_return_mode: PrivMode = mstatus_mpp;
</code></pre></div><p><span class="caption">▼リスト16.12: 遷移先の特権レベルを求める (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> trap_mode_next: PrivMode = <span class="hljs-keyword">switch</span> {
    raise_expt     : expt_mode,
    raise_interrupt: interrupt_mode,
    trap_return    : trap_return_mode,
    <span class="hljs-keyword">default</span>        : PrivMode::U,
};
</code></pre></div><p>トラップが発生するとき、mstatus.MPPに現在の特権レベルを保存します (リスト13)。 また、トラップから戻るとき、特権レベルをmstatus.MPPに設定し、 mstatus.MPPに実装がサポートする最小の特権レベルである<code>PrivMode::U</code>を書き込みます。</p><p><span class="caption">▼リスト16.13: 特権レベル、mstatus.MPPを更新する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">if</span> raise_trap {
    <span class="hljs-keyword">if</span> raise_expt || raise_interrupt {
        ...
        <span class="custom-hl-bold"><span class="hljs-comment">// save current privilege level to mstatus.mpp</span></span>
        @&lt;b&lt;|mstatus[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>] = mode;|
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> trap_return {
        ...
        <span class="custom-hl-bold"><span class="hljs-comment">// set mstatus.mpp = U (least privilege level)</span></span>
        <span class="custom-hl-bold">mstatus[<span class="hljs-number">12</span>:<span class="hljs-number">11</span>] = PrivMode::U;</span>
    }
    <span class="custom-hl-bold">mode = trap_mode_next;</span>
</code></pre></div><h2 id="csrのアクセス権限の確認" tabindex="-1">CSRのアクセス権限の確認 <a class="header-anchor" href="#csrのアクセス権限の確認" aria-label="Permalink to “CSRのアクセス権限の確認”">​</a></h2><p>CSRのアドレスを<code>csr_addr</code>とするとき、 <code>csr_addr[9:8]</code>の2ビットはそのCSRにアクセスできる最低の特権レベルを表しています。 これを下回る特権レベルでCSRにアクセスしようとするとIllegal instruction例外が発生します。</p><p>CSRのアドレスと特権レベルを確認して、例外を起こすようにします ( リスト14、 リスト15、 リスト16 )。</p><p><span class="caption">▼リスト16.14: 現在の特権レベルでCSRにアクセスできるか判定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> expt_csr_priv_violation: <span class="hljs-keyword">logic</span> = is_wsc &amp;&amp; csr_addr[<span class="hljs-number">9</span>:<span class="hljs-number">8</span>] &gt;: mode; <span class="hljs-comment">// attempt to access CSR without privilege level</span>
</code></pre></div><p><span class="caption">▼リスト16.15: 例外の発生条件に追加する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> raise_expt: <span class="hljs-keyword">logic</span> = valid &amp;&amp; (expt_info.valid || expt_write_readonly_csr || <span class="custom-hl-bold">expt_csr_priv_violation</span>);
</code></pre></div><p><span class="caption">▼リスト16.16: causeを設定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>expt_write_readonly_csr: CsrCause::ILLEGAL_INSTRUCTION,
<span class="custom-hl-bold">expt_csr_priv_violation: CsrCause::ILLEGAL_INSTRUCTION,</span>
<span class="hljs-keyword">default</span>                : <span class="hljs-number">0</span>,
</code></pre></div><h2 id="mcounterenレジスタの実装" tabindex="-1">mcounterenレジスタの実装 <a class="header-anchor" href="#mcounterenレジスタの実装" aria-label="Permalink to “mcounterenレジスタの実装”">​</a></h2><p><img src="`+p+`" alt="mcounterenレジスタ"> mcounterenレジスタは、M-modeの次に低い特権レベルで ハードウェアパフォーマンスモニタにアクセスできるようにするかを制御する32ビットのレジスタです(図1)。 CY、TM、IRビットはそれぞれcycle、time、instretにアクセスできるかどうかを制御します<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>本章でM-modeの次に低い特権レベルとしてU-modeを実装するため、 mcounterenレジスタはU-modeでのアクセスを制御します。 mcounterenレジスタで許可されていないままU-modeでcycle、time、instretレジスタにアクセスしようとすると、 Illelgal Instruction例外が発生します。</p><p>mcounterenレジスタを作成し、CY、TM、IRビットに書き込みできるようにします ( リスト17、 リスト19、 リスト20、 リスト21、 リスト18、 リスト22 )。</p><p><span class="caption">▼リスト16.17: mcounterenレジスタの定義 (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">var</span> mcounteren: UInt32;
</code></pre></div><p><span class="caption">▼リスト16.18: mcounterenレジスタを0でリセットする (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>mie        = <span class="hljs-number">0</span>;
<span class="custom-hl-bold">mcounteren = <span class="hljs-number">0</span>;</span>
mscratch   = <span class="hljs-number">0</span>;
</code></pre></div><p><span class="caption">▼リスト16.19: rdataにmcounterenレジスタを設定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>CsrAddr::MIE       : mie,
<span class="custom-hl-bold">CsrAddr::MCOUNTEREN: {<span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> XLEN - <span class="hljs-number">32</span>, mcounteren},</span>
CsrAddr::MCYCLE    : mcycle,
</code></pre></div><p><span class="caption">▼リスト16.20: 書き込みマスクの定義 (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">const</span> MCOUNTEREN_WMASK: UIntX = <span class="hljs-number">&#39;h0000_0000_0000_0007</span> <span class="hljs-keyword">as</span> UIntX;
</code></pre></div><p><span class="caption">▼リスト16.21: wmaskに書き込みマスクを設定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>CsrAddr::MIE       : MIE_WMASK,
<span class="custom-hl-bold">CsrAddr::MCOUNTEREN: MCOUNTEREN_WMASK,</span>
CsrAddr::MSCRATCH  : MSCRATCH_WMASK,
</code></pre></div><p><span class="caption">▼リスト16.22: mcounterenレジスタの書き込み (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>CsrAddr::MIE       : mie        = wdata;
<span class="custom-hl-bold">CsrAddr::MCOUNTEREN: mcounteren = wdata[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];</span>
CsrAddr::MSCRATCH  : mscratch   = wdata;
</code></pre></div><p>U-modeでハードウェアパフォーマンスモニタにアクセスするとき、 mcounterenレジスタのビットが<code>0</code>ならIllegal instruction例外を発生させます ( リスト23、 リスト24 )。</p><p><span class="caption">▼リスト16.23: U-modeのとき、mcounterenレジスタを確認する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> expt_zicntr_priv       : <span class="hljs-keyword">logic</span> = is_wsc &amp;&amp; mode == PrivMode::U &amp;&amp; <span class="hljs-keyword">case</span> csr_addr {
    CsrAddr::CYCLE  : !mcounteren[<span class="hljs-number">0</span>],
    CsrAddr::TIME   : !mcounteren[<span class="hljs-number">1</span>],
    CsrAddr::INSTRET: !mcounteren[<span class="hljs-number">2</span>],
    <span class="hljs-keyword">default</span>         : <span class="hljs-number">0</span>,
}; <span class="hljs-comment">// attemp to access Zicntr CSR without permission</span>
</code></pre></div><p><span class="caption">▼リスト16.24: causeを設定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>expt_csr_priv_violation: CsrCause::ILLEGAL_INSTRUCTION,
<span class="custom-hl-bold">expt_zicntr_priv       : CsrCause::ILLEGAL_INSTRUCTION,</span>
<span class="hljs-keyword">default</span>                : <span class="hljs-number">0</span>,
</code></pre></div><h2 id="mret命令の実行を制限する" tabindex="-1">MRET命令の実行を制限する <a class="header-anchor" href="#mret命令の実行を制限する" aria-label="Permalink to “MRET命令の実行を制限する”">​</a></h2><p>MRET命令はM-mode以上の特権レベルのときにしか実行できません。 M-mode未満の特権レベルでMRET命令を実行しようとするとIllegal instruction例外が発生します。</p><p>命令がMRET命令のとき、特権レベルを確認して例外を発生させます ( リスト25、 リスト26、 リスト27 )。</p><p><span class="caption">▼リスト16.25: MRET命令を実行するとき、現在の特権レベルを確認する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> expt_trap_return_priv: <span class="hljs-keyword">logic</span> = is_mret &amp;&amp; mode &lt;: PrivMode::M; <span class="hljs-comment">// attempt to execute trap return instruction in low privilege level</span>
</code></pre></div><p><span class="caption">▼リスト16.26: 例外の発生条件に追加する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> raise_expt: <span class="hljs-keyword">logic</span> = valid &amp;&amp; (expt_info.valid || expt_write_readonly_csr || expt_csr_priv_violation || expt_zicntr_priv <span class="custom-hl-bold">|| expt_trap_return_priv</span>);
</code></pre></div><p><span class="caption">▼リスト16.27: causeを設定する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>    expt_zicntr_priv       : CsrCause::ILLEGAL_INSTRUCTION,
    <span class="custom-hl-bold">expt_trap_return_priv  : CsrCause::ILLEGAL_INSTRUCTION,</span>
    <span class="hljs-keyword">default</span>                : <span class="hljs-number">0</span>,
};
</code></pre></div><h2 id="ecall命令のcauseを変更する" tabindex="-1">ECALL命令のcauseを変更する <a class="header-anchor" href="#ecall命令のcauseを変更する" aria-label="Permalink to “ECALL命令のcauseを変更する”">​</a></h2><p>M-modeでECALL命令を実行するとEnvironment call from M-mode例外が発生します。 これに対してU-modeでECALL命令を実行するとEnvironment call from U-mode例外が発生します。 特権レベルと例外の対応は表1のようになっています。</p><div id="ecall.cause.table" class="table"><p class="caption">表16.1: ECALL命令を実行したときに発生する例外</p><table><tr class="hline"><th>特権レベル</th><th>例外</th><th>cause</th></tr><tr class="hline"><td>M-mode</td><td>Environment call from M-mode</td><td>11</td></tr><tr class="hline"><td>S-mode</td><td>Environment call from S-mode</td><td>9</td></tr><tr class="hline"><td>U-mode</td><td>Environment call from U-mode</td><td>8</td></tr></table></div> ここで各例外のcauseがU-modeのcauseに特権レベルの数値を足したものになっていることを利用します。 \`CsrCause\`型にEnvironment call from U-mode例外のcauseを追加します ( リスト28 )。 <p><span class="caption">▼リスト16.28: CsrCause型に例外のcauseを追加する (eei.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>STORE_AMO_ADDRESS_MISALIGNED = <span class="hljs-number">6</span>,
<span class="custom-hl-bold">ENVIRONMENT_CALL_FROM_U_MODE = <span class="hljs-number">8</span>,</span>
ENVIRONMENT_CALL_FROM_M_MODE = <span class="hljs-number">11</span>,
</code></pre></div><p>csrunitモジュールの<code>mode</code>レジスタをポート宣言に移動し、 IDステージでECALL命令をデコードするときにcauseに<code>mode</code>を足します ( リスト29、 リスト30、 リスト31、 リスト32 )。</p><p><span class="caption">▼リスト16.29: modeレジスタをポートに移動する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>rdata      : <span class="hljs-keyword">output</span>  UIntX               ,
<span class="custom-hl-bold">mode       : <span class="hljs-keyword">output</span>  PrivMode            ,</span>
raise_trap : <span class="hljs-keyword">output</span>  <span class="hljs-keyword">logic</span>               ,
</code></pre></div><p><span class="caption">▼リスト16.30: csrunitから現在の特権レベルを受け取る変数 (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">var</span> csru_priv_mode  : PrivMode;
</code></pre></div><p><span class="caption">▼リスト16.31: csrunitモジュールのインスタンスから現在の特権レベルを受け取る (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>rdata      : csru_rdata           ,
<span class="custom-hl-bold">mode       : csru_priv_mode       ,</span>
raise_trap : csru_raise_trap      ,
</code></pre></div><p><span class="caption">▼リスト16.32: Environment call from U-mode例外のcauseに特権レベルの数値を足す (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ids_inst_bits == <span class="hljs-number">32&#39;h00000073</span> {
    <span class="hljs-comment">// ECALL</span>
    exq_wdata.expt.valid      = <span class="hljs-number">1</span>;
    exq_wdata.expt.cause      = <span class="custom-hl-bold">CsrCause::ENVIRONMENT_CALL_FROM_U_MODE;</span>
    <span class="custom-hl-bold">exq_wdata.expt.cause[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] = csru_priv_mode;</span>
    exq_wdata.expt.value      = <span class="hljs-number">0</span>;
</code></pre></div><h2 id="割り込み条件の変更" tabindex="-1">割り込み条件の変更 <a class="header-anchor" href="#割り込み条件の変更" aria-label="Permalink to “割り込み条件の変更”">​</a></h2><p>M-modeだけが実装されたCPUで割り込みが発生する条件は<a href="./21-impl-interrupt.html">「15.1.2 RISC-Vの割り込み」</a>で解説しましたが、 M-modeとU-modeだけが実装されたCPUで割り込みが発生する条件は少し異なります。 M-modeとU-modeだけが実装されたCPUで割り込みが発生する条件は次の通りです。</p><ol><li>割り込み原因に対応したmipレジスタのビットが<code>1</code>である</li><li>割り込み原因に対応したmieレジスタのビットが<code>1</code>である</li><li>現在の特権レベルがM-mode未満である。またはmstatus.MIEが<code>1</code>である</li></ol><p>M-modeだけの場合と違い、 現在の特権レベルがU-modeのときはグローバル割り込みイネーブルビット(mstatus.MIE)の値は考慮されずに割り込みが発生します。</p><p>現在の特権レベルによって割り込みが発生する条件を切り替えます。 U-modeのときはmstatus.MIEを考慮しないようにします (リスト33)。</p><p><span class="caption">▼リスト16.33: U-modeのとき、割り込みの発生条件を変更する (csrunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> raise_interrupt  : <span class="hljs-keyword">logic</span> = valid &amp;&amp; can_intr &amp;&amp; <span class="custom-hl-bold">(mode != PrivMode::M ||</span> mstatus_mie<span class="custom-hl-bold">)</span> &amp;&amp; interrupt_pending != <span class="hljs-number">0</span>;
</code></pre></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>hpmcounterレジスタを制御するHPMビットもありますが、hpmcounterレジスタを実装していないので実装しません <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>`,111)])])}const v=a(t,[["render",c]]);export{h as __pageData,v as default};
