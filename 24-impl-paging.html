<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>S-modeの実装 (2. 仮想記憶システム) | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="PLICの実装" href="25-impl-plic.html">
    <link rel="prev" title="S-modeの実装 (1. CSRの実装)" href="23-smode-csr.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき</a></li>
<li class="toc-part">第I部 RV32I/RV64Iの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./02-setup.html">1 環境構築</a></li>
    <li class="toc-chapter"><a href="./03-veryl.html">2 ハードウェア記述言語 Veryl</a></li>
    <li class="toc-chapter"><a href="./04-impl-rv32i.html">3 RV32Iの実装</a></li>
    <li class="toc-chapter"><a href="./04a-zicsr.html">4 Zicsr拡張の実装</a></li>
    <li class="toc-chapter"><a href="./04b-riscvtests.html">5 riscv-testsによるテスト</a></li>
    <li class="toc-chapter"><a href="./05-impl-rv64i.html">6 RV64Iの実装</a></li>
    <li class="toc-chapter"><a href="./05a-pipeline.html">7 CPUのパイプライン化</a></li>
    <li class="toc-chapter"><a href="./05b-synth.html">8 CPUの合成</a></li>
  </ul>
</li>
<li class="toc-part">第II部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">9 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">10 例外の実装</a></li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">11 Memory-mapped I/Oの実装</a></li>
    <li class="toc-chapter"><a href="./13-impl-a.html">12 A拡張の実装</a></li>
    <li class="toc-chapter"><a href="./14-impl-c.html">13 C拡張の実装</a></li>
  </ul>
</li>
<li class="toc-part">第III部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">14 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">15 M-modeの実装 (2. 割り込みの実装)</a></li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">16 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">17 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">18 S-modeの実装 (2. 仮想記憶システム)</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./24-impl-paging.html#h18-1">18.1 概要</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-2">18.2 satpレジスタ</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-3">18.3 Sv39のアドレス変換</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-4">18.4 実装順序</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-5">18.5 メモリで発生する例外の実装</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-6">18.6 satpレジスタの作成</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-7">18.7 mstatusのMXR、SUM、MPRVビットの実装</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-8">18.8 アドレス変換モジュール(PTW)の実装</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-9">18.9 Sv39の実装</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-10">18.10 SFENCE.VMA命令の実装</a></li>
        <li class="toc-section"><a href="./24-impl-paging.html#h18-11">18.11 パイプラインをフラッシュする</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">19 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">20 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99-postface.html">あとがき (第Ⅰ部)</a></li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき (第Ⅱ部、第Ⅲ部)</a></li>
    <li class="toc-chapter"><a href="./100-contribute.html">このプロジェクトに貢献する</a></li>
    <li class="toc-chapter"><a href="./bib.html">参考文献</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h18"></a><span class="secno">第18章</span> <br/>S-modeの実装 (2. 仮想記憶システム)</h1>

<h2 class="numbox"><a id="h18-1"></a><span class="secno">18.1</span> 概要</h2>

<h3 class="none"><a id="h18-1-1"></a><span class="secno">18.1.1</span> 仮想記憶システム</h3>
<p>仮想記憶(Virtual Memory)とは、メモリを管理する手法の一種です。仮想的なアドレス(virtual address、仮想アドレス)を実際のアドレス(real address、実アドレス)に変換することにより、実際のアドレス空間とは異なるアドレス空間を提供することができます。実アドレスのことを物理アドレス(physical address)と呼ぶことがあります。</p>
<p>仮想記憶を利用すると、次のような動作を実現できます。</p>
<ol start="1" type="1">
<li>連続していない物理アドレス空間を仮想的に連続したアドレス空間として扱う。</li>
<li>特定のアドレスにしか配置できない(特定のアドレスで動くことを前提としている)プログラムを、そのアドレスとは異なる物理アドレスに配置して実行する。</li>
<li>アプリケーションごとにアドレス空間を分離する。</li>
</ol>
<p>一般的に仮想記憶システムはハードウェアによって提供されます。メモリアクセスを処理するハードウェア部品のことをメモリ管理ユニット(Memory Management Unit, MMU)と呼びます。</p>

<h3 class="none"><a id="h18-1-2"></a><span class="secno">18.1.2</span> ページング方式</h3>
<p>仮想記憶システムを実現する方式の1つにページング方式(Paging)があります。ページング方式は、物理アドレス空間の一部をページ(Page)という単位に割り当て、ページを参照するための情報をページテーブル(Page Table)に格納します。ページテーブルに格納する情報の単位のことをページテーブルエントリ(Page Table Entry、PTE)と呼びます。仮想アドレスから物理アドレスへの変換はページテーブルにあるPTEを参照して行います(<span class="imgref"><a href="./24-impl-paging.html#ptpte">図18.1</a></span>)。</p>
<div id="ptpte" class="image">
<img src="images/24-impl-paging/ptpte.png" alt="仮想アドレスの変換にPTEを使う" class="img" style="width:80%" />
<p class="caption">
図18.1: 仮想アドレスの変換にPTEを使う
</p>
</div>

<h3 class="none"><a id="h18-1-3"></a><span class="secno">18.1.3</span> RISC-Vの仮想記憶システム</h3>
<p>RISC-Vの仮想記憶システムはページング方式を採用しており、RV32I向けにはSv32、RV64I向けにはSv39、Sv48、Sv57が定義されています。</p>
<p>RISC-Vの仮想アドレスの変換を簡単に説明します。仮想アドレスの変換は次のプロセスで行います。</p>
<p>(a) satpレジスタのPPNフィールドと仮想アドレスのフィールドからPTEの物理アドレスを作る。(b) PTEを読み込む。PTEが有効なものか確認する。(c) PTEがページを指しているとき、PTEに書かれている権限を確認してから物理アドレスを作り、アドレス変換終了。(d) PTEが次のPTEを指しているとき、PTEのフィールドと仮想アドレスのフィールドから次のPTEの物理アドレスを作り、(b)に戻る。</p>
<p>satpレジスタは仮想記憶システムを制御するためのCSRです。一番最初に参照するPTEのことをroot PTEと呼びます。また、PTEがページを指しているとき、そのPTEのことをleaf PTEと呼びます。</p>
<p>RISC-Vのページングでは、satpレジスタと仮想アドレス、PTEを使って多段階のPTEの参照を行い、仮想アドレスを物理アドレスに変換します。Sv39の場合、何段階で物理アドレスに変換できるかによってページサイズは4KiB、2MiB、1GiBと異なります。これ以降、MMU内のページング方式を実現する部品のことをPTW(Page Table Walker)と呼びます<sup><a id="fnb-ptw" href="#fn-ptw" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-ptw" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>ページテーブルをたどってアドレスを変換するのでPage Table Walkerと呼びます。アドレスを変換することをPage Table Walkと呼ぶこともあります。</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h18-2"></a><span class="secno">18.2</span> satpレジスタ</h2>
<div id="satp" class="image">
<img src="images/24-impl-paging/satp.png" alt="satpレジスタ" class="img" style="width:90%" />
<p class="caption">
図18.2: satpレジスタ
</p>
</div>
<p>RISC-Vの仮想記憶システムはsatpレジスタによって制御します。</p>
<p>MODEは仮想アドレスの変換方式を指定するフィールドです。方式と値は<span class="tableref"><a href="./24-impl-paging.html#satp.numtomode">表18.1</a></span>のように対応しています。方式がBare(<code class="inline-code" translate="no" >0</code>)のときはアドレス変換を行いません(仮想アドレス=物理アドレス)。</p>
<div id="satp.numtomode" class="table">
<p class="caption">表18.1: 方式とMODEの値の対応</p>
<table>
<tr class="hline"><th>方式</th><th>MODE</th></tr>
<tr class="hline"><td>Bare</td><td>0</td></tr>
<tr class="hline"><td>Sv39</td><td>8</td></tr>
<tr class="hline"><td>Sv48</td><td>9</td></tr>
<tr class="hline"><td>Sv57</td><td>10</td></tr>
</table>
</div>
<p>ASID(Address Space IDentifier)は仮想アドレスが属するアドレス空間のIDです。動かすアプリケーションによってIDを変えることでMMUにアドレス変換の高速化のヒントを与えることができます。本章ではキャッシュ機構を持たない単純なモジュールを実装するため、ASIDを無視したアドレス変換を実装します<sup><a id="fnb-tlb" href="#fn-tlb" class="noteref" epub:type="noteref">*2</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-tlb" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>PTWはページエントリをキャッシュすることで高速化できます。ASIDが異なるときのキャッシュは利用することができません。キャッシュ機構(TLB)は応用編で実装します。</p></div>
</div><!--/.footnote-list-->
<div id="rootpteaddr" class="image">
<img src="images/24-impl-paging/rootpteaddr.png" alt="root PTEのアドレスはsatpレジスタと仮想アドレスから構成される" class="img" style="width:90%" />
<p class="caption">
図18.3: root PTEのアドレスはsatpレジスタと仮想アドレスから構成される
</p>
</div>
<p>PPN(Physical Page Number)はroot PTEの物理アドレスの一部を格納するフィールドです。root PTEのアドレスは仮想アドレスのVPNビットと組み合わせて作られます(<span class="imgref"><a href="./24-impl-paging.html#rootpteaddr">図18.3</a></span>)。</p>

<h2 id="sv39process" class="numbox"><a id="h18-3"></a><span class="secno">18.3</span> Sv39のアドレス変換</h2>
<div id="virtualaddress" class="image">
<img src="images/24-impl-paging/virtualaddress.png" alt="仮想アドレス" class="img" style="width:90%" />
<p class="caption">
図18.4: 仮想アドレス
</p>
</div>
<div id="physicaladdress" class="image">
<img src="images/24-impl-paging/physicaladdress.png" alt="物理アドレス" class="img" style="width:90%" />
<p class="caption">
図18.5: 物理アドレス
</p>
</div>
<p>Sv39では39ビットの仮想アドレスを56ビットの物理アドレスに変換します。</p>
<p>ページの最小サイズは4096(<code class="inline-code" translate="no" >2 ** 12</code>)バイト、PTEのサイズは8(<code class="inline-code" translate="no" >2 ** 3</code>)バイトです。それぞれ12と8をPAGESIZE、PTESIZEという定数として定義します。</p>
<p>ページテーブルのサイズ(1つのページテーブルに含まれるPTEの数)は512(= <code class="inline-code" translate="no" >2 ** 9</code>)個です。1回のアドレス変換で、最大3回PTEをフェッチし、leaf PTEを見つけます。</p>
<p>アドレスの変換途中でPTEが不正な値だったり、ページが求める権限を持たずにページにアクセスしようとした場合、アクセスする目的に応じたページフォルト(Page fault)例外が発生します<sup><a id="fnb-access-fault" href="#fn-access-fault" class="noteref" epub:type="noteref">*3</a></sup>。命令フェッチはInstruction page fault例外、ロード命令はLoad page fault例外、ストアとAMO命令はStore/AMO page fault例外が発生します。</p>
<div class="footnote-list">
<div class="footnote" id="fn-access-fault" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*3] </span>RISC-VのMMUはPMP、PMAという仕組みで物理アドレス空間へのアクセスを制限することができ、それに違反した場合にアクセスフォルト例外を発生させます。本章ではPMP、PMAを実装していないのでアクセスフォルト例外に関する機能について説明せず、実装もしません。これらの機能は応用編で実装します。</p></div>
</div><!--/.footnote-list-->

<h3 class="none"><a id="h18-3-1"></a><span class="secno">18.3.1</span> ページングが有効になる条件</h3>
<p>satpレジスタのMODEフィールドがSv39のとき、S-mode、U-modeでアドレス変換が有効になります。ただし、ロードストアのときは、mstatus.MPRVが<code class="inline-code" translate="no" >1</code>なら特権レベルをmstatus.MPPとして判定します。</p>
<p>有効な仮想アドレスは、MSBでXLENビットに拡張された値である必要があります。有効ではない仮想アドレスの場合、ページフォルト例外が発生します。</p>

<h3 class="none"><a id="h18-3-2"></a><span class="secno">18.3.2</span> PTEのフェッチ</h3>
<div id="pteaddress" class="image">
<img src="images/24-impl-paging/pteaddress.png" alt="PTEのアドレス" class="img" style="width:90%" />
<p class="caption">
図18.6: PTEのアドレス
</p>
</div>
<p>ページングが有効なとき、まずroot PTEをフェッチします。ここでlevelという変数の値を<code class="inline-code" translate="no" >2</code>とします。</p>
<p>root PTEの物理アドレスは、satpレジスタのPPNフィールドと仮想アドレスの<code class="inline-code" translate="no" >VPN[level]</code>フィールドを結合し、<code class="inline-code" translate="no" >log2(PTESIZE)</code>だけ左シフトしたアドレスになります。このアドレスは、PPNフィールドを12ビット左シフトしたアドレスに存在するページテーブルの、VPN[level]番目のPTEのアドレスです。</p>
<div id="pte" class="image">
<img src="images/24-impl-paging/pte.png" alt="PTEのフィールド" class="img" style="width:90%" />
<p class="caption">
図18.7: PTEのフィールド
</p>
</div>
<p>PTEのフィールドは<span class="imgref"><a href="./24-impl-paging.html#pte">図18.7</a></span>のようになっています。このうちN、PBMT、Reservedは使用せず、<code class="inline-code" translate="no" >0</code>でなければページフォルト例外を発生させます。RSWビットは無視します。</p>
<p>下位8ビットはPTEの状態と権限を表すビットです。</p>
<p>Vが<code class="inline-code" translate="no" >1</code>のとき、有効なPTEであることを示します。<code class="inline-code" translate="no" >0</code>ならページフォルト例外を発生させます。</p>
<p>R、W、X、Uはページの権限を指定するビットです。Rは読み込み許可、Wは書き込み許可、Xは実行許可、UはU-modeでアクセスできるかを示します。書き込みできるPTEは読み込みできる必要があり、Wが<code class="inline-code" translate="no" >1</code>なのにRが<code class="inline-code" translate="no" >0</code>ならページフォルト例外を発生させます。</p>
<p>RとXが<code class="inline-code" translate="no" >0</code>のとき、PTEは次のPTEを指しています。このとき、levelが<code class="inline-code" translate="no" >0</code>ならこれ以上PTEを指すことはできない(VPN[-1]は無い)ので、ページフォルト例外を発生させます。levelが<code class="inline-code" translate="no" >1</code>以上なら、levelから<code class="inline-code" translate="no" >1</code>を引いてPTEをフェッチします。次のPTEのアドレスは、PTEのPPN[2]、PPN[1]、PPN[0]と仮想アドレスのVPN[level]を結合し、<code class="inline-code" translate="no" >log2(PTESIZE)</code>だけ左シフトしたアドレスになります。</p>
<p>PTEのRかXが<code class="inline-code" translate="no" >1</code>のとき、PTEはleaf PTEで、ページを指し示しています。</p>
<p>物理アドレスを計算する前に、R、W、X、Uビットで権限を確認します。命令フェッチのときはX、ロードのときはR、ストアのときはW、U-modeのときはUが立っている必要があります。S-modeのときは、Uが立っているページにmstatus.SUMが<code class="inline-code" translate="no" >0</code>の状態でアクセスできません。S-modeのときは、Uが立っているページの実行はできません。これらに違反した場合、ページフォルト例外が発生します。</p>
<div id="level2" class="image">
<img src="images/24-impl-paging/level2.png" alt="levelが2のときの物理アドレス" class="img" style="width:95%" />
<p class="caption">
図18.8: levelが2のときの物理アドレス
</p>
</div>
<p>levelが<code class="inline-code" translate="no" >2</code>なら、物理アドレスはPTEのPPN[2]、仮想アドレスのVPN[1]、VPN[0]、page offsetを結合した値になります(<span class="imgref"><a href="./24-impl-paging.html#level2">図18.8</a></span>)。</p>
<div id="level1" class="image">
<img src="images/24-impl-paging/level1.png" alt="levelが1のときの物理アドレス" class="img" style="width:95%" />
<p class="caption">
図18.9: levelが1のときの物理アドレス
</p>
</div>
<p>levelが<code class="inline-code" translate="no" >1</code>なら、物理アドレスはPTEのPPN[2]、PPN[1]、仮想アドレスのVPN[0]、page offsetを結合した値になります(<span class="imgref"><a href="./24-impl-paging.html#level1">図18.9</a></span>)。</p>
<div id="level0" class="image">
<img src="images/24-impl-paging/level0.png" alt="levelが0のときの物理アドレス" class="img" style="width:95%" />
<p class="caption">
図18.10: levelが0のときの物理アドレス
</p>
</div>
<p>levelが<code class="inline-code" translate="no" >0</code>なら、物理アドレスはPTEのPPN[2]、PPN[1]、PPN[0]、仮想アドレスのpage offsetを結合した値になります(<span class="imgref"><a href="./24-impl-paging.html#level0">図18.10</a></span>)。</p>
<p>leaf PTEの使わないPPNフィールドは<code class="inline-code" translate="no" >0</code>である必要があり、<code class="inline-code" translate="no" >0</code>ではないならページフォルト例外を発生させます。</p>
<p>求めた物理アドレスにアクセスする前に、leaf PTEのA、Dビットを確認します。Aはページがこれまでにアクセスされたか、Dはページがこれまでに書き換えられたかを示すビットです。Aが<code class="inline-code" translate="no" >0</code>のとき、Aを<code class="inline-code" translate="no" >1</code>に設定します。Dが<code class="inline-code" translate="no" >0</code>でストアするとき、Dを<code class="inline-code" translate="no" >1</code>に設定します。Aは投機的に<code class="inline-code" translate="no" >1</code>に変更できますが、Dは命令が実行された場合にしか<code class="inline-code" translate="no" >1</code>に変更できません。</p>

<h2 class="numbox"><a id="h18-4"></a><span class="secno">18.4</span> 実装順序</h2>
<p>RISC-Vでは命令フェッチ、データのロードストアの両方でページングを利用できます。命令フェッチ、データのロードストアのそれぞれのために2つのPTWを用意してもいいですが、シンプルなアーキテクチャにするために本章では1つのPTWを共有することにします。</p>
<p>inst_fetcherモジュール、amounitモジュールは仮想アドレスを扱うことがありますが、mmio_controllerモジュールは常に物理アドレス空間を扱います。そのため、inst_fetcherモジュール、amounitモジュールとmmio_controllerモジュールの間にPTWを配置します(<span class="imgref"><a href="./24-impl-paging.html#ptw-mmio-structure">図18.11</a></span>)。</p>
<p>本章では、仮想記憶システムを次の順序で実装します。</p>
<ol start="1" type="1">
<li>PTWで発生する例外をcsrunitモジュールに伝達する</li>
<li>Bareにだけ対応したアドレス変換モジュール(ptw)を実装する</li>
<li>satpレジスタ、mstatusのMXR、SUM、MPRVビットを実装する</li>
<li>Sv39を実装する</li>
<li>SFENCE.VMA命令、FENCEI命令を実装する</li>
</ol>
<div id="ptw-mmio-structure" class="image">
<img src="images/24-impl-paging/ptw-mmio-structure.png" alt="PTWと他のモジュールの接続" class="img" style="width:90%" />
<p class="caption">
図18.11: PTWと他のモジュールの接続
</p>
</div>

<h2 class="numbox"><a id="h18-5"></a><span class="secno">18.5</span> メモリで発生する例外の実装</h2>
<p>PTWで発生した例外は、最終的にcsrunitモジュールで処理します。そのために、例外の情報をメモリのインターフェースを使って伝達します。</p>
<p>ページングによって発生する例外のcauseを<code class="inline-code" translate="no" >CsrCause</code>型に追加します(<span class="listref"><a href="./24-impl-paging.html#eei.veryl.CsrCause.def">リスト18.1</a></span>)。</p>
<div id="eei.veryl.CsrCause.def" class="caption-code">
<span class="caption">リスト18.1: リスト18.1: CsrCause型にページフォルト例外を追加する (eei.veryl)</span>
<pre class="list language-def" translate="no"><em class="lineno">1: </em>    INSTRUCTION_PAGE_FAULT = 12,
<em class="lineno">2: </em>    LOAD_PAGE_FAULT = 13,
<em class="lineno">3: </em>    STORE_AMO_PAGE_FAULT = 15,
</pre>
</div>

<h3 class="none"><a id="h18-5-1"></a><span class="secno">18.5.1</span> 例外を伝達する</h3>

<h4><a id="h18-5-1-1"></a>構造体の定義</h4>
<p><code class="inline-code" translate="no" >MemException</code>構造体を定義します(<span class="listref"><a href="./24-impl-paging.html#eei.veryl.newexpt.def">リスト18.2</a></span>)。メモリアクセス中に発生する例外の情報はこの構造体で管理します。</p>
<div id="eei.veryl.newexpt.def" class="caption-code">
<span class="caption">リスト18.2: リスト18.2: MemException型の定義 (eei.veryl)</span>
<pre class="list language-def" translate="no"><em class="lineno">1: </em>    struct MemException {
<em class="lineno">2: </em>        valid     : logic,
<em class="lineno">3: </em>        page_fault: logic,
<em class="lineno">4: </em>    }
</pre>
</div>
<p><code class="inline-code" translate="no" >membus_if</code>、<code class="inline-code" translate="no" >core_data_if</code>、<code class="inline-code" translate="no" >core_inst_if</code>インターフェースに<code class="inline-code" translate="no" >MemException</code>構造体を追加します(<span class="listref"><a href="./24-impl-paging.html#membus_if.veryl.newexpt.var">リスト18.3</a></span>、<span class="listref"><a href="./24-impl-paging.html#membus_if.veryl.newexpt.master">リスト18.4</a></span>、<span class="listref"><a href="./24-impl-paging.html#membus_if.veryl.newexpt.response">リスト18.5</a></span>)。インターフェースの<code class="inline-code" translate="no" >rvalid</code>が<code class="inline-code" translate="no" >1</code>で、構造体の<code class="inline-code" translate="no" >valid</code>と<code class="inline-code" translate="no" >is_page_fault</code>が<code class="inline-code" translate="no" >1</code>ならページフォルト例外が発生したことを示します。</p>
<div id="membus_if.veryl.newexpt.var" class="caption-code">
<span class="caption">リスト18.3: リスト18.3: MemException型を追加する (membus_if.veryl, core_data_if.veryl, core_inst_if.veryl)</span>
<pre class="list language-var" translate="no"><em class="lineno">1: </em>    var expt  : eei::MemException                ;
</pre>
</div>
<div id="membus_if.veryl.newexpt.master" class="caption-code">
<span class="caption">リスト18.4: リスト18.4: masterにexptを追加する (membus_if.veryl, core_data_if.veryl, core_inst_if.veryl)</span>
<pre class="list language-master" translate="no"><em class="lineno">1: </em>    modport master {
<em class="lineno">2: </em>        ...
<em class="lineno">3: </em>        <b>expt        : input ,</b>
<em class="lineno">4: </em>        ...
<em class="lineno">5: </em>    }
</pre>
</div>
<div id="membus_if.veryl.newexpt.response" class="caption-code">
<span class="caption">リスト18.5: リスト18.5: responseにexptを追加する (membus_if.veryl)</span>
<pre class="list language-response" translate="no"><em class="lineno">1: </em>    modport response {
<em class="lineno">2: </em>        rvalid: output,
<em class="lineno">3: </em>        rdata : output,
<em class="lineno">4: </em>        expt  : output,
<em class="lineno">5: </em>    }
</pre>
</div>

<h4><a id="h18-5-1-2"></a>mmio_controllerモジュールの対応</h4>
<p>mmio_controllerモジュールで構造体の値をすべて<code class="inline-code" translate="no" >0</code>に設定します(<span class="listref"><a href="./24-impl-paging.html#mmio_controller.veryl.newexpt.comb">リスト18.6</a></span>、<span class="listref"><a href="./24-impl-paging.html#top.veryl.newexpt.comb">リスト18.7</a></span>)。いまのところ、デバイスは例外を発生させません。</p>
<div id="mmio_controller.veryl.newexpt.comb" class="caption-code">
<span class="caption">リスト18.6: リスト18.6: exptを0に設定する (membus_if.veryl)</span>
<pre class="list language-comb" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        req_core.ready  = 0;
<em class="lineno">3: </em>        req_core.rvalid = 0;
<em class="lineno">4: </em>        req_core.rdata  = 0;
<em class="lineno">5: </em>        <b>req_core.expt   = 0;</b>
</pre>
</div>
<p>mmio_controllerモジュールからの例外情報を<code class="inline-code" translate="no" >core_data_if</code>、<code class="inline-code" translate="no" >core_inst_if</code>インターフェースに伝達します。</p>
<div id="top.veryl.newexpt.comb" class="caption-code">
<span class="caption">リスト18.7: リスト18.7: exptを伝達する (top.veryl)</span>
<pre class="list language-comb" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        i_membus.ready  = mmio_membus.ready &amp;&amp; !d_membus.valid;
<em class="lineno">3: </em>        i_membus.rvalid = mmio_membus.rvalid &amp;&amp; memarb_last_i;
<em class="lineno">4: </em>        i_membus.rdata  = mmio_membus.rdata;
<em class="lineno">5: </em>        <b>i_membus.expt   = mmio_membus.expt;</b>
<em class="lineno">6: </em>
<em class="lineno">7: </em>        d_membus.ready  = mmio_membus.ready;
<em class="lineno">8: </em>        d_membus.rvalid = mmio_membus.rvalid &amp;&amp; !memarb_last_i;
<em class="lineno">9: </em>        d_membus.rdata  = mmio_membus.rdata;
<em class="lineno">10: </em>        <b>d_membus.expt   = mmio_membus.expt;</b>
</pre>
</div>

<h4><a id="h18-5-1-3"></a>inst_fetcherモジュールの対応</h4>
<p>inst_fetcherモジュールからcoreモジュールに例外情報を伝達します。まず、FIFOの型に例外情報を追加します(<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.fft">リスト18.8</a></span>、<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.ift">リスト18.9</a></span>))。</p>
<div id="inst_fetcher.veryl.newexpt.fft" class="caption-code">
<span class="caption">リスト18.8: リスト18.8: fetch_firo_typeにMemException型を追加する (inst_fetcher.veryl)</span>
<pre class="list language-fft" translate="no"><em class="lineno">1: </em>    struct fetch_fifo_type {
<em class="lineno">2: </em>        addr: Addr                           ,
<em class="lineno">3: </em>        bits: logic       &lt;MEMBUS_DATA_WIDTH&gt;,
<em class="lineno">4: </em>        <b>expt: MemException                   ,</b>
<em class="lineno">5: </em>    }
</pre>
</div>
<div id="inst_fetcher.veryl.newexpt.ift" class="caption-code">
<span class="caption">リスト18.9: リスト18.9: issue_fifo_typeにMemException型を追加する (inst_fetcher.veryl)</span>
<pre class="list language-ift" translate="no"><em class="lineno">1: </em>    struct issue_fifo_type {
<em class="lineno">2: </em>        addr  : Addr        ,
<em class="lineno">3: </em>        bits  : Inst        ,
<em class="lineno">4: </em>        is_rvc: logic       ,
<em class="lineno">5: </em>        <b>expt  : MemException,</b>
<em class="lineno">6: </em>    }
</pre>
</div>
<p>メモリからの例外情報を<code class="inline-code" translate="no" >fetch_fifo</code>に保存します(<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.fetch">リスト18.10</a></span>)。</p>
<div id="inst_fetcher.veryl.newexpt.fetch" class="caption-code">
<span class="caption">リスト18.10: リスト18.10: メモリの例外情報をfetch_fifoに保存する (inst_fetcher.veryl)</span>
<pre class="list language-fetch" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        fetch_fifo_flush      = core_if.is_hazard;
<em class="lineno">3: </em>        fetch_fifo_wvalid     = fetch_requested &amp;&amp; mem_if.rvalid;
<em class="lineno">4: </em>        fetch_fifo_wdata.addr = fetch_pc_requested;
<em class="lineno">5: </em>        fetch_fifo_wdata.bits = mem_if.rdata;
<em class="lineno">6: </em>        <b>fetch_fifo_wdata.expt = mem_if.expt;</b>
<em class="lineno">7: </em>    }
</pre>
</div>
<p><code class="inline-code" translate="no" >fetch_fifo</code>から<code class="inline-code" translate="no" >issue_fifo</code>に例外情報を伝達します(<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.feif">リスト18.11</a></span>)、<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.offset_comb">リスト18.12</a></span>、<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.offset_ff">リスト18.13</a></span>)。offsetが<code class="inline-code" translate="no" >6</code>で例外が発生しているとき、32ビット幅の命令の上位16ビットを取得せずにすぐに<code class="inline-code" translate="no" >issue_fifo</code>に例外を書き込みます。</p>
<div id="inst_fetcher.veryl.newexpt.feif" class="caption-code">
<span class="caption">リスト18.11: リスト18.11: fetch_fifoからissue_fifoに例外情報を伝達する (inst_fetcher.veryl)</span>
<pre class="list language-feif" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        let raddr : Addr                            = fetch_fifo_rdata.addr;
<em class="lineno">3: </em>        let rdata : logic       &lt;MEMBUS_DATA_WIDTH&gt; = fetch_fifo_rdata.bits;
<em class="lineno">4: </em>        <b>let expt  : MemException                    = fetch_fifo_rdata.expt;</b>
<em class="lineno">5: </em>        let offset: logic       &lt;3&gt;                 = issue_pc_offset;
<em class="lineno">6: </em>
<em class="lineno">7: </em>        fetch_fifo_rready     = 0;
<em class="lineno">8: </em>        issue_fifo_wvalid     = 0;
<em class="lineno">9: </em>        issue_fifo_wdata      = 0;
<em class="lineno">10: </em>        <b>issue_fifo_wdata.expt = expt;</b>
</pre>
</div>
<div id="inst_fetcher.veryl.newexpt.offset_comb" class="caption-code">
<span class="caption">リスト18.12: リスト18.12: offsetが6のときに例外が発生している場合、すぐにissue_fifoに例外を書き込む (inst_fetcher.veryl)</span>
<pre class="list language-offset_comb" translate="no"><em class="lineno">1: </em>    fetch_fifo_rready = 1;
<em class="lineno">2: </em>    if rvcc_is_rvc <b>|| expt.valid</b> {
<em class="lineno">3: </em>        issue_fifo_wvalid       = 1;
<em class="lineno">4: </em>        issue_fifo_wdata.addr   = {raddr[msb:3], offset};
<em class="lineno">5: </em>        issue_fifo_wdata.is_rvc = 1;
<em class="lineno">6: </em>        issue_fifo_wdata.bits   = rvcc_inst32;
</pre>
</div>
<div id="inst_fetcher.veryl.newexpt.offset_ff" class="caption-code">
<span class="caption">リスト18.13: リスト18.13: 例外が発生しているときは32ビット幅の命令の上位16ビットを取得しない (inst_fetcher.veryl)</span>
<pre class="list language-offset_ff" translate="no"><em class="lineno">1: </em>    if issue_pc_offset == 6 &amp;&amp; !rvcc_is_rvc &amp;&amp; !issue_is_rdata_saved <b>&amp;&amp; !fetch_fifo_rdata.expt.valid</b> {
<em class="lineno">2: </em>        if fetch_fifo_rvalid {
<em class="lineno">3: </em>            issue_is_rdata_saved = 1;
</pre>
</div>
<p><code class="inline-code" translate="no" >issue_fifo</code>からcoreモジュールに例外情報を伝達します(<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.newexpt.issue">リスト18.14</a></span>)。</p>
<div id="inst_fetcher.veryl.newexpt.issue" class="caption-code">
<span class="caption">リスト18.14: リスト18.14: issue_fifoからcoreモジュールに例外情報を伝達する (inst_fetcher.veryl)</span>
<pre class="list language-issue" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        issue_fifo_flush  = core_if.is_hazard;
<em class="lineno">3: </em>        issue_fifo_rready = core_if.rready;
<em class="lineno">4: </em>        core_if.rvalid    = issue_fifo_rvalid;
<em class="lineno">5: </em>        core_if.raddr     = issue_fifo_rdata.addr;
<em class="lineno">6: </em>        core_if.rdata     = issue_fifo_rdata.bits;
<em class="lineno">7: </em>        core_if.is_rvc    = issue_fifo_rdata.is_rvc;
<em class="lineno">8: </em>        <b>core_if.expt      = issue_fifo_rdata.expt;</b>
<em class="lineno">9: </em>    }
</pre>
</div>

<h4><a id="h18-5-1-4"></a>amounitモジュールの対応</h4>
<p><code class="inline-code" translate="no" >state</code>が<code class="inline-code" translate="no" >State::Init</code>以外の時に例外が発生した場合、すぐに結果を返すようにします(<span class="listref"><a href="./24-impl-paging.html#amounit.veryl.newexpt.slave">リスト18.15</a></span>、<span class="listref"><a href="./24-impl-paging.html#amounit.veryl.newexpt.slave_end">リスト18.16</a></span>、<span class="listref"><a href="./24-impl-paging.html#amounit.veryl.newexpt.master_end">リスト18.17</a></span>、)。例外が発生したクロックでは要求を受け付けないようにします。</p>
<div id="amounit.veryl.newexpt.slave" class="caption-code">
<span class="caption">リスト18.15: リスト18.15: slaveにexptを割り当てる (amounit.veryl)</span>
<pre class="list language-slave" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        slave.ready  = 0;
<em class="lineno">3: </em>        slave.rvalid = 0;
<em class="lineno">4: </em>        slave.rdata  = 0;
<em class="lineno">5: </em>        <b>slave.expt   = master.expt;</b>
</pre>
</div>
<div id="amounit.veryl.newexpt.slave_end" class="caption-code">
<span class="caption">リスト18.16: リスト18.16: 例外が発生したらすぐに結果を返し、readyを0にする (amounit.veryl)</span>
<pre class="list language-slave_end" translate="no"><em class="lineno">1: </em>            default: {}
<em class="lineno">2: </em>        }
<em class="lineno">3: </em>
<em class="lineno">4: </em>        <b>if state != State::Init &amp;&amp; master.expt.valid {</b>
<em class="lineno">5: </em>        <b>    slave.ready  = 0;</b>
<em class="lineno">6: </em>        <b>    slave.rvalid = 1;</b>
<em class="lineno">7: </em>        <b>}</b>
<em class="lineno">8: </em>    }
</pre>
</div>
<div id="amounit.veryl.newexpt.master_end" class="caption-code">
<span class="caption">リスト18.17: リスト18.17: 例外が発生していたらmasterに要求するのをやめる (amounit.veryl)</span>
<pre class="list language-master_end" translate="no"><em class="lineno">1: </em>            State::AMOStoreValid: accept_request_comb();
<em class="lineno">2: </em>            default             : {}
<em class="lineno">3: </em>        }
<em class="lineno">4: </em>
<em class="lineno">5: </em>        <b>if state != State::Init &amp;&amp; master.expt.valid {</b>
<em class="lineno">6: </em>        <b>    reset_master();</b>
<em class="lineno">7: </em>        <b>}</b>
<em class="lineno">8: </em>    }
</pre>
</div>
<p>例外が発生したら、<code class="inline-code" translate="no" >state</code>を<code class="inline-code" translate="no" >State::Init</code>にリセットします(<span class="listref"><a href="./24-impl-paging.html#amounit.veryl.newexpt.on_clock">リスト18.18</a></span>)。</p>
<div id="amounit.veryl.newexpt.on_clock" class="caption-code">
<span class="caption">リスト18.18: リスト18.18: 例外が発生していたらstateをInitにリセットする (amounit.veryl)</span>
<pre class="list language-on_clock" translate="no"><em class="lineno">1: </em>    function on_clock () {
<em class="lineno">2: </em>        <b>if state != State::Init &amp;&amp; master.expt.valid {</b>
<em class="lineno">3: </em>        <b>    state = State::Init;</b>
<em class="lineno">4: </em>        <b>} else {</b>
<em class="lineno">5: </em>            case state {
<em class="lineno">6: </em>                State::Init     : accept_request_ff();
</pre>
</div>

<h4><a id="h18-5-1-5"></a>Instruction page fault例外の実装</h4>
<p>命令フェッチ処理中にページフォルト例外が発生していたとき、Instruction page fault例外を発生させます。xtvalには例外が発生したアドレスを設定します(<span class="listref"><a href="./24-impl-paging.html#core.veryl.newexpt.inst">リスト18.19</a></span>)。</p>
<div id="core.veryl.newexpt.inst" class="caption-code">
<span class="caption">リスト18.19: リスト18.19: i_membusの例外をExceptionInfo型に設定する (core.veryl)</span>
<pre class="list language-inst" translate="no"><em class="lineno">1: </em>        <b>if i_membus.expt.valid {</b>
<em class="lineno">2: </em>        <b>    // fault</b>
<em class="lineno">3: </em>        <b>    exq_wdata.expt.valid = 1;</b>
<em class="lineno">4: </em>        <b>    exq_wdata.expt.cause = CsrCause::INSTRUCTION_PAGE_FAULT;</b>
<em class="lineno">5: </em>        <b>    exq_wdata.expt.value = ids_pc;</b>
<em class="lineno">6: </em>        <b>} else</b> if !ids_inst_valid {
</pre>
</div>

<h4><a id="h18-5-1-6"></a>ロード、ストア命令のpage fault例外の実装</h4>
<p>ロード命令、ストア命令、A拡張の命令のメモリアクセス中にページフォルト例外が発生していたとき、Load page fault例外、Store/AMO page fault例外を発生させます。</p>
<p>csrunitモジュールに、メモリにアクセスする命令の例外情報を監視するためのポートを作成します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.newexpt.port">リスト18.20</a></span>、<span class="listref"><a href="./24-impl-paging.html#core.veryl.newexpt.csru">リスト18.21</a></span>)。</p>
<div id="csrunit.veryl.newexpt.port" class="caption-code">
<span class="caption">リスト18.20: リスト18.20: メモリアドレス、例外の監視用のポートを追加する (csrunit.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>module csrunit (
<em class="lineno">2: </em>    ...
<em class="lineno">3: </em>    can_intr   : input   logic                   ,
<em class="lineno">4: </em>    <b>mem_addr   : input   Addr                    ,</b>
<em class="lineno">5: </em>    rdata      : output  UIntX                   ,
<em class="lineno">6: </em>    ...
<em class="lineno">7: </em>    <b>membus     : modport core_data_if::master    ,</b>
<em class="lineno">8: </em>) {
</pre>
</div>
<div id="core.veryl.newexpt.csru" class="caption-code">
<span class="caption">リスト18.21: リスト18.21: csrunitモジュールにメモリアドレスとインターフェースを割り当てる (core.veryl)</span>
<pre class="list language-csru" translate="no"><em class="lineno">1: </em>    inst csru: csrunit (
<em class="lineno">2: </em>        ...
<em class="lineno">3: </em>        <b>mem_addr   : memu_addr            ,</b>
<em class="lineno">4: </em>        ...
<em class="lineno">5: </em>        <b>membus     : d_membus             ,</b>
<em class="lineno">6: </em>    );
</pre>
</div>
<p>例外を発生させます(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.newexpt.fault">リスト18.22</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.newexpt.raise">リスト18.23</a></span>)。</p>
<div id="csrunit.veryl.newexpt.fault" class="caption-code">
<span class="caption">リスト18.22: リスト18.22: メモリアクセス中に例外が発生しているかをチェックする (csrunit.veryl)</span>
<pre class="list language-fault" translate="no"><em class="lineno">1: </em>    let expt_memory_fault    : logic = membus.rvalid &amp;&amp; membus.expt.valid;
</pre>
</div>
<div id="csrunit.veryl.newexpt.raise" class="caption-code">
<span class="caption">リスト18.23: リスト18.23: 例外を発生させる (csrunit.veryl)</span>
<pre class="list language-raise" translate="no"><em class="lineno">1: </em>    let raise_expt: logic = valid &amp;&amp; (expt_info.valid || expt_write_readonly_csr || expt_csr_priv_violation || expt_zicntr_priv || expt_trap_return_priv <b>|| expt_memory_fault</b>);
<em class="lineno">2: </em>    let expt_cause: UIntX = switch {
<em class="lineno">3: </em>        ...
<em class="lineno">4: </em>        <b>expt_memory_fault      : if ctrl.is_load ? CsrCause::LOAD_PAGE_FAULT : CsrCause::STORE_AMO_PAGE_FAULT,</b>
<em class="lineno">5: </em>        default                : 0,
<em class="lineno">6: </em>    };
</pre>
</div>
<p>xtvalに例外が発生したアドレスを設定します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.newexpt.cause">リスト18.24</a></span>)。</p>
<div id="csrunit.veryl.newexpt.cause" class="caption-code">
<span class="caption">リスト18.24: リスト18.24: 例外の原因を設定する (csrunit.veryl)</span>
<pre class="list language-cause" translate="no"><em class="lineno">1: </em>    let expt_value: UIntX = switch {
<em class="lineno">2: </em>        expt_info.valid                             : expt_info.value,
<em class="lineno">3: </em>        expt_cause == CsrCause::ILLEGAL_INSTRUCTION : {1'b0 repeat XLEN - $bits(Inst), inst_bits},
<em class="lineno">4: </em>        <b>expt_cause == CsrCause::LOAD_PAGE_FAULT     : mem_addr,</b>
<em class="lineno">5: </em>        <b>expt_cause == CsrCause::STORE_AMO_PAGE_FAULT: mem_addr,</b>
<em class="lineno">6: </em>        default                                     : 0
<em class="lineno">7: </em>    };
</pre>
</div>

<h3 class="none"><a id="h18-5-2"></a><span class="secno">18.5.2</span> ページフォルトが発生した正確なアドレスを特定する</h3>
<p>ページフォルト例外が発生したとき、xtvalにはページフォルトが発生した仮想アドレスを格納します。</p>
<p>実は現状の実装では、メモリにアクセスする操作がページの境界をまたぐとき、ページフォルトが発生した正確な仮想アドレスをxtvalに格納できていません。</p>
<p>例えば、inst_fetcherモジュールで32ビット幅の命令を2回のメモリ読み込みでフェッチするとき、1回目(下位16ビット)のロードは成功して、2回目(上位16ビット)のロードでページフォルトが発生したとします。このとき、ページフォルトが発生したアドレスは2回目のロードでアクセスしたアドレスなのに、xtvalには1回目のロードでアクセスしたアドレスが書き込まれます。</p>
<p>これに対処するために、例外が発生したアドレスのオフセットを例外情報に追加します(<span class="listref"><a href="./24-impl-paging.html#eei.veryl.exptoffset.def">リスト18.25</a></span>)。</p>
<div id="eei.veryl.exptoffset.def" class="caption-code">
<span class="caption">リスト18.25: リスト18.25: MemException型にaddr_offsetを追加する (eei.veryl)</span>
<pre class="list language-def" translate="no"><em class="lineno">1: </em>    struct MemException {
<em class="lineno">2: </em>        valid      : logic   ,
<em class="lineno">3: </em>        page_fault : logic   ,
<em class="lineno">4: </em>        <b>addr_offset: logic&lt;3&gt;,</b>
<em class="lineno">5: </em>    }
</pre>
</div>
<p>inst_fetcherモジュールで、32ビット幅の命令の上位16ビットを読み込んで<code class="inline-code" translate="no" >issue_fifo</code>に書き込むときに、オフセットを<code class="inline-code" translate="no" >2</code>に設定します(<span class="listref"><a href="./24-impl-paging.html#inst_fetcher.veryl.exptoffset.offset">リスト18.26</a></span>)。</p>
<div id="inst_fetcher.veryl.exptoffset.offset" class="caption-code">
<span class="caption">リスト18.26: リスト18.26: オフセットを2に設定する (inst_fetcher.veryl)</span>
<pre class="list language-offset" translate="no"><em class="lineno">1: </em>    if issue_is_rdata_saved {
<em class="lineno">2: </em>        issue_fifo_wvalid                 = 1;
<em class="lineno">3: </em>        issue_fifo_wdata.addr             = {issue_saved_addr[msb:3], offset};
<em class="lineno">4: </em>        issue_fifo_wdata.bits             = {rdata[15:0], issue_saved_bits};
<em class="lineno">5: </em>        issue_fifo_wdata.is_rvc           = 0;
<em class="lineno">6: </em>        <b>issue_fifo_wdata.expt.addr_offset = 2;</b>
</pre>
</div>
<p>xtvalを生成するとき、オフセットを足します(<span class="listref"><a href="./24-impl-paging.html#core.veryl.exptoffset.offset">リスト18.27</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.exptoffset.offset">リスト18.28</a></span>)。</p>
<div id="core.veryl.exptoffset.offset" class="caption-code">
<span class="caption">リスト18.27: リスト18.27: 命令アドレスにオフセットを足す (core.veryl)</span>
<pre class="list language-offset" translate="no"><em class="lineno">1: </em>    exq_wdata.expt.valid = 1;
<em class="lineno">2: </em>    exq_wdata.expt.cause = CsrCause::INSTRUCTION_PAGE_FAULT;
<em class="lineno">3: </em>    exq_wdata.expt.value = ids_pc <b>+ {1'b0 repeat XLEN - 3, i_membus.expt.addr_offset}</b>;
</pre>
</div>
<div id="csrunit.veryl.exptoffset.offset" class="caption-code">
<span class="caption">リスト18.28: リスト18.28: ロードストア命令のメモリアドレスにオフセットを足す (csrunit.veryl)</span>
<pre class="list language-offset" translate="no"><em class="lineno">1: </em>    let expt_value: UIntX = switch {
<em class="lineno">2: </em>        expt_info.valid                             : expt_info.value,
<em class="lineno">3: </em>        expt_cause == CsrCause::ILLEGAL_INSTRUCTION : {1'b0 repeat XLEN - $bits(Inst), inst_bits},
<em class="lineno">4: </em>        expt_cause == CsrCause::LOAD_PAGE_FAULT     : mem_addr <b>+ {1'b0 repeat XLEN - 3, membus.expt.addr_offset}</b>,
<em class="lineno">5: </em>        expt_cause == CsrCause::STORE_AMO_PAGE_FAULT: mem_addr <b>+ {1'b0 repeat XLEN - 3, membus.expt.addr_offset}</b>,
<em class="lineno">6: </em>        default                                     : 0
<em class="lineno">7: </em>    };
</pre>
</div>

<h2 class="numbox"><a id="h18-6"></a><span class="secno">18.6</span> satpレジスタの作成</h2>
<p>satpレジスタを実装します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.reg">リスト18.29</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.reset">リスト18.30</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.rdata">リスト18.31</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.WMASK">リスト18.32</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.wmask">リスト18.33</a></span>)。すべてのフィールドを読み書きできるように設定して、値を<code class="inline-code" translate="no" >0</code>でリセットします。</p>
<div id="csrunit.veryl.satp.reg" class="caption-code">
<span class="caption">リスト18.29: リスト18.29: satpレジスタを作成する (csrunit.veryl)</span>
<pre class="list language-reg" translate="no"><em class="lineno">1: </em>    var satp      : UIntX ;
</pre>
</div>
<div id="csrunit.veryl.satp.reset" class="caption-code">
<span class="caption">リスト18.30: リスト18.30: satpレジスタを0でリセットする (csrunit.veryl)</span>
<pre class="list language-reset" translate="no"><em class="lineno">1: </em>    satp       = 0;
</pre>
</div>
<div id="csrunit.veryl.satp.rdata" class="caption-code">
<span class="caption">リスト18.31: リスト18.31: rdataにsatpレジスタの値を設定する (csrunit.veryl)</span>
<pre class="list language-rdata" translate="no"><em class="lineno">1: </em>    CsrAddr::SATP      : satp,
</pre>
</div>
<div id="csrunit.veryl.satp.WMASK" class="caption-code">
<span class="caption">リスト18.32: リスト18.32: 書き込みマスクの定義 (csrunit.veryl)</span>
<pre class="list language-WMASK" translate="no"><em class="lineno">1: </em>    const SATP_WMASK      : UIntX = 'hffff_ffff_ffff_ffff;
</pre>
</div>
<div id="csrunit.veryl.satp.wmask" class="caption-code">
<span class="caption">リスト18.33: リスト18.33: wmaskに書き込みマスクを設定する (csrunit.veryl)</span>
<pre class="list language-wmask" translate="no"><em class="lineno">1: </em>    CsrAddr::SATP      : SATP_WMASK,
</pre>
</div>
<p>satpレジスタは、MODEフィールドに書き込もうとしている値がサポートしないMODEなら、satpレジスタの変更を全ビットについて無視すると定められています。</p>
<p>本章ではBareとSv39だけをサポートするため、MODEには<code class="inline-code" translate="no" >0</code>と<code class="inline-code" translate="no" >8</code>のみ書き込めるようにして、それ以外の値を書き込もうとしたらsatpレジスタへの書き込みを無視します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.validate">リスト18.34</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.satp.write">リスト18.35</a></span>)。</p>
<div id="csrunit.veryl.satp.validate" class="caption-code">
<span class="caption">リスト18.34: リスト18.34: satに書き込む値を生成する関数 (csrunit.veryl)</span>
<pre class="list language-validate" translate="no"><em class="lineno">1: </em>    function validate_satp (
<em class="lineno">2: </em>        satp : input UIntX,
<em class="lineno">3: </em>        wdata: input UIntX,
<em class="lineno">4: </em>    ) -&gt; UIntX {
<em class="lineno">5: </em>        // mode
<em class="lineno">6: </em>        if wdata[msb-:4] != 0 &amp;&amp; wdata[msb-:4] != 8 {
<em class="lineno">7: </em>            return satp;
<em class="lineno">8: </em>        }
<em class="lineno">9: </em>        return wdata;
<em class="lineno">10: </em>    }
</pre>
</div>
<div id="csrunit.veryl.satp.write" class="caption-code">
<span class="caption">リスト18.35: リスト18.35: satpレジスタに書き込む (csrunit.veryl)</span>
<pre class="list language-write" translate="no"><em class="lineno">1: </em>    CsrAddr::SATP      : satp       = validate_satp(satp, wdata);
</pre>
</div>

<h2 class="numbox"><a id="h18-7"></a><span class="secno">18.7</span> mstatusのMXR、SUM、MPRVビットの実装</h2>
<p>mstatusレジスタのMXR、SUM、MPRVビットを変更できるようにします(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.mstatuses.WMASK_mstatus">リスト18.36</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.mstatuses.WMASK_sstatus">リスト18.37</a></span>)。</p>
<div id="csrunit.veryl.mstatuses.WMASK_mstatus" class="caption-code">
<span class="caption">リスト18.36: リスト18.36: 書き込みマスクの変更 (csrunit.veryl)</span>
<pre class="list language-WMASK_mstatus" translate="no"><em class="lineno">1: </em>    const MSTATUS_WMASK   : UIntX = 'h0000_0000_006<b>e</b>_19aa as UIntX;
</pre>
</div>
<div id="csrunit.veryl.mstatuses.WMASK_sstatus" class="caption-code">
<span class="caption">リスト18.37: リスト18.37: 書き込みマスクの変更 (csrunit.veryl)</span>
<pre class="list language-WMASK_sstatus" translate="no"><em class="lineno">1: </em>    const SSTATUS_WMASK   : UIntX = 'h0000_0000_000<b>c</b>_0122 as UIntX;
</pre>
</div>
<p>それぞれのビットを示す変数を作成します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.mstatuses.reg">リスト18.38</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.mstatuses.mprv">リスト18.39</a></span>)。</p>
<div id="csrunit.veryl.mstatuses.reg" class="caption-code">
<span class="caption">リスト18.38: リスト18.38: mstatusのMXR、SUM、MPRVビットを示す変数を作成する (csrunit.veryl)</span>
<pre class="list language-reg" translate="no"><em class="lineno">1: </em>    let mstatus_mxr : logic    = mstatus[19];
<em class="lineno">2: </em>    let mstatus_sum : logic    = mstatus[18];
<em class="lineno">3: </em>    let mstatus_mprv: logic    = mstatus[17];
</pre>
</div>
<p>mstatus.MPRVは、M-mode以外のモードに戻るときに<code class="inline-code" translate="no" >0</code>に設定されると定められています。そのため、<code class="inline-code" translate="no" >trap_mode_next</code>を確認して<code class="inline-code" translate="no" >0</code>を設定します。</p>
<div id="csrunit.veryl.mstatuses.mprv" class="caption-code">
<span class="caption">リスト18.39: リスト18.39: mstatus.MPRVをMRET、SRET命令で0に設定する (csrunit.veryl)</span>
<pre class="list language-mprv" translate="no"><em class="lineno">1: </em>    } else if trap_return {
<em class="lineno">2: </em>        <b>// set mstatus.mprv = 0 when new mode != M-mode</b>
<em class="lineno">3: </em>        <b>if trap_mode_next &lt;: PrivMode::M {</b>
<em class="lineno">4: </em>        <b>    mstatus[17] = 0;</b>
<em class="lineno">5: </em>        <b>}</b>
<em class="lineno">6: </em>        if is_mret {
</pre>
</div>

<h2 class="numbox"><a id="h18-8"></a><span class="secno">18.8</span> アドレス変換モジュール(PTW)の実装</h2>
<p>ページテーブルエントリをフェッチしてアドレス変換を行うptwモジュールを作成します。まず、MODEがBareのとき(仮想アドレス = 物理アドレス)の動作を実装し、Sv39を「<a href="24-impl-paging.html#h18-9">18.9 Sv39の実装</a>」で実装します。</p>

<h3 class="none"><a id="h18-8-1"></a><span class="secno">18.8.1</span> CSRのインターフェースを実装する</h3>
<p>ページングで使用するCSRを、csrunitモジュールからptwモジュールに渡すためのインターフェースを定義します。</p>
<p><code class="inline-code" translate="no" >src/ptw_ctrl_if.veryl</code>を作成し、次のように記述します(<span class="listref"><a href="./24-impl-paging.html#ptw_ctrl_if.veryl.empty">リスト18.40</a></span>)。</p>
<div id="ptw_ctrl_if.veryl.empty" class="caption-code">
<span class="caption">リスト18.40: リスト18.40: ptw_ctrl_if.veryl</span>
<pre class="list language-empty" translate="no"><em class="lineno">1: </em>import eei::*;
<em class="lineno">2: </em>
<em class="lineno">3: </em>interface ptw_ctrl_if {
<em class="lineno">4: </em>    var priv: PrivMode;
<em class="lineno">5: </em>    var satp: UIntX   ;
<em class="lineno">6: </em>    var mxr : logic   ;
<em class="lineno">7: </em>    var sum : logic   ;
<em class="lineno">8: </em>    var mprv: logic   ;
<em class="lineno">9: </em>    var mpp : PrivMode;
<em class="lineno">10: </em>
<em class="lineno">11: </em>    modport master {
<em class="lineno">12: </em>        priv: output,
<em class="lineno">13: </em>        satp: output,
<em class="lineno">14: </em>        mxr : output,
<em class="lineno">15: </em>        sum : output,
<em class="lineno">16: </em>        mprv: output,
<em class="lineno">17: </em>        mpp : output,
<em class="lineno">18: </em>    }
<em class="lineno">19: </em>
<em class="lineno">20: </em>    modport slave {
<em class="lineno">21: </em>        is_enabled: import,
<em class="lineno">22: </em>        ..converse(master)
<em class="lineno">23: </em>    }
<em class="lineno">24: </em>
<em class="lineno">25: </em>    function is_enabled (
<em class="lineno">26: </em>        is_inst: input logic,
<em class="lineno">27: </em>    ) -&gt; logic {
<em class="lineno">28: </em>        if satp[msb-:4] == 0 {
<em class="lineno">29: </em>            return 0;
<em class="lineno">30: </em>        }
<em class="lineno">31: </em>        if is_inst {
<em class="lineno">32: </em>            return priv &lt;= PrivMode::S;
<em class="lineno">33: </em>        } else {
<em class="lineno">34: </em>            return (if mprv ? mpp : priv) &lt;= PrivMode::S;
<em class="lineno">35: </em>        }
<em class="lineno">36: </em>    }
<em class="lineno">37: </em>}
</pre>
</div>
<p>is_enabledは、CSRとアクセス目的からページングがページングが有効かどうかを判定する関数です。Bareかどうかを判定した後に、命令フェッチかどうか(<code class="inline-code" translate="no" >is_inst</code>)によって分岐しています。命令フェッチのときはS-mode以下の特権レベルのときにページングが有効になります。ロードストアのとき、mstatus.MPRVが<code class="inline-code" translate="no" >1</code>ならmstatus.MPP、<code class="inline-code" translate="no" >0</code>なら現在の特権レベルがS-mode以下ならページングが有効になります。</p>

<h3 class="none"><a id="h18-8-2"></a><span class="secno">18.8.2</span> Bareだけに対応するアドレス変換モジュールを実装する</h3>
<p><code class="inline-code" translate="no" >src/ptw.veryl</code>を作成し、次のようなポートを記述します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.port">リスト18.41</a></span>)。</p>
<div id="ptw.veryl.empty.port" class="caption-code">
<span class="caption">リスト18.41: リスト18.41: ポートの定義 (ptw.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>import eei::*;
<em class="lineno">2: </em>
<em class="lineno">3: </em>module ptw (
<em class="lineno">4: </em>    clk    : input   clock             ,
<em class="lineno">5: </em>    rst    : input   reset             ,
<em class="lineno">6: </em>    is_inst: input   logic             ,
<em class="lineno">7: </em>    slave  : modport Membus::slave     ,
<em class="lineno">8: </em>    master : modport Membus::master    ,
<em class="lineno">9: </em>    ctrl   : modport ptw_ctrl_if::slave,
<em class="lineno">10: </em>) {
</pre>
</div>
<p><code class="inline-code" translate="no" >slave</code>はcoreモジュール側からの仮想アドレスによる要求を受け付けるためのインターフェースです。<code class="inline-code" translate="no" >master</code>はmmio_conterollerモジュール側に物理アドレスによるアクセスを行うためのインターフェースです。</p>
<p><code class="inline-code" translate="no" >is_inst</code>を使い、ページングが有効かどうか判定します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.paging_enabled">リスト18.42</a></span>)。</p>
<div id="ptw.veryl.empty.paging_enabled" class="caption-code">
<span class="caption">リスト18.42: リスト18.42: ページングが有効かどうかを判定する (ptw.veryl)</span>
<pre class="list language-paging_enabled" translate="no"><em class="lineno">1: </em>    let paging_enabled: logic = ctrl.is_enabled(is_inst);
</pre>
</div>
<p>状態の管理のために<code class="inline-code" translate="no" >State</code>型を定義します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.state">リスト18.43</a></span>)。</p>
<div id="ptw.veryl.empty.state" class="caption-code">
<span class="caption">リスト18.43: リスト18.43: 状態の定義 (ptw.veryl)</span>
<pre class="list language-state" translate="no"><em class="lineno">1: </em>    enum State {
<em class="lineno">2: </em>        IDLE,
<em class="lineno">3: </em>        EXECUTE_READY,
<em class="lineno">4: </em>        EXECUTE_VALID,
<em class="lineno">5: </em>    }
<em class="lineno">6: </em>
<em class="lineno">7: </em>    var state: State;
</pre>
</div>
<dl>
<dt><code class="inline-code" translate="no" >State::IDLE</code></dt>
<dd>
    <code class="inline-code" translate="no" >slave</code>から要求を受け付け、<code class="inline-code" translate="no" >master</code>に物理アドレスでアクセスします。
    <code class="inline-code" translate="no" >master</code>の<code class="inline-code" translate="no" >ready</code>が<code class="inline-code" translate="no" >1</code>なら<code class="inline-code" translate="no" >State::EXECUTE_VALID</code>、
    <code class="inline-code" translate="no" >0</code>なら<code class="inline-code" translate="no" >EXECUTE_READY</code>に状態を移動します。
</dd>
<dt><code class="inline-code" translate="no" >State::EXECUTE_READY</code></dt>
<dd>
    <code class="inline-code" translate="no" >master</code>に物理アドレスでメモリアクセスを要求し続けます。
    <code class="inline-code" translate="no" >master</code>の<code class="inline-code" translate="no" >ready</code>が<code class="inline-code" translate="no" >1</code>なら状態を<code class="inline-code" translate="no" >State::EXECUTE_VALID</code>に移動します。
</dd>
<dt><code class="inline-code" translate="no" >State::EXECUTE_VALID</code></dt>
<dd>
    <code class="inline-code" translate="no" >master</code>からの結果を待ちます。
    <code class="inline-code" translate="no" >master</code>の<code class="inline-code" translate="no" >rvalid</code>が<code class="inline-code" translate="no" >1</code>のとき、
    <code class="inline-code" translate="no" >State::IDLE</code>と同じように<code class="inline-code" translate="no" >slave</code>からの要求を受け付けます。
    <code class="inline-code" translate="no" >slave</code>が何も要求していないなら、状態を<code class="inline-code" translate="no" >State::IDLE</code>に移動します。
</dd>
</dl>
<p><code class="inline-code" translate="no" >slave</code>からの要求を保存しておくためのインターフェースをインスタンス化します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.save">リスト18.44</a></span>)。</p>
<div id="ptw.veryl.empty.save" class="caption-code">
<span class="caption">リスト18.44: リスト18.44: slaveを保存するためのインターフェースをインスタンス化する (ptw.veryl)</span>
<pre class="list language-save" translate="no"><em class="lineno">1: </em>    inst slave_saved: Membus;
</pre>
</div>
<p>状態に基づいて、<code class="inline-code" translate="no" >master</code>に要求を割り当てます(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.phy">リスト18.45</a></span>、<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.assign_master">リスト18.46</a></span>)。<code class="inline-code" translate="no" >State::EXECUTE_READY</code>で<code class="inline-code" translate="no" >master</code>に要求を割り当てるとき、<code class="inline-code" translate="no" >physical_addr</code>レジスタの値をアドレスに割り当てるようにします。</p>
<div id="ptw.veryl.empty.phy" class="caption-code">
<span class="caption">リスト18.45: リスト18.45: 物理アドレスを保存するためのレジスタを作成する (ptw.veryl)</span>
<pre class="list language-phy" translate="no"><em class="lineno">1: </em>    var physical_addr: Addr;
</pre>
</div>
<div id="ptw.veryl.empty.assign_master" class="caption-code">
<span class="caption">リスト18.46: リスト18.46: masterに要求を割り当てる (ptw.veryl)</span>
<pre class="list language-assign_master" translate="no"><em class="lineno">1: </em>    function assign_master (
<em class="lineno">2: </em>        addr : input Addr                        ,
<em class="lineno">3: </em>        wen  : input logic                       ,
<em class="lineno">4: </em>        wdata: input logic&lt;MEMBUS_DATA_WIDTH&gt;    ,
<em class="lineno">5: </em>        wmask: input logic&lt;MEMBUS_DATA_WIDTH / 8&gt;,
<em class="lineno">6: </em>    ) {
<em class="lineno">7: </em>        master.valid = 1;
<em class="lineno">8: </em>        master.addr  = addr;
<em class="lineno">9: </em>        master.wen   = wen;
<em class="lineno">10: </em>        master.wdata = wdata;
<em class="lineno">11: </em>        master.wmask = wmask;
<em class="lineno">12: </em>    }
<em class="lineno">13: </em>
<em class="lineno">14: </em>    function accept_request_comb () {
<em class="lineno">15: </em>        if slave.ready &amp;&amp; slave.valid &amp;&amp; !paging_enabled {
<em class="lineno">16: </em>            assign_master(slave.addr, slave.wen, slave.wdata, slave.wmask);
<em class="lineno">17: </em>        }
<em class="lineno">18: </em>    }
<em class="lineno">19: </em>
<em class="lineno">20: </em>    always_comb {
<em class="lineno">21: </em>        master.valid = 0;
<em class="lineno">22: </em>        master.addr  = 0;
<em class="lineno">23: </em>        master.wen   = 0;
<em class="lineno">24: </em>        master.wdata = 0;
<em class="lineno">25: </em>        master.wmask = 0;
<em class="lineno">26: </em>
<em class="lineno">27: </em>        case state {
<em class="lineno">28: </em>            State::IDLE         : accept_request_comb();
<em class="lineno">29: </em>            State::EXECUTE_READY: assign_master      (physical_addr, slave_saved.wen, slave_saved.wdata, slave_saved.wmask);
<em class="lineno">30: </em>            State::EXECUTE_VALID: if master.rvalid {
<em class="lineno">31: </em>                accept_request_comb();
<em class="lineno">32: </em>            }
<em class="lineno">33: </em>            default: {}
<em class="lineno">34: </em>        }
<em class="lineno">35: </em>    }
</pre>
</div>
<p>状態に基づいて、<code class="inline-code" translate="no" >ready</code>と結果を<code class="inline-code" translate="no" >slave</code>に割り当てます(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.assign_slave">リスト18.47</a></span>)。</p>
<div id="ptw.veryl.empty.assign_slave" class="caption-code">
<span class="caption">リスト18.47: リスト18.47: slaveに結果を割り当てる (ptw.veryl)</span>
<pre class="list language-assign_slave" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        slave.ready  = 0;
<em class="lineno">3: </em>        slave.rvalid = 0;
<em class="lineno">4: </em>        slave.rdata  = 0;
<em class="lineno">5: </em>        slave.expt   = 0;
<em class="lineno">6: </em>
<em class="lineno">7: </em>        case state {
<em class="lineno">8: </em>            State::IDLE         : slave.ready = 1;
<em class="lineno">9: </em>            State::EXECUTE_VALID: {
<em class="lineno">10: </em>                slave.ready  = master.rvalid;
<em class="lineno">11: </em>                slave.rvalid = master.rvalid;
<em class="lineno">12: </em>                slave.rdata  = master.rdata;
<em class="lineno">13: </em>                slave.expt   = master.expt;
<em class="lineno">14: </em>            }
<em class="lineno">15: </em>            default: {}
<em class="lineno">16: </em>        }
<em class="lineno">17: </em>    }
</pre>
</div>
<p>状態を遷移する処理を記述します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.empty.ff">リスト18.48</a></span>)。要求を受け入れるとき、<code class="inline-code" translate="no" >slave_saved</code>に要求を保存します。</p>
<div id="ptw.veryl.empty.ff" class="caption-code">
<span class="caption">リスト18.48: リスト18.48: 状態を遷移する (ptw.veryl)</span>
<pre class="list language-ff" translate="no"><em class="lineno">1: </em>    function accept_request_ff () {
<em class="lineno">2: </em>        slave_saved.valid = slave.ready &amp;&amp; slave.valid;
<em class="lineno">3: </em>        if slave.ready &amp;&amp; slave.valid {
<em class="lineno">4: </em>            slave_saved.addr  = slave.addr;
<em class="lineno">5: </em>            slave_saved.wen   = slave.wen;
<em class="lineno">6: </em>            slave_saved.wdata = slave.wdata;
<em class="lineno">7: </em>            slave_saved.wmask = slave.wmask;
<em class="lineno">8: </em>            if paging_enabled {
<em class="lineno">9: </em>                // TODO
<em class="lineno">10: </em>            } else {
<em class="lineno">11: </em>                state         = if master.ready ? State::EXECUTE_VALID : State::EXECUTE_READY;
<em class="lineno">12: </em>                physical_addr = slave.addr;
<em class="lineno">13: </em>            }
<em class="lineno">14: </em>        } else {
<em class="lineno">15: </em>            state = State::IDLE;
<em class="lineno">16: </em>        }
<em class="lineno">17: </em>    }
<em class="lineno">18: </em>
<em class="lineno">19: </em>    function on_clock () {
<em class="lineno">20: </em>        case state {
<em class="lineno">21: </em>            State::IDLE         : accept_request_ff();
<em class="lineno">22: </em>            State::EXECUTE_READY: if master.ready {
<em class="lineno">23: </em>                state = State::EXECUTE_VALID;
<em class="lineno">24: </em>            }
<em class="lineno">25: </em>            State::EXECUTE_VALID: if master.rvalid {
<em class="lineno">26: </em>                accept_request_ff();
<em class="lineno">27: </em>            }
<em class="lineno">28: </em>            default: {}
<em class="lineno">29: </em>        }
<em class="lineno">30: </em>    }
<em class="lineno">31: </em>
<em class="lineno">32: </em>    function on_reset () {
<em class="lineno">33: </em>        state             = State::IDLE;
<em class="lineno">34: </em>        physical_addr     = 0;
<em class="lineno">35: </em>        slave_saved.valid = 0;
<em class="lineno">36: </em>        slave_saved.addr  = 0;
<em class="lineno">37: </em>        slave_saved.wen   = 0;
<em class="lineno">38: </em>        slave_saved.wdata = 0;
<em class="lineno">39: </em>        slave_saved.wmask = 0;
<em class="lineno">40: </em>    }
<em class="lineno">41: </em>
<em class="lineno">42: </em>    always_ff {
<em class="lineno">43: </em>        if_reset {
<em class="lineno">44: </em>            on_reset();
<em class="lineno">45: </em>        } else {
<em class="lineno">46: </em>            on_clock();
<em class="lineno">47: </em>        }
<em class="lineno">48: </em>    }
</pre>
</div>

<h3 class="none"><a id="h18-8-3"></a><span class="secno">18.8.3</span> ptwモジュールをインスタンス化する</h3>
<p>topモジュールで、ptwモジュールをインスタンス化します。</p>
<p>ptwモジュールはmmio_controllerモジュールの前で仮想アドレスを物理アドレスに変換するモジュールです。ptwモジュールとmmio_controllerモジュールの間のインターフェースを作成します(<span class="listref"><a href="./24-impl-paging.html#top.veryl.empty.intr">リスト18.49</a></span>)。</p>
<div id="top.veryl.empty.intr" class="caption-code">
<span class="caption">リスト18.49: リスト18.49: ptwモジュールとmmio_controllerモジュールの間のインターフェースを作成する (top.veryl)</span>
<pre class="list language-intr" translate="no"><em class="lineno">1: </em>    inst ptw_membus     : Membus;
</pre>
</div>
<p>調停処理をptwモジュール向けのものに変更します(<span class="listref"><a href="./24-impl-paging.html#top.veryl.empty.arb">リスト18.50</a></span>)。</p>
<div id="top.veryl.empty.arb" class="caption-code">
<span class="caption">リスト18.50: リスト18.50: 調停処理をptwモジュール向けのものに変更する (top.veryl)</span>
<pre class="list language-arb" translate="no"><em class="lineno">1: </em>    always_ff {
<em class="lineno">2: </em>        if_reset {
<em class="lineno">3: </em>            memarb_last_i = 0;
<em class="lineno">4: </em>        } else {
<em class="lineno">5: </em>            if <b>ptw</b>_membus.ready {
<em class="lineno">6: </em>                memarb_last_i = !d_membus.valid;
<em class="lineno">7: </em>            }
<em class="lineno">8: </em>        }
<em class="lineno">9: </em>    }
<em class="lineno">10: </em>
<em class="lineno">11: </em>    always_comb {
<em class="lineno">12: </em>        i_membus.ready  = <b>ptw</b>_membus.ready &amp;&amp; !d_membus.valid;
<em class="lineno">13: </em>        i_membus.rvalid = <b>ptw</b>_membus.rvalid &amp;&amp; memarb_last_i;
<em class="lineno">14: </em>        i_membus.rdata  = <b>ptw</b>_membus.rdata;
<em class="lineno">15: </em>        i_membus.expt   = <b>ptw</b>_membus.expt;
<em class="lineno">16: </em>
<em class="lineno">17: </em>        d_membus.ready  = <b>ptw</b>_membus.ready;
<em class="lineno">18: </em>        d_membus.rvalid = <b>ptw</b>_membus.rvalid &amp;&amp; !memarb_last_i;
<em class="lineno">19: </em>        d_membus.rdata  = <b>ptw</b>_membus.rdata;
<em class="lineno">20: </em>        d_membus.expt   = <b>ptw</b>_membus.expt;
<em class="lineno">21: </em>
<em class="lineno">22: </em>        <b>ptw</b>_membus.valid = i_membus.valid | d_membus.valid;
<em class="lineno">23: </em>        if d_membus.valid {
<em class="lineno">24: </em>            <b>ptw</b>_membus.addr  = d_membus.addr;
<em class="lineno">25: </em>            <b>ptw</b>_membus.wen   = d_membus.wen;
<em class="lineno">26: </em>            <b>ptw</b>_membus.wdata = d_membus.wdata;
<em class="lineno">27: </em>            <b>ptw</b>_membus.wmask = d_membus.wmask;
<em class="lineno">28: </em>        } else {
<em class="lineno">29: </em>            <b>ptw</b>_membus.addr  = i_membus.addr;
<em class="lineno">30: </em>            <b>ptw</b>_membus.wen   = 0; // 命令フェッチは常に読み込み
<em class="lineno">31: </em>            <b>ptw</b>_membus.wdata = 'x;
<em class="lineno">32: </em>            <b>ptw</b>_membus.wmask = 'x;
<em class="lineno">33: </em>        }
<em class="lineno">34: </em>    }
</pre>
</div>
<p>今処理している要求、または今のクロックから処理し始める要求が命令フェッチによるものか判定する変数を作成します(<span class="listref"><a href="./24-impl-paging.html#top.veryl.empty.is_inst">リスト18.51</a></span>)。</p>
<div id="top.veryl.empty.is_inst" class="caption-code">
<span class="caption">リスト18.51: リスト18.51: ptwモジュールが処理する要求が命令フェッチによるものかを判定する (top.veryl)</span>
<pre class="list language-is_inst" translate="no"><em class="lineno">1: </em>    let ptw_is_inst  : logic = (i_membus.ready &amp;&amp; i_membus.valid) || // inst ack or
<em class="lineno">2: </em>     !(d_membus.ready &amp;&amp; d_membus.valid) &amp;&amp; memarb_last_i; // data not ack &amp; last ack is inst
</pre>
</div>
<p>ptwモジュールをインスタンス化します(<span class="listref"><a href="./24-impl-paging.html#top.veryl.empty.ptw">リスト18.52</a></span>)。</p>
<div id="top.veryl.empty.ptw" class="caption-code">
<span class="caption">リスト18.52: リスト18.52: ptwモジュールをインスタンス化する (top.veryl)</span>
<pre class="list language-ptw" translate="no"><em class="lineno">1: </em>    inst ptw_ctrl: ptw_ctrl_if;
<em class="lineno">2: </em>    inst paging_unit: ptw (
<em class="lineno">3: </em>        clk                 ,
<em class="lineno">4: </em>        rst                 ,
<em class="lineno">5: </em>        is_inst: ptw_is_inst,
<em class="lineno">6: </em>        slave  : ptw_membus ,
<em class="lineno">7: </em>        master : mmio_membus,
<em class="lineno">8: </em>        ctrl   : ptw_ctrl   ,
<em class="lineno">9: </em>    );
</pre>
</div>
<p>csrunitモジュールとptwモジュールを<code class="inline-code" translate="no" >ptw_ctrl_if</code>インターフェースで接続するために、coreモジュールにポートを追加します(<span class="listref"><a href="./24-impl-paging.html#core.veryl.empty.port">リスト18.53</a></span>、<span class="listref"><a href="./24-impl-paging.html#top.veryl.empty.core">リスト18.54</a></span>)。</p>
<div id="core.veryl.empty.port" class="caption-code">
<span class="caption">リスト18.53: リスト18.53: coreモジュールにptw_ctrl_ifインターフェースを追加する (core.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>module core (
<em class="lineno">2: </em>    clk     : input   clock               ,
<em class="lineno">3: </em>    rst     : input   reset               ,
<em class="lineno">4: </em>    i_membus: modport core_inst_if::master,
<em class="lineno">5: </em>    d_membus: modport core_data_if::master,
<em class="lineno">6: </em>    led     : output  UIntX               ,
<em class="lineno">7: </em>    aclint  : modport aclint_if::slave    ,
<em class="lineno">8: </em>    <b>ptw_ctrl: modport ptw_ctrl_if::master ,</b>
<em class="lineno">9: </em>) {
</pre>
</div>
<div id="top.veryl.empty.core" class="caption-code">
<span class="caption">リスト18.54: リスト18.54: ptw_ctrl_ifインターフェースを割り当てる (top.veryl)</span>
<pre class="list language-core" translate="no"><em class="lineno">1: </em>    inst c: core (
<em class="lineno">2: </em>        clk                      ,
<em class="lineno">3: </em>        rst                      ,
<em class="lineno">4: </em>        i_membus: i_membus_core  ,
<em class="lineno">5: </em>        d_membus: d_membus_core  ,
<em class="lineno">6: </em>        led                      ,
<em class="lineno">7: </em>        aclint  : aclint_core_bus,
<em class="lineno">8: </em>        <b>ptw_ctrl                 ,</b>
<em class="lineno">9: </em>    );
</pre>
</div>
<p>csrunitモジュールにポートを追加し、CSRを割り当てます(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.empty.port">リスト18.55</a></span>、<span class="listref"><a href="./24-impl-paging.html#core.veryl.empty.csru">リスト18.56</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.empty.assign">リスト18.57</a></span>)。</p>
<div id="csrunit.veryl.empty.port" class="caption-code">
<span class="caption">リスト18.55: リスト18.55: csunitモジュールにptw_ctrl_ifインターフェースを追加する (csrunit.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em>    membus     : modport core_data_if::master    ,
<em class="lineno">2: </em>    <b>ptw_ctrl   : modport ptw_ctrl_if::master     ,</b>
<em class="lineno">3: </em>) {
</pre>
</div>
<div id="core.veryl.empty.csru" class="caption-code">
<span class="caption">リスト18.56: リスト18.56: csrunitモジュールのインスタンスにptw_ctrl_ifインターフェースを割り当てる (core.veryl)</span>
<pre class="list language-csru" translate="no"><em class="lineno">1: </em>        membus     : d_membus             ,
<em class="lineno">2: </em>        <b>ptw_ctrl                          ,</b>
<em class="lineno">3: </em>    );
</pre>
</div>
<div id="csrunit.veryl.empty.assign" class="caption-code">
<span class="caption">リスト18.57: リスト18.57: インターフェースにCSRの値を割り当てる (csrunit.veryl)</span>
<pre class="list language-assign" translate="no"><em class="lineno">1: </em>    always_comb {
<em class="lineno">2: </em>        ptw_ctrl.priv = mode;
<em class="lineno">3: </em>        ptw_ctrl.satp = satp;
<em class="lineno">4: </em>        ptw_ctrl.mxr  = mstatus_mxr;
<em class="lineno">5: </em>        ptw_ctrl.sum  = mstatus_sum;
<em class="lineno">6: </em>        ptw_ctrl.mprv = mstatus_mprv;
<em class="lineno">7: </em>        ptw_ctrl.mpp  = mstatus_mpp;
<em class="lineno">8: </em>    }
</pre>
</div>

<h2 id="impl-sv39" class="numbox"><a id="h18-9"></a><span class="secno">18.9</span> Sv39の実装</h2>
<p>ptwモジュールに、Sv39を実装します。ここで定義する関数は、コメントと「<a href="24-impl-paging.html#h18-3">18.3 Sv39のアドレス変換</a>」を参考に動作を確認してください。</p>

<h3 id="define_const" class="none"><a id="h18-9-1"></a><span class="secno">18.9.1</span> 定数の定義</h3>
<p>ptwモジュールで使用する定数と関数を実装します。</p>
<p><code class="inline-code" translate="no" >src/sv39util.veryl</code>を作成し、次のように記述します(<span class="listref"><a href="./24-impl-paging.html#sv39util.veryl.sv39">リスト18.58</a></span>)。定数は「<a href="24-impl-paging.html#h18-3">18.3 Sv39のアドレス変換</a>」で使用しているものと同じです。</p>
<div id="sv39util.veryl.sv39" class="caption-code">
<span class="caption">リスト18.58: リスト18.58: sv39util.veryl</span>
<pre class="list language-sv39" translate="no"><em class="lineno">1: </em>import eei::*;
<em class="lineno">2: </em>package sv39util {
<em class="lineno">3: </em>    const PAGESIZE: u32      = 12;
<em class="lineno">4: </em>    const PTESIZE : u32      = 8;
<em class="lineno">5: </em>    const LEVELS  : logic&lt;2&gt; = 3;
<em class="lineno">6: </em>
<em class="lineno">7: </em>    type Level = logic&lt;2&gt;;
<em class="lineno">8: </em>
<em class="lineno">9: </em>    // 有効な仮想アドレスか判定する
<em class="lineno">10: </em>    function is_valid_vaddr (
<em class="lineno">11: </em>        va: input Addr,
<em class="lineno">12: </em>    ) -&gt; logic {
<em class="lineno">13: </em>        let hiaddr: logic&lt;26&gt; = va[msb:38];
<em class="lineno">14: </em>        return &amp;hiaddr || &amp;~hiaddr;
<em class="lineno">15: </em>    }
<em class="lineno">16: </em>
<em class="lineno">17: </em>    // 仮想アドレスのVPN[level]フィールドを取得する
<em class="lineno">18: </em>    function vpn (
<em class="lineno">19: </em>        va   : input Addr ,
<em class="lineno">20: </em>        level: input Level,
<em class="lineno">21: </em>    ) -&gt; logic&lt;9&gt; {
<em class="lineno">22: </em>        return case level {
<em class="lineno">23: </em>            0      : va[20:12],
<em class="lineno">24: </em>            1      : va[29:21],
<em class="lineno">25: </em>            2      : va[38:30],
<em class="lineno">26: </em>            default: 0,
<em class="lineno">27: </em>        };
<em class="lineno">28: </em>    }
<em class="lineno">29: </em>
<em class="lineno">30: </em>    // 最初にフェッチするPTEのアドレスを取得する
<em class="lineno">31: </em>    function get_first_pte_address (
<em class="lineno">32: </em>        satp: input UIntX,
<em class="lineno">33: </em>        va  : input Addr ,
<em class="lineno">34: </em>    ) -&gt; Addr {
<em class="lineno">35: </em>        return {
<em class="lineno">36: </em>            1'b0 repeat XLEN - 44 - PAGESIZE,
<em class="lineno">37: </em>            satp[43:0],
<em class="lineno">38: </em>            vpn(va, 2),
<em class="lineno">39: </em>            1'b0 repeat $clog2(PTESIZE)
<em class="lineno">40: </em>        };
<em class="lineno">41: </em>    }
<em class="lineno">42: </em>}
</pre>
</div>

<h3 id="define_PTE" class="none"><a id="h18-9-2"></a><span class="secno">18.9.2</span> PTEの定義</h3>
<p>Sv39のPTEのビットを分かりやすく取得するために、次のインターフェースを定義します。</p>
<p><code class="inline-code" translate="no" >src/pte.veryl</code>を作成し、次のように記述します(<span class="listref"><a href="./24-impl-paging.html#pte.veryl.sv39.bits">リスト18.59</a></span>)。</p>
<div id="pte.veryl.sv39.bits" class="caption-code">
<span class="caption">リスト18.59: リスト18.59: pte.veryl</span>
<pre class="list language-bits" translate="no"><em class="lineno">1: </em>import eei::*;
<em class="lineno">2: </em>import sv39util::*;
<em class="lineno">3: </em>
<em class="lineno">4: </em>interface PTE39 {
<em class="lineno">5: </em>    var value: UIntX;
<em class="lineno">6: </em>
<em class="lineno">7: </em>    function v () -&gt; logic { return value[0]; }
<em class="lineno">8: </em>    function r () -&gt; logic { return value[1]; }
<em class="lineno">9: </em>    function w () -&gt; logic { return value[2]; }
<em class="lineno">10: </em>    function x () -&gt; logic { return value[3]; }
<em class="lineno">11: </em>    function u () -&gt; logic { return value[4]; }
<em class="lineno">12: </em>    function a () -&gt; logic { return value[6]; }
<em class="lineno">13: </em>    function d () -&gt; logic { return value[7]; }
<em class="lineno">14: </em>
<em class="lineno">15: </em>    function reserved -&gt; logic&lt;10&gt; { return value[63:54]; }
<em class="lineno">16: </em>
<em class="lineno">17: </em>    function ppn2 () -&gt; logic&lt;26&gt; { return value[53:28]; }
<em class="lineno">18: </em>    function ppn1 () -&gt; logic&lt;9&gt; { return value[27:19]; }
<em class="lineno">19: </em>    function ppn0 () -&gt; logic&lt;9&gt; { return value[18:10]; }
<em class="lineno">20: </em>    function ppn  () -&gt; logic&lt;44&gt; { return value[53:10]; }
<em class="lineno">21: </em>}
</pre>
</div>
<p>PTEの値を使った関数を定義します(<span class="listref"><a href="./24-impl-paging.html#pte.veryl.sv39.func">リスト18.60</a></span>)。</p>
<div id="pte.veryl.sv39.func" class="caption-code">
<span class="caption">リスト18.60: リスト18.60: PTEの値を使った関数を定義する (pte.veryl)</span>
<pre class="list language-func" translate="no"><em class="lineno">1: </em>    // leaf PTEか判定する
<em class="lineno">2: </em>    function is_leaf () -&gt; logic { return r() || x(); }
<em class="lineno">3: </em>
<em class="lineno">4: </em>    // leaf PTEのとき、PPNがページサイズに整列されているかどうかを判定する
<em class="lineno">5: </em>    function is_ppn_aligned (
<em class="lineno">6: </em>        level: input Level,
<em class="lineno">7: </em>    ) -&gt; logic {
<em class="lineno">8: </em>        return case level {
<em class="lineno">9: </em>            0      : 1,
<em class="lineno">10: </em>            1      : ppn0() == 0,
<em class="lineno">11: </em>            2      : ppn1() == 0 &amp;&amp; ppn0() == 0,
<em class="lineno">12: </em>            default: 1,
<em class="lineno">13: </em>        };
<em class="lineno">14: </em>    }
<em class="lineno">15: </em>
<em class="lineno">16: </em>    // 有効なPTEか判定する
<em class="lineno">17: </em>    function is_valid (
<em class="lineno">18: </em>        level: input Level,
<em class="lineno">19: </em>    ) -&gt; logic {
<em class="lineno">20: </em>        if !v() || reserved() != 0 || !r() &amp;&amp; w() {
<em class="lineno">21: </em>            return 0;
<em class="lineno">22: </em>        }
<em class="lineno">23: </em>        if is_leaf() &amp;&amp; !is_ppn_aligned(level) {
<em class="lineno">24: </em>            return 0;
<em class="lineno">25: </em>        }
<em class="lineno">26: </em>        if !is_leaf() &amp;&amp; level == 0 {
<em class="lineno">27: </em>            return 0;
<em class="lineno">28: </em>        }
<em class="lineno">29: </em>        return 1;
<em class="lineno">30: </em>    }
<em class="lineno">31: </em>
<em class="lineno">32: </em>    // 次のlevelのPTEのアドレスを得る
<em class="lineno">33: </em>    function get_next_pte_addr (
<em class="lineno">34: </em>        level: input Level,
<em class="lineno">35: </em>        va   : input Addr ,
<em class="lineno">36: </em>    ) -&gt; Addr {
<em class="lineno">37: </em>        return {
<em class="lineno">38: </em>            1'b0 repeat XLEN - 44 - PAGESIZE,
<em class="lineno">39: </em>            ppn(),
<em class="lineno">40: </em>            vpn(va, level - 1),
<em class="lineno">41: </em>            1'b0 repeat $clog2(PTESIZE)
<em class="lineno">42: </em>        };
<em class="lineno">43: </em>    }
<em class="lineno">44: </em>
<em class="lineno">45: </em>    // PTEと仮想アドレスから物理アドレスを生成する
<em class="lineno">46: </em>    function get_physical_address (
<em class="lineno">47: </em>        level: input Level,
<em class="lineno">48: </em>        va   : input Addr ,
<em class="lineno">49: </em>    ) -&gt; Addr {
<em class="lineno">50: </em>        return {
<em class="lineno">51: </em>            8'b0, ppn2(), case level {
<em class="lineno">52: </em>                0: {
<em class="lineno">53: </em>                    ppn1(), ppn0()
<em class="lineno">54: </em>                },
<em class="lineno">55: </em>                1: {
<em class="lineno">56: </em>                    ppn1(), vpn(va, 0)
<em class="lineno">57: </em>                },
<em class="lineno">58: </em>                2: {
<em class="lineno">59: </em>                    vpn(va, 1), vpn(va, 0)
<em class="lineno">60: </em>                },
<em class="lineno">61: </em>                default: 18'b0,
<em class="lineno">62: </em>            }, va[11:0]
<em class="lineno">63: </em>        };
<em class="lineno">64: </em>    }
<em class="lineno">65: </em>
<em class="lineno">66: </em>    // A、Dビットを更新する必要があるかを判定する
<em class="lineno">67: </em>    function need_update_ad (
<em class="lineno">68: </em>        wen: input logic,
<em class="lineno">69: </em>    ) -&gt; logic {
<em class="lineno">70: </em>        return !a() || wen &amp;&amp; !d();
<em class="lineno">71: </em>    }
<em class="lineno">72: </em>
<em class="lineno">73: </em>    // A, Dビットを更新したPTEの下位8ビットを生成する
<em class="lineno">74: </em>    function get_updated_ad (
<em class="lineno">75: </em>        wen: input logic,
<em class="lineno">76: </em>    ) -&gt; logic&lt;8&gt; {
<em class="lineno">77: </em>        let a: logic&lt;8&gt; = 1 &lt;&lt; 6;
<em class="lineno">78: </em>        let d: logic&lt;8&gt; = wen as u8 &lt;&lt; 7;
<em class="lineno">79: </em>        return value[7:0] | a | d;
<em class="lineno">80: </em>    }
</pre>
</div>

<h3 class="none"><a id="h18-9-3"></a><span class="secno">18.9.3</span> ptwモジュールの実装</h3>
<p>sv39utilパッケージをimportします(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.import">リスト18.61</a></span>)。</p>
<div id="ptw.veryl.sv39.import" class="caption-code">
<span class="caption">リスト18.61: リスト18.61: sv39utilパッケージをimportする (ptw.veryl)</span>
<pre class="list language-import" translate="no"><em class="lineno">1: </em>import sv39util::*;
</pre>
</div>
<p>PTE39インターフェースをインスタンス化します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.pte">リスト18.62</a></span>)。<code class="inline-code" translate="no" >value</code>には<code class="inline-code" translate="no" >master</code>のロード結果を割り当てます。</p>
<div id="ptw.veryl.sv39.pte" class="caption-code">
<span class="caption">リスト18.62: リスト18.62: PTE39インターフェースをインスタンス化する (ptw.veryl)</span>
<pre class="list language-pte" translate="no"><em class="lineno">1: </em>    inst pte      : PTE39;
<em class="lineno">2: </em>    assign pte.value = master.rdata;
</pre>
</div>
<div id="statezu" class="image">
<img src="images/24-impl-paging/statezu.png" alt="状態の遷移図 (点線の状態で新しく要求を受け付け、二重丸の状態で結果を返す)" class="img" style="width:80%" />
<p class="caption">
図18.12: 状態の遷移図 (点線の状態で新しく要求を受け付け、二重丸の状態で結果を返す)
</p>
</div>
<p>仮想アドレスを変換するための状態を追加します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.State">リスト18.63</a></span>)。本章ではページングが有効な時に、<code class="inline-code" translate="no" >state</code>が<span class="imgref"><a href="./24-impl-paging.html#statezu">図18.12</a></span>のように遷移するようにします。</p>
<div id="ptw.veryl.sv39.State" class="caption-code">
<span class="caption">リスト18.63: リスト18.63: 状態の定義 (ptw.veryl)</span>
<pre class="list language-State" translate="no"><em class="lineno">1: </em>    enum State {
<em class="lineno">2: </em>        IDLE,
<em class="lineno">3: </em>        <b>WALK_READY,</b>
<em class="lineno">4: </em>        <b>WALK_VALID,</b>
<em class="lineno">5: </em>        <b>SET_AD,</b>
<em class="lineno">6: </em>        EXECUTE_READY,
<em class="lineno">7: </em>        EXECUTE_VALID,
<em class="lineno">8: </em>        <b>PAGE_FAULT,</b>
<em class="lineno">9: </em>    }
</pre>
</div>
<p>現在のPTEのlevel(<code class="inline-code" translate="no" >level</code>)、PTEのアドレス(<code class="inline-code" translate="no" >taddr</code>)、要求によって更新されるPTEの下位8ビット(<code class="inline-code" translate="no" >wdata_ad</code>)を格納するためのレジスタを定義します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.reg">リスト18.64</a></span>、<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.reset">リスト18.65</a></span>)。</p>
<div id="ptw.veryl.sv39.reg" class="caption-code">
<span class="caption">リスト18.64: リスト18.64: レジスタの定義 (ptw.veryl)</span>
<pre class="list language-reg" translate="no"><em class="lineno">1: </em>    var physical_addr: Addr    ;
<em class="lineno">2: </em>    <b>var taddr        : Addr    ;</b>
<em class="lineno">3: </em>    <b>var level        : Level   ;</b>
<em class="lineno">4: </em>    <b>var wdata_ad     : logic&lt;8&gt;;</b>
</pre>
</div>
<div id="ptw.veryl.sv39.reset" class="caption-code">
<span class="caption">リスト18.65: リスト18.65: レジスタをリセットする (ptw.veryl)</span>
<pre class="list language-reset" translate="no"><em class="lineno">1: </em>    function on_reset () {
<em class="lineno">2: </em>        state             = State::IDLE;
<em class="lineno">3: </em>        physical_addr     = 0;
<em class="lineno">4: </em>        <b>taddr             = 0;</b>
<em class="lineno">5: </em>        <b>level             = 0;</b>
<em class="lineno">6: </em>        <b>wdata_ad          = 0;</b>
</pre>
</div>
<p>PTEのフェッチとA、Dビットの更新のために<code class="inline-code" translate="no" >master</code>に要求を割り当てます(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.assign_master">リスト18.66</a></span>)。PTEは<code class="inline-code" translate="no" >taddr</code>を使ってアクセスし、A、Dビットの更新では下位8ビットのみの書き込みマスクを設定します。</p>
<div id="ptw.veryl.sv39.assign_master" class="caption-code">
<span class="caption">リスト18.66: リスト18.66: masterに要求を割り当てる (ptw.veryl)</span>
<pre class="list language-assign_master" translate="no"><em class="lineno">1: </em>case state {
<em class="lineno">2: </em>    State::IDLE      : accept_request_comb();
<em class="lineno">3: </em>    <b>State::WALK_READY: assign_master      (taddr, 0, 0, 0);</b>
<em class="lineno">4: </em>    <b>State::SET_AD    : assign_master      (taddr, 1, // wen = 1</b>
<em class="lineno">5: </em>    <b> {1'b0 repeat MEMBUS_DATA_WIDTH - 8, wdata_ad}, // wdata</b>
<em class="lineno">6: </em>    <b> {1'b0 repeat XLEN / 8 - 1, 1'b1} // wmask</b>
<em class="lineno">7: </em>    <b>);</b>
<em class="lineno">8: </em>    State::EXECUTE_READY: assign_master(physical_addr, slave_saved.wen, slave_saved.wdata, slave_saved.wmask);
<em class="lineno">9: </em>    State::EXECUTE_VALID: if master.rvalid {
<em class="lineno">10: </em>        accept_request_comb();
<em class="lineno">11: </em>    }
<em class="lineno">12: </em>    default: {}
<em class="lineno">13: </em>}
</pre>
</div>
<p><code class="inline-code" translate="no" >slave</code>への結果の割り当てで、ページフォルト例外が発生していた場合の結果を割り当てます(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.assign_slave">リスト18.67</a></span>)。</p>
<div id="ptw.veryl.sv39.assign_slave" class="caption-code">
<span class="caption">リスト18.67: リスト18.67: ページフォルト例外のときの結果を割り当てる (ptw.veryl)</span>
<pre class="list language-assign_slave" translate="no"><em class="lineno">1: </em>State::PAGE_FAULT: {
<em class="lineno">2: </em>    slave.rvalid          = 1;
<em class="lineno">3: </em>    slave.expt.valid      = 1;
<em class="lineno">4: </em>    slave.expt.page_fault = 1;
<em class="lineno">5: </em>}
</pre>
</div>
<p>ページングが有効なときに要求を受け入れる動作を実装します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.accept">リスト18.68</a></span>)。仮想アドレスが有効かどうかでページフォルト例外を判定し、<code class="inline-code" translate="no" >taddr</code>レジスタに最初のPTEのアドレスを割り当てます。<code class="inline-code" translate="no" >level</code>の初期値は<code class="inline-code" translate="no" >LEVELS - 1</code>とします。</p>
<div id="ptw.veryl.sv39.accept" class="caption-code">
<span class="caption">リスト18.68: リスト18.68: ページングが有効なときの要求の受け入れ (ptw.veryl)</span>
<pre class="list language-accept" translate="no"><em class="lineno">1: </em>if paging_enabled {
<em class="lineno">2: </em>    <b>state = if is_valid_vaddr(slave.addr) ? State::WALK_READY : State::PAGE_FAULT;</b>
<em class="lineno">3: </em>    <b>taddr = get_first_pte_address(ctrl.satp, slave.addr);</b>
<em class="lineno">4: </em>    <b>level = LEVELS - 1;</b>
<em class="lineno">5: </em>} else {
<em class="lineno">6: </em>    state         = if master.ready ? State::EXECUTE_VALID : State::EXECUTE_READY;
<em class="lineno">7: </em>    physical_addr = slave.addr;
<em class="lineno">8: </em>}
</pre>
</div>
<p>ページフォルト例外が発生したとき、状態を<code class="inline-code" translate="no" >State::IDLE</code>に戻します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.clockpf">リスト18.69</a></span>)。</p>
<div id="ptw.veryl.sv39.clockpf" class="caption-code">
<span class="caption">リスト18.69: リスト18.69: ページフォルト例外が発生したときの状態遷移 (ptw.veryl)</span>
<pre class="list language-clockpf" translate="no"><em class="lineno">1: </em>State::PAGE_FAULT: state = State::IDLE;
</pre>
</div>
<p>A、Dビットを更新するとき、メモリが書き込み要求を受け入れたら、状態を<code class="inline-code" translate="no" >State::EXECUTE_READY</code>に移動します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.clockad">リスト18.70</a></span>)。</p>
<div id="ptw.veryl.sv39.clockad" class="caption-code">
<span class="caption">リスト18.70: リスト18.70: A、Dビットを更新したときの状態遷移 (ptw.veryl)</span>
<pre class="list language-clockad" translate="no"><em class="lineno">1: </em>State::SET_AD: if master.ready {
<em class="lineno">2: </em>    state = State::EXECUTE_READY;
<em class="lineno">3: </em>}
</pre>
</div>
<p>ページにアクセスする権限があるかをPTEと要求から判定する関数を定義します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.check">リスト18.71</a></span>)。条件の詳細は「<a href="24-impl-paging.html#h18-3">18.3 Sv39のアドレス変換</a>」を確認してください。</p>
<div id="ptw.veryl.sv39.check" class="caption-code">
<span class="caption">リスト18.71: リスト18.71: ページにアクセスする権限があるかを判定する関数 (ptw.veryl)</span>
<pre class="list language-check" translate="no"><em class="lineno">1: </em>    function check_permission (
<em class="lineno">2: </em>        req: modport Membus::all_input,
<em class="lineno">3: </em>    ) -&gt; logic {
<em class="lineno">4: </em>        let priv: PrivMode = if is_inst || !ctrl.mprv ? ctrl.priv : ctrl.mpp;
<em class="lineno">5: </em>
<em class="lineno">6: </em>        // U-mode access with PTE.U=0
<em class="lineno">7: </em>        let u_u0: logic = priv == PrivMode::U &amp;&amp; !pte.u();
<em class="lineno">8: </em>        // S-mode load/store with PTE.U=1 &amp; sum=0
<em class="lineno">9: </em>        let sd_u1: logic = !is_inst &amp;&amp; priv == PrivMode::S &amp;&amp; pte.u() &amp;&amp; !ctrl.sum;
<em class="lineno">10: </em>        // S-mode execute with PTE.U=1
<em class="lineno">11: </em>        let si_u1: logic = is_inst &amp;&amp; priv == PrivMode::S &amp;&amp; pte.u();
<em class="lineno">12: </em>
<em class="lineno">13: </em>        // execute without PTE.X
<em class="lineno">14: </em>        let x: logic = is_inst &amp;&amp; !pte.x();
<em class="lineno">15: </em>        // write without PTE.W
<em class="lineno">16: </em>        let w: logic = !is_inst &amp;&amp; req.wen &amp;&amp; !pte.w();
<em class="lineno">17: </em>        // read without PTE.R (MXR)
<em class="lineno">18: </em>        let r: logic = !is_inst &amp;&amp; !req.wen &amp;&amp; !pte.r() &amp;&amp; !(pte.x() &amp;&amp; ctrl.mxr);
<em class="lineno">19: </em>
<em class="lineno">20: </em>        return !(u_u0 | sd_u1 | si_u1 | x | w | r);
<em class="lineno">21: </em>    }
</pre>
</div>
<p>PTEをフェッチしてページフォルト例外を判定し、次のPTEのフェッチ、A、Dビットを更新する状態への遷移を実装します(<span class="listref"><a href="./24-impl-paging.html#ptw.veryl.sv39.walk">リスト18.72</a></span>)。</p>
<div id="ptw.veryl.sv39.walk" class="caption-code">
<span class="caption">リスト18.72: リスト18.72: PTEのフェッチとPTEの確認 (ptw.veryl)</span>
<pre class="list language-walk" translate="no"><em class="lineno">1: </em>State::WALK_READY: if master.ready {
<em class="lineno">2: </em>    state = State::WALK_VALID;
<em class="lineno">3: </em>}
<em class="lineno">4: </em>State::WALK_VALID: if master.rvalid {
<em class="lineno">5: </em>    if !pte.is_valid(level) {
<em class="lineno">6: </em>        state = State::PAGE_FAULT;
<em class="lineno">7: </em>    } else {
<em class="lineno">8: </em>        if pte.is_leaf() {
<em class="lineno">9: </em>            if check_permission(slave_saved) {
<em class="lineno">10: </em>                physical_addr = pte.get_physical_address(level, slave_saved.addr);
<em class="lineno">11: </em>                if pte.need_update_ad(slave_saved.wen) {
<em class="lineno">12: </em>                    state    = State::SET_AD;
<em class="lineno">13: </em>                    wdata_ad = pte.get_updated_ad(slave_saved.wen);
<em class="lineno">14: </em>                } else {
<em class="lineno">15: </em>                    state = State::EXECUTE_READY;
<em class="lineno">16: </em>                }
<em class="lineno">17: </em>            } else {
<em class="lineno">18: </em>                state = State::PAGE_FAULT;
<em class="lineno">19: </em>            }
<em class="lineno">20: </em>        } else {
<em class="lineno">21: </em>            // read next pte
<em class="lineno">22: </em>            state = State::WALK_READY;
<em class="lineno">23: </em>            taddr = pte.get_next_pte_addr(level, slave_saved.addr);
<em class="lineno">24: </em>            level = level - 1;
<em class="lineno">25: </em>        }
<em class="lineno">26: </em>    }
<em class="lineno">27: </em>}
</pre>
</div>
<p>これでSv39をptwモジュールに実装できました。</p>

<h2 class="numbox"><a id="h18-10"></a><span class="secno">18.10</span> SFENCE.VMA命令の実装</h2>
<p>SFENCE.VMA命令は、SFENCE.VMA命令を実行する以前のストア命令がMMUに反映されたことを保証する命令です。S-mode以上の特権レベルのときに実行できます。</p>
<p>基本編ではすべてのメモリアクセスを直列に行い、仮想アドレスを変換するために毎回PTEをフェッチしなおすため、何もしない命令として定義します。</p>

<h3 class="none"><a id="h18-10-1"></a><span class="secno">18.10.1</span> SFENCE.VMA命令をデコードする</h3>
<p>SFENCE.VMA命令を有効な命令としてデコードします(<span class="listref"><a href="./24-impl-paging.html#inst_decoder.veryl.sfence.system">リスト18.73</a></span>)。</p>
<div id="inst_decoder.veryl.sfence.system" class="caption-code">
<span class="caption">リスト18.73: リスト18.73: SFENCE.VMA命令を有効な命令としてデコードする (inst_decoder.veryl)</span>
<pre class="list language-system" translate="no"><em class="lineno">1: </em> bits == 32'h10200073 || //SRET
<em class="lineno">2: </em> bits == 32'h10500073 || // WFI
<em class="lineno">3: </em> f7 == 7'b0001001 &amp;&amp; bits[11:7] == 0, // SFENCE.VMA
</pre>
</div>

<h3 class="none"><a id="h18-10-2"></a><span class="secno">18.10.2</span> 特権レベルの確認、mstatus.TVMを実装する</h3>
<p>S-mode未満の特権レベルでSFENCE.VMA命令を実行しようとしたとき、Illegal instruction例外が発生します。</p>
<p>mstatus.TVMはS-modeのときにsatpレジスタにアクセスできるか、SFENCE.VMA命令を実行できるかを制御するビットです。mstatus.TVMが<code class="inline-code" translate="no" >1</code>にされているとき、Illegal instruction例外が発生します。</p>
<p>mstatus.TVMを書き込めるようにします(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.sfence.WMASK">リスト18.74</a></span>)。</p>
<div id="csrunit.veryl.sfence.WMASK" class="caption-code">
<span class="caption">リスト18.74: リスト18.74: mstatusレジスタの書き込みマスクを変更する (csrunit.veryl)</span>
<pre class="list language-WMASK" translate="no"><em class="lineno">1: </em>    const MSTATUS_WMASK   : UIntX = 'h0000_0000_00<b>7</b>e_19aa as UIntX;
</pre>
</div>
<div id="csrunit.veryl.sfence.tvm" class="caption-code">
<span class="caption">リスト18.75: リスト18.75: mstatus.TVMを示す変数を作成する (csrunit.veryl)</span>
<pre class="list language-tvm" translate="no"><em class="lineno">1: </em>    let mstatus_tvm : logic    = mstatus[20];
</pre>
</div>
<p>特権レベルを確認して、例外を発生させます(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.sfence.is">リスト18.76</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.sfence.expt">リスト18.77</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.sfence.raise">リスト18.78</a></span>)。</p>
<div id="csrunit.veryl.sfence.is" class="caption-code">
<span class="caption">リスト18.76: リスト18.76: SFENCE.VMA命令かどうかを判定する (csrunit.veryl)</span>
<pre class="list language-is" translate="no"><em class="lineno">1: </em>    let is_sfence_vma: logic = ctrl.is_csr &amp;&amp; ctrl.funct7 == 7'b0001001 &amp;&amp; ctrl.funct3 == 0 &amp;&amp; rd_addr == 0;
</pre>
</div>
<div id="csrunit.veryl.sfence.expt" class="caption-code">
<span class="caption">リスト18.77: リスト18.77: SFENCE.VMA命令の例外を判定する (csrunit.veryl)</span>
<pre class="list language-expt" translate="no"><em class="lineno">1: </em>    let expt_tvm: logic = (is_sfence_vma &amp;&amp; mode &lt;: PrivMode::S) || (mstatus_tvm &amp;&amp; mode == PrivMode::S &amp;&amp; (is_wsc &amp;&amp; csr_addr == CsrAddr::SATP || is_sfence_vma));
</pre>
</div>
<div id="csrunit.veryl.sfence.raise" class="caption-code">
<span class="caption">リスト18.78: リスト18.78: 例外を発生させる (csrunit.veryl)</span>
<pre class="list language-raise" translate="no"><em class="lineno">1: </em>    let raise_expt: logic = valid &amp;&amp; (expt_info.valid || expt_write_readonly_csr || expt_csr_priv_violation || expt_zicntr_priv || expt_trap_return_priv || expt_memory_fault <b>|| expt_tvm</b>);
<em class="lineno">2: </em>    let expt_cause: UIntX = switch {
<em class="lineno">3: </em>        ...
<em class="lineno">4: </em>        <b>expt_tvm               : CsrCause::ILLEGAL_INSTRUCTION,</b>
<em class="lineno">5: </em>        default                : 0,
<em class="lineno">6: </em>    };
</pre>
</div>

<h2 class="numbox"><a id="h18-11"></a><span class="secno">18.11</span> パイプラインをフラッシュする</h2>
<p>本書はパイプライン化したCPUを実装しているため、命令フェッチは前の命令を待たずに次々に行われます。</p>

<h3 class="none"><a id="h18-11-1"></a><span class="secno">18.11.1</span> CSRの変更</h3>
<p>mstatusレジスタのMXR、SUM、TVMビット、satpレジスタを書き換えたとき、CSRを書き換える命令の後ろの命令は、CSRの変更が反映されていない状態でアドレス変換してフェッチした命令になっている可能性があります。</p>
<p>CSRの書き換えをページングに反映するために、特定のCSRを書き換えたらパイプラインをフラッシュするようにします。</p>
<p>csrunitモジュールに、フラッシュするためのフラグを追加します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.flushcsr.port">リスト18.79</a></span>、<span class="listref"><a href="./24-impl-paging.html#core.veryl.flushcsr.reg">リスト18.80</a></span>、<span class="listref"><a href="./24-impl-paging.html#core.veryl.flushcsr.csru">リスト18.81</a></span>)。</p>
<div id="csrunit.veryl.flushcsr.port" class="caption-code">
<span class="caption">リスト18.79: リスト18.79: csrunitモジュールのポートにフラッシュするためのフラグを追加する (csrunit.veryl)</span>
<pre class="list language-port" translate="no"><em class="lineno">1: </em><b>flush      : output  logic                   ,</b>
<em class="lineno">2: </em>minstret   : input   UInt64                  ,
</pre>
</div>
<div id="core.veryl.flushcsr.reg" class="caption-code">
<span class="caption">リスト18.80: リスト18.80: csru_flush変数の定義 (core.veryl)</span>
<pre class="list language-reg" translate="no"><em class="lineno">1: </em>    var csru_trap_return: logic   ;
<em class="lineno">2: </em>    <b>var csru_flush      : logic   ;</b>
<em class="lineno">3: </em>    var minstret        : UInt64  ;
</pre>
</div>
<div id="core.veryl.flushcsr.csru" class="caption-code">
<span class="caption">リスト18.81: リスト18.81: csrunitモジュールのflushフラグをcsru_flushに割り当てる (core.veryl)</span>
<pre class="list language-csru" translate="no"><em class="lineno">1: </em><b>flush      : csru_flush           ,</b>
<em class="lineno">2: </em>minstret                          ,
</pre>
</div>
<p>satp、mstatus、sstatusレジスタが変更されるときに<code class="inline-code" translate="no" >flush</code>を<code class="inline-code" translate="no" >1</code>にします(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.flushcsr.logic">リスト18.82</a></span>)。</p>
<div id="csrunit.veryl.flushcsr.logic" class="caption-code">
<span class="caption">リスト18.82: リスト18.82: satp、mstatus、sstatusレジスタが変更されるときにflushを1にする (csrunit.veryl)</span>
<pre class="list language-logic" translate="no"><em class="lineno">1: </em>    let wsc_flush: logic = is_wsc &amp;&amp; (csr_addr == CsrAddr::SATP || csr_addr == CsrAddr::MSTATUS || csr_addr == CsrAddr::SSTATUS);
<em class="lineno">2: </em>    assign flush     = valid &amp;&amp; wsc_flush;
</pre>
</div>
<p><code class="inline-code" translate="no" >flush</code>が<code class="inline-code" translate="no" >1</code>のとき、制御ハザードが発生したことにしてパイプラインをフラッシュします(<span class="listref"><a href="./24-impl-paging.html#core.veryl.flushcsr.hazard">リスト18.83</a></span>)。</p>
<div id="core.veryl.flushcsr.hazard" class="caption-code">
<span class="caption">リスト18.83: リスト18.83: csru_flushが1のときにパイプラインをフラッシュする (core.veryl)</span>
<pre class="list language-hazard" translate="no"><em class="lineno">1: </em>    assign control_hazard         = mems_valid &amp;&amp; (csru_raise_trap || mems_ctrl.is_jump || memq_rdata.br_taken <b>|| csru_flush</b>);
<em class="lineno">2: </em>    assign control_hazard_pc_next = if csru_raise_trap ? csru_trap_vector : // trap
<em class="lineno">3: </em>     <b>if csru_flush ? mems_pc + 4 :</b> memq_rdata.jump_addr; // <b>flush or</b> jump
</pre>
</div>

<h3 class="none"><a id="h18-11-2"></a><span class="secno">18.11.2</span> FENCE.I命令の実装</h3>
<p>あるアドレスにデータを書き込むとき、データを書き込んだ後の命令が、書き換えられたアドレスにある命令だった場合、命令のビット列がデータが書き換えられる前のものになっている可能性があります。</p>
<p>FENCE.I命令は、FENCE.I命令の後の命令のフェッチ処理がストア命令の完了後に行われることを保証する命令です。例えばユーザーのアプリケーションのプログラムをページに書き込んで実行するとき、ページへの書き込みを反映させるために使用します。</p>
<p>FENCE.I命令を判定し、パイプラインをフラッシュする条件に設定します(<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.fence.is">リスト18.84</a></span>、<span class="listref"><a href="./24-impl-paging.html#csrunit.veryl.fence.flush">リスト18.85</a></span>)。</p>
<div id="csrunit.veryl.fence.is" class="caption-code">
<span class="caption">リスト18.84: リスト18.84: FENCE.I命令かどうかを判定する (csrunit.veryl)</span>
<pre class="list language-is" translate="no"><em class="lineno">1: </em>    let is_fence_i: logic = inst_bits[6:0] == OP_MISC_MEM &amp;&amp; ctrl.funct3 == 3'b001;
</pre>
</div>
<div id="csrunit.veryl.fence.flush" class="caption-code">
<span class="caption">リスト18.85: リスト18.85: FENCE.I命令のときにflushを1にする (csrunit.veryl)</span>
<pre class="list language-flush" translate="no"><em class="lineno">1: </em>    assign flush     = valid &amp;&amp; (wsc_flush <b>|| is_fence_i</b>);
</pre>
</div>
<p>riscv-testsの<code class="inline-code" translate="no" >-v-</code>を含むテストを実行し、実装している命令のテストに成功することを確認してください。</p>
        </main>
        <nav class="page-navi">
          <a href="23-smode-csr.html" class="page-prev">&#9664;</a>
          <a href="25-impl-plic.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
