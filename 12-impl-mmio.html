<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Memory-mapped I/Oの実装 | Verylで作るCPU</title>
    <meta name="description" content="Write RISC-V CPU in Veryl">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/assets/style.C620yUbE.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.Cn7PkA9i.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.CeOffQno.js">
    <link rel="modulepreload" href="/assets/chunks/framework.BNheOMQd.js">
    <link rel="modulepreload" href="/assets/12-impl-mmio.md.CHiBJDdb.lean.js">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EM6HSGNSVY"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EM6HSGNSVY");</script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-9f75dce3><div class="VPNavBar" data-v-9f75dce3 data-v-2a96a3d0><div class="wrapper" data-v-2a96a3d0><div class="container" data-v-2a96a3d0><div class="title" data-v-2a96a3d0><div class="VPNavBarTitle has-sidebar" data-v-2a96a3d0 data-v-1e38c6bc><a class="title" href="/" data-v-1e38c6bc><!--[--><!--]--><!----><span data-v-1e38c6bc>Verylで作るCPU</span><!--[--><!--]--></a></div></div><div class="content" data-v-2a96a3d0><div class="content-body" data-v-2a96a3d0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2a96a3d0><!--[--><!----><div id="local-search"><button type="button" aria-label="Search" aria-keyshortcuts="/ control+k meta+k" class="DocSearch DocSearch-Button"><span class="DocSearch-Button-Container"><span class="vpi-search DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key"></kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2a96a3d0 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2a96a3d0 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2a96a3d0 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/nananapo/veryl-riscv-book" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2a96a3d0 data-v-bb2aa2f0 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/nananapo/veryl-riscv-book" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2a96a3d0 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-2a96a3d0><div class="divider-line" data-v-2a96a3d0></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-8acdfeb5><div class="container" data-v-8acdfeb5><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-8acdfeb5><span class="vpi-align-left menu-icon" data-v-8acdfeb5></span><span class="menu-text" data-v-8acdfeb5>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-8acdfeb5 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-e7c6e512><div class="curtain" data-v-e7c6e512></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e7c6e512><span class="visually-hidden" id="sidebar-aria-label" data-v-e7c6e512> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>第I部 RV32I/RV64Iの実装</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/00-preface.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>まえがき</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/02-setup.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>1 環境構築</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/03-veryl.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>2 ハードウェア記述言語 Veryl</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/04-impl-rv32i.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>3 RV32Iの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/04a-zicsr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>4 Zicsr拡張の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/04b-riscvtests.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>5 riscv-testsによるテスト</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/05-impl-rv64i.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>6 RV64Iの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/05a-pipeline.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>7 CPUのパイプライン化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/05b-synth.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>8 CPUの合成</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>第II部 RV64IMACの実装</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/10-impl-m.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>9 M拡張の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/11-impl-exception.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>10 例外の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/12-impl-mmio.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>11 Memory-mapped I/Oの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/13-impl-a.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>12 A拡張の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/14-impl-c.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>13 C拡張の実装</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>第III部 特権/割り込みの実装</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/20-mmode-csr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>14 M-modeの実装 (1. CSRの実装)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/21-impl-interrupt.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>15 M-modeの実装 (2. 割り込みの実装)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/22-umode-csr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>16 U-modeの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/23-smode-csr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>17 S-modeの実装 (1. CSRの実装)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/24-impl-paging.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>18 S-modeの実装 (2. 仮想記憶システム)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/25-impl-plic.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>19 PLICの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/26-run-linux.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>20 Linuxを動かす</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/99-postface.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>あとがき (第Ⅰ部)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/99b-postface.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>あとがき (第Ⅱ部、第Ⅲ部)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/100-contribute.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>このプロジェクトに貢献する</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-aff0b8d7><div class="VPDoc has-sidebar has-aside" data-v-aff0b8d7 data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-2d0bdf9b><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _12-impl-mmio" data-v-7011f0d8><div><h1 id="memory-mapped-i-oの実装" tabindex="-1">Memory-mapped I/Oの実装 <a class="header-anchor" href="#memory-mapped-i-oの実装" aria-label="Permalink to “Memory-mapped I/Oの実装”">​</a></h1><h2 id="memory-mapped-i-oとは何か" tabindex="-1">Memory-mapped I/Oとは何か？ <a class="header-anchor" href="#memory-mapped-i-oとは何か" aria-label="Permalink to “Memory-mapped I/Oとは何か？”">​</a></h2><p>これまでの実装では、 CPUに内蔵された1つの大きなメモリ空間、 1つのメモリデバイス(memoryモジュール)に命令データを格納、実行し、 データのロードストア命令も同じメモリに対して実行してきました。</p><p>一般に流通するコンピュータは複数のデバイスに接続されています。 CPUが起動すると、読み込み専用の小さなメモリ(ROM)に格納されたプログラムから命令の実行を開始します。 プログラムは周辺デバイスの初期化などを行ったあと、 動かしたいアプリケーションの命令やデータをRAMに展開して、 制御をアプリケーションに移します。</p><p>CPUがデバイスにアクセスする方法にはCSRやメモリ空間を経由する方法があります。 一般的な方法はメモリ空間を通じてデバイスにアクセスする方法であり、 この方式のことを<strong>メモリマップドIO</strong>(Memory-mapped I/O, <strong>MMIO</strong>)と呼びます。 メモリ空間の一部を、デバイスにアクセスするための空間として扱うことを、メモリ(またはアドレス)に<strong>マップ</strong>すると呼びます。 RAMとROMもメモリデバイスであり、異なるアドレスにマップされています。</p><p><img src="/assets/mmio.CKW0FEpU.png" alt="メモリマップ"> 本章ではCPUのメモリ部分をRAM(Random Access Memory)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>とROM(Read Only Memory)に分割し、 アクセスするアドレスに応じてアクセスするデバイスを切り替える機能を実装します。 また、デバッグ用の入出力デバイス(64ビットのレジスタ)も実装します。 デバイスとメモリ空間の対応は図1のように設定します。 図1のようにメモリがどのように配置されているかを示す図のことを<strong>メモリマップ</strong>(Memory map)と呼びます。 あるメモリ空間の先頭アドレスのことをベースアドレス(base address)と呼ぶことがあります。</p><h2 id="定数の定義" tabindex="-1">定数の定義 <a class="header-anchor" href="#定数の定義" aria-label="Permalink to “定数の定義”">​</a></h2><p>eeiパッケージに定義しているメモリの定数をRAM用の定数に変更します。 また、新しくRAMのベースアドレス、メモリバスのデータ幅、ROMのメモリマップを示す定数を定義してください (リスト1)。 デバッグ入出力デバイス(レジスタ)の位置は、topモジュールのポートで定義します (リスト9)。</p><p><span class="caption">▼リスト11.1: メモリマップの定義 (eei.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// メモリ<span class="custom-hl-bold">バス</span>のデータ幅</span>
<span class="hljs-keyword">const</span> MEM<span class="custom-hl-bold">BUS</span>_DATA_WIDTH: <span class="hljs-keyword">u32</span> = <span class="hljs-number">64</span>;
<span class="custom-hl-del"><span class="hljs-comment">// メモリのアドレス幅</span></span>
<span class="custom-hl-del"><span class="hljs-keyword">const</span> MEM_ADDR_WIDTH: <span class="hljs-keyword">u32</span> = <span class="hljs-number">16</span>;</span>

<span class="hljs-comment">// RAM</span>
<span class="hljs-keyword">const</span> RAM_ADDR_WIDTH: <span class="hljs-keyword">u32</span>  = <span class="hljs-number">16</span>;
<span class="hljs-keyword">const</span> RAM_DATA_WIDTH: <span class="hljs-keyword">u32</span>  = <span class="hljs-number">64</span>;
<span class="hljs-keyword">const</span> MMAP_RAM_BEGIN: Addr = <span class="hljs-number">&#39;h8000_0000</span> <span class="hljs-keyword">as</span> Addr;

<span class="hljs-comment">// ROM</span>
<span class="hljs-keyword">const</span> ROM_ADDR_WIDTH: <span class="hljs-keyword">u32</span>  = <span class="hljs-number">9</span>;
<span class="hljs-keyword">const</span> ROM_DATA_WIDTH: <span class="hljs-keyword">u32</span>  = <span class="hljs-number">64</span>;
<span class="hljs-keyword">const</span> MMAP_ROM_BEGIN: Addr = <span class="hljs-number">&#39;h1000</span> <span class="hljs-keyword">as</span> Addr;
<span class="hljs-keyword">const</span> MMAP_ROM_END  : Addr = MMAP_ROM_BEGIN + <span class="hljs-number">&#39;h3ff</span> <span class="hljs-keyword">as</span> Addr;
</code></pre></div><p><code>MEM_DATA_WIDTH</code>、<code>MEM_ADDR_WIDTH</code>を使っている部分を<code>MEMBUS_DATA_WIDTH</code>、<code>XLEN</code>に置き換えます。 <code>MEMBUS_DATA_WIDTH</code>と<code>XLEN</code>を使うmembus_ifインターフェースに別名<code>Membus</code>をつけて利用します ( リスト2、 リスト3、 リスト4、 リスト5 )。</p><p><span class="caption">▼リスト11.2: 別名の定義 (membus_if.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">alias</span> <span class="hljs-keyword">interface</span> Membus = membus_if::&lt;eei::MEMBUS_DATA_WIDTH, eei::XLEN&gt;;
</code></pre></div><p><span class="caption">▼リスト11.3: Membusに置き換える (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> core (
    clk     : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">clock</span>                          ,
    rst     : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">reset</span>                          ,
    i_membus: <span class="hljs-keyword">modport</span> membus_if::&lt;ILEN, XLEN&gt;::master,
    d_membus: <span class="hljs-keyword">modport</span> <span class="custom-hl-bold">Membus</span>::master                 ,
    led     : <span class="hljs-keyword">output</span>  UIntX                          ,
) {
</code></pre></div><p><span class="caption">▼リスト11.4: Membusに置き換える (memunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>membus: <span class="hljs-keyword">modport</span> <span class="custom-hl-bold">Membus</span>::master, <span class="hljs-comment">// メモリとのinterface</span>
</code></pre></div><p><span class="caption">▼リスト11.5: 定数名を変更する (memunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">var</span> req_wen  : <span class="hljs-keyword">logic</span>                       ;
<span class="hljs-keyword">var</span> req_addr : Addr                        ;
<span class="hljs-keyword">var</span> req_wdata: <span class="hljs-keyword">logic</span>&lt;MEM<span class="custom-hl-bold">BUS</span>_DATA_WIDTH&gt;    ;
<span class="hljs-keyword">var</span> req_wmask: <span class="hljs-keyword">logic</span>&lt;MEM<span class="custom-hl-bold">BUS</span>_DATA_WIDTH / <span class="hljs-number">8</span>&gt;;

<span class="hljs-keyword">const</span> W   : <span class="hljs-keyword">u32</span>                      = XLEN;
<span class="hljs-keyword">let</span> D   : <span class="hljs-keyword">logic</span>&lt;MEM<span class="custom-hl-bold">BUS</span>_DATA_WIDTH&gt; = membus.rdata;
<span class="hljs-keyword">let</span> sext: <span class="hljs-keyword">logic</span>                    = ctrl.funct3[<span class="hljs-number">2</span>] == <span class="hljs-number">1&#39;b0</span>;
</code></pre></div><p>topモジュールでインスタンス化しているmembus_ifインターフェースのジェネリックパラメータを変更します (リスト6)。</p><p><span class="caption">▼リスト11.6: ジェネリックパラメータを変更する / Membusに置き換える (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> membus  : membus_if::&lt;<span class="custom-hl-bold">RAM</span>_DATA_WIDTH, <span class="custom-hl-bold">RAM</span>_ADDR_WIDTH&gt;;
<span class="hljs-keyword">inst</span> i_membus: membus_if::&lt;ILEN, XLEN&gt;; <span class="hljs-comment">// 命令フェッチ用</span>
<span class="hljs-keyword">inst</span> d_membus: <span class="custom-hl-bold">Membus</span>; <span class="hljs-comment">// ロードストア命令用</span>
</code></pre></div><p>addr_to_memaddr関数をジェネリック関数にして、呼び出すときにRAMのパラメータを使用するように変更します ( リスト7、 リスト8、 )。</p><p><span class="caption">▼リスト11.7: addr_to_memaddr関数をジェネリック関数に変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// アドレスをデータ単位でのアドレスに変換する</span>
<span class="hljs-keyword">function</span> addr_to_memaddr<span class="custom-hl-bold">::&lt;DATA_WIDTH: <span class="hljs-keyword">u32</span>, ADDR_WIDTH: <span class="hljs-keyword">u32</span>&gt;</span> (
    addr: <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;XLEN&gt;,
) -&gt; <span class="hljs-keyword">logic</span>&lt;<span class="custom-hl-bold">ADDR_WIDTH</span>&gt; {
    <span class="hljs-keyword">return</span> addr[$clog2(<span class="custom-hl-bold">DATA_WIDTH</span> / <span class="hljs-number">8</span>)+:<span class="custom-hl-bold">ADDR_WIDTH</span>];
}
</code></pre></div><p><span class="caption">▼リスト11.8: ジェネリックパラメータを指定する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>membus.valid = i_membus.valid | d_membus.valid;
<span class="hljs-keyword">if</span> d_membus.valid {
    membus.addr  = addr_to_memaddr<span class="custom-hl-bold">::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;</span>(d_membus.addr);
    membus.wen   = d_membus.wen;
    membus.wdata = d_membus.wdata;
    membus.wmask = d_membus.wmask;
} <span class="hljs-keyword">else</span> {
    membus.addr  = addr_to_memaddr<span class="custom-hl-bold">::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;</span>(i_membus.addr);
    membus.wen   = <span class="hljs-number">0</span>; <span class="hljs-comment">// 命令フェッチは常に読み込み</span>
    membus.wdata = &#39;x;
    membus.wmask = &#39;x;
}
</code></pre></div><p>メモリに読み込むHEXファイルを指定するパラメータの名前を変更します ( リスト9、 リスト10 )。</p><p><span class="caption">▼リスト11.9: パラメータ名を変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> top #(
    <span class="hljs-keyword">param</span> RAM_FILEPATH_IS_ENV: <span class="hljs-keyword">bit</span>    = <span class="hljs-number">1</span>              ,
    <span class="hljs-keyword">param</span> RAM_FILEPATH       : <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;RAM_FILE_PATH&quot;</span>,
) (
</code></pre></div><p><span class="caption">▼リスト11.10: パラメータ名を変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> ram: memory::&lt;<span class="custom-hl-bold">RAM</span>_DATA_WIDTH, <span class="custom-hl-bold">RAM</span>_ADDR_WIDTH&gt; #(
    FILEPATH_IS_ENV: <span class="custom-hl-bold">RAM</span>_FILEPATH_IS_ENV,
    FILEPATH       : <span class="custom-hl-bold">RAM</span>_FILEPATH       ,
) (
</code></pre></div><p>シミュレータ用のC++プログラムも変更します ( リスト11、 リスト12、 リスト13 )。</p><p><span class="caption">▼リスト11.11: 引数の名称を変える (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {
    std::cout &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; <span class="custom-hl-bold">RAM</span>_FILE_PATH [CYCLE]&quot;</span> &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre></div><p><span class="caption">▼リスト11.12: 環境変数名を変える (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-comment">// 環境変数でメモリの初期化用ファイルを指定する</span>
<span class="hljs-type">const</span> <span class="hljs-type">char</span>* original_env = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;<span class="custom-hl-bold">RAM</span>_FILE_PATH&quot;</span>);
<span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;<span class="custom-hl-bold">RAM</span>_FILE_PATH&quot;</span>, memory_file_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">1</span>);
</code></pre></div><p><span class="caption">▼リスト11.13: 環境変数名を変える (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-comment">// 環境変数を元に戻す</span>
<span class="hljs-keyword">if</span> (original_env != <span class="hljs-literal">nullptr</span>){
    <span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;<span class="custom-hl-bold">RAM</span>_FILE_PATH&quot;</span>, original_env, <span class="hljs-number">1</span>);
}
</code></pre></div><h2 id="mmio-controllerモジュールの作成" tabindex="-1">mmio_controllerモジュールの作成 <a class="header-anchor" href="#mmio-controllerモジュールの作成" aria-label="Permalink to “mmio_controllerモジュールの作成”">​</a></h2><p>アクセスするアドレスに応じてアクセス先のデバイスを切り替えるモジュールを実装します。</p><p><code>src/mmio_controller.veryl</code>を作成し、次のように記述します ( リスト14 )。</p><p><span class="caption">▼リスト11.14: mmio_controller.veryl</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">import</span> eei::*;

<span class="hljs-keyword">module</span> mmio_controller (
    clk     : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">clock</span>        ,
    rst     : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">reset</span>        ,
    req_core: <span class="hljs-keyword">modport</span> Membus::slave,
) {

    <span class="hljs-keyword">enum</span> Device {
        UNKNOWN,
    }

    <span class="hljs-keyword">inst</span> req_saved: Membus;

    <span class="hljs-keyword">var</span> last_device : Device;
    <span class="hljs-keyword">var</span> is_requested: <span class="hljs-keyword">logic</span> ;

    <span class="hljs-comment">// masterを0でリセットする</span>
    <span class="hljs-keyword">function</span> reset_membus_master (
        master: <span class="hljs-keyword">modport</span> Membus::master_output,
    ) {
        master.valid = <span class="hljs-number">0</span>;
        master.addr  = <span class="hljs-number">0</span>;
        master.wen   = <span class="hljs-number">0</span>;
        master.wdata = <span class="hljs-number">0</span>;
        master.wmask = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// すべてのデバイスのmasterをリセットする</span>
    <span class="hljs-keyword">function</span> reset_all_device_masters () {}

    <span class="hljs-comment">// アドレスからデバイスを取得する</span>
    <span class="hljs-keyword">function</span> get_device (
        addr: <span class="hljs-keyword">input</span> Addr,
    ) -&gt; Device {
        <span class="hljs-keyword">return</span> Device::UNKNOWN;
    }

    <span class="hljs-comment">// デバイスのmasterにreqの情報を割り当てる</span>
    <span class="hljs-keyword">function</span> assign_device_master (
        req: <span class="hljs-keyword">modport</span> Membus::all_input,
    ) {}

    <span class="hljs-comment">// デバイスのrvalid、rdataをreqに割り当てる</span>
    <span class="hljs-keyword">function</span> assign_device_slave (
        device: <span class="hljs-keyword">input</span>   Device          ,
        req   : <span class="hljs-keyword">modport</span> Membus::response,
    ) {
        req.rvalid = <span class="hljs-number">1</span>;
        req.rdata  = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// デバイスのreadyを取得する</span>
    <span class="hljs-keyword">function</span> get_device_ready (
        device: <span class="hljs-keyword">input</span> Device,
    ) -&gt; <span class="hljs-keyword">logic</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// デバイスのrvalidを取得する</span>
    <span class="hljs-keyword">function</span> get_device_rvalid (
        device: <span class="hljs-keyword">input</span> Device,
    ) -&gt; <span class="hljs-keyword">logic</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// req_coreの割り当て</span>
    <span class="hljs-keyword">always_comb</span> {
        req_core.ready  = <span class="hljs-number">0</span>;
        req_core.rvalid = <span class="hljs-number">0</span>;
        req_core.rdata  = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> req_saved.valid {
            <span class="hljs-keyword">if</span> is_requested {
                <span class="hljs-comment">// 結果を返す</span>
                assign_device_slave(last_device, req_core);
                req_core.ready      = get_device_rvalid(last_device);
            }
        } <span class="hljs-keyword">else</span> {
            req_core.ready = <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-comment">// デバイスのmasterの割り当て</span>
    <span class="hljs-keyword">always_comb</span> {
        reset_all_device_masters();
        <span class="hljs-keyword">if</span> req_saved.valid {
            <span class="hljs-keyword">if</span> is_requested {
                <span class="hljs-keyword">if</span> get_device_rvalid(last_device) {
                    <span class="hljs-comment">// 新しく要求を受け入れる</span>
                    <span class="hljs-keyword">if</span> req_core.ready &amp;&amp; req_core.valid {
                        assign_device_master(req_core);
                    }
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// デバイスにreq_savedを割り当てる</span>
                assign_device_master(req_saved);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 新しく要求を受け入れる</span>
            <span class="hljs-keyword">if</span> req_core.ready &amp;&amp; req_core.valid {
                assign_device_master(req_core);
            }
        }
    }

    <span class="hljs-comment">// 新しく要求を受け入れる</span>
    <span class="hljs-keyword">function</span> accept_request () {
        req_saved.valid = req_core.ready &amp;&amp; req_core.valid;
        <span class="hljs-keyword">if</span> req_core.ready &amp;&amp; req_core.valid {
            last_device  = get_device(req_core.addr);
            is_requested = get_device_ready(last_device);
            <span class="hljs-comment">// reqを保存</span>
            req_saved.addr  = req_core.addr;
            req_saved.wen   = req_core.wen;
            req_saved.wdata = req_core.wdata;
            req_saved.wmask = req_core.wmask;
        }
    }

    <span class="hljs-keyword">function</span> on_clock () {
        <span class="hljs-keyword">if</span> req_saved.valid {
            <span class="hljs-keyword">if</span> is_requested {
                <span class="hljs-keyword">if</span> get_device_rvalid(last_device) {
                    accept_request();
                }
            } <span class="hljs-keyword">else</span> {
                is_requested = get_device_ready(last_device);
            }
        } <span class="hljs-keyword">else</span> {
            accept_request();
        }
    }

    <span class="hljs-keyword">function</span> on_reset () {
        last_device         = Device::UNKNOWN;
        is_requested        = <span class="hljs-number">0</span>;
        reset_membus_master(req_saved);
    }

    <span class="hljs-keyword">always_ff</span> {
        <span class="hljs-keyword">if_reset</span> {
            on_reset();
        } <span class="hljs-keyword">else</span> {
            on_clock();
        }
    }
}
</code></pre></div><p>mmio_controllerモジュールの関数の引数にmembus_ifインターフェースを使うために、 新しくmodportを宣言します (リスト15)。</p><p><span class="caption">▼リスト11.15: modport宣言を追加する (membus_if.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">modport</span> all_input {
    ..<span class="hljs-keyword">input</span>
}

<span class="hljs-keyword">modport</span> response {
    rvalid: <span class="hljs-keyword">output</span>,
    rdata : <span class="hljs-keyword">output</span>,
}

<span class="hljs-keyword">modport</span> slave_output {
    ready: <span class="hljs-keyword">output</span>,
    ..<span class="hljs-keyword">same</span>(response)
}

<span class="hljs-keyword">modport</span> master_output {
    valid: <span class="hljs-keyword">output</span>,
    addr : <span class="hljs-keyword">output</span>,
    wen  : <span class="hljs-keyword">output</span>,
    wdata: <span class="hljs-keyword">output</span>,
    wmask: <span class="hljs-keyword">output</span>,
}
</code></pre></div><p>mmio_controllerモジュールは<code>req_core</code>からメモリアクセス要求を受け付け、 アクセス対象のモジュールからの結果を返すモジュールです。</p><p><code>Device</code>型は実装しているデバイスを表現するための列挙型です (リスト16)。 まだデバイスを接続していないので、不明なデバイス(<code>Device::UNKNOWN</code>)だけ定義しています。</p><p><span class="caption">▼リスト11.16: Device型の定義 (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">enum</span> Device {
    UNKNOWN,
}
</code></pre></div><p>reset_membus_master、reset_all_device_masters関数はインターフェースの値の割り当てを<code>0</code>でリセットするためのユーティリティ関数です。 名前がget_device_、assign_deviceから始まる関数は、デバイスの状態を取得したり、インターフェースに値を割り当てる関数です。 get_device関数はアドレスに対応する<code>Device</code>を取得する関数です。</p><p>always_comb、always_ffブロックはこれらの関数を利用してメモリアクセスを制御します。</p><p>always_ffブロックは、メモリアクセス要求の処理中ではない場合とメモリアクセスが終わった場合にメモリアクセス要求を受け入れます。 要求を受け入れるとき、<code>req_core</code>の値を<code>req_saved</code>に保存します。</p><p>always_combブロックはデバイスにアクセスし <code>req_core</code>に結果を返します。 <code>is_requested</code>は、メモリアクセス要求を処理している場合に既にデバイスが要求を受け入れたかを示すフラグです。 新しく要求を受け入れるときと<code>is_requested</code>が<code>0</code>のときにデバイスに要求を割り当て、 <code>is_requested</code>が<code>1</code>かつ<code>rvalid</code>が<code>1</code>のときに結果を返します。</p><p>まだアクセス先のデバイスを実装していないため、 常に<code>0</code>を読み込み、<code>ready</code>と<code>rvalid</code>は常に<code>1</code>にして、書き込みは無視します。</p><h2 id="ramの接続" tabindex="-1">RAMの接続 <a class="header-anchor" href="#ramの接続" aria-label="Permalink to “RAMの接続”">​</a></h2><h3 id="mmio-controllerモジュールにramを追加する" tabindex="-1">mmio_controllerモジュールにRAMを追加する <a class="header-anchor" href="#mmio-controllerモジュールにramを追加する" aria-label="Permalink to “mmio_controllerモジュールにRAMを追加する”">​</a></h3><p>mmio_controllerモジュールにRAMとのインターフェースを実装します。</p><p><code>Device</code>型にRAMを追加して、アドレスにRAMをマップします (リスト17、 リスト18 )。</p><p><span class="caption">▼リスト11.17: Device型にRAMを追加する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">enum</span> Device {
    UNKNOWN,
    RAM,
}
</code></pre></div><p><span class="caption">▼リスト11.18: get_device関数でRAMの範囲を定義する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> get_device (
    addr: <span class="hljs-keyword">input</span> Addr,
) -&gt; Device {
    <span class="custom-hl-bold"><span class="hljs-keyword">if</span> addr &gt;= MMAP_RAM_BEGIN {</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">return</span> Device::RAM;</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">return</span> Device::UNKNOWN;
}
</code></pre></div><p>RAMとのインターフェースを追加し、 reset_all_device_masters関数に要求をリセットするコードを追加します ( リスト19、 リスト20 )。</p><p><span class="caption">▼リスト11.19: RAMとのインターフェースを追加する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> mmio_controller (
    clk       : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">clock</span>         ,
    rst       : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">reset</span>         ,
    req_core  : <span class="hljs-keyword">modport</span> Membus::slave ,
    <span class="custom-hl-bold">ram_membus: <span class="hljs-keyword">modport</span> Membus::master,</span>
) {
</code></pre></div><p><span class="caption">▼リスト11.20: インターフェースの要求部分をリセットする (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> reset_all_device_masters () {
    <span class="custom-hl-bold">reset_membus_master(ram_membus);</span>
}
</code></pre></div><p><code>ready</code>、<code>rvalid</code>を取得する関数にRAMを登録します ( リスト21、 リスト22 )。</p><p><span class="caption">▼リスト11.21: インターフェースのreadyを返す (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> get_device_ready (
    device: <span class="hljs-keyword">input</span> Device,
) -&gt; <span class="hljs-keyword">logic</span> {
    <span class="custom-hl-bold"><span class="hljs-keyword">case</span> device {</span>
    <span class="custom-hl-bold">    Device::RAM: <span class="hljs-keyword">return</span> ram_membus.ready;</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">default</span>    : {}</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre></div><p><span class="caption">▼リスト11.22: インターフェースのrvalidを返す (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> get_device_rvalid (
    device: <span class="hljs-keyword">input</span> Device,
) -&gt; <span class="hljs-keyword">logic</span> {
    <span class="custom-hl-bold"><span class="hljs-keyword">case</span> device {</span>
    <span class="custom-hl-bold">    Device::RAM: <span class="hljs-keyword">return</span> ram_membus.rvalid;</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">default</span>    : {}</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre></div><p>RAMの<code>rvalid</code>、<code>rdata</code>を<code>req_core</code>に割り当てます (リスト23)。</p><p><span class="caption">▼リスト11.23: RAMへのアクセス結果をreqに割り当てる (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> assign_device_slave (
    device: <span class="hljs-keyword">input</span>   Device          ,
    req   : <span class="hljs-keyword">modport</span> Membus::response,
) {
    req.rvalid = <span class="hljs-number">1</span>;
    req.rdata  = <span class="hljs-number">0</span>;
    <span class="custom-hl-bold"><span class="hljs-keyword">case</span> device {</span>
    <span class="custom-hl-bold">    Device::RAM: req &lt;&gt; ram_membus;</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">default</span>    : {}</span>
    <span class="custom-hl-bold">}</span>
}
</code></pre></div><p>RAMのインターフェースに要求を割り当てます (リスト24)。 ここでRAMのベースアドレスを引いたアドレスを割り当てることで、<code>MMAP_RAM_BEGIN</code>が<code>0</code>になるようにしています。</p><p><span class="caption">▼リスト11.24: RAMにreqを割り当ててアクセス要求する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> assign_device_master (
    req: <span class="hljs-keyword">modport</span> Membus::all_input,
) {
    <span class="custom-hl-bold"><span class="hljs-keyword">case</span> get_device(req.addr) {</span>
    <span class="custom-hl-bold">    Device::RAM: {</span>
    <span class="custom-hl-bold">        ram_membus      &lt;&gt; req;</span>
    <span class="custom-hl-bold">        ram_membus.addr -= MMAP_RAM_BEGIN;</span>
    <span class="custom-hl-bold">    }</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">default</span>: {}</span>
    <span class="custom-hl-bold">}</span>
}
</code></pre></div><h3 id="ramとmmio-controllerモジュールを接続する" tabindex="-1">RAMとmmio_controllerモジュールを接続する <a class="header-anchor" href="#ramとmmio-controllerモジュールを接続する" aria-label="Permalink to “RAMとmmio_controllerモジュールを接続する”">​</a></h3><p>topモジュールにmmio_controllerモジュールをインスタンス化し、 RAMとmmio_controllerモジュール、mmio_controllerモジュールとcoreモジュールを接続します。</p><p>RAMとmmio_controllerモジュールを接続するインターフェース(<code>mmio_ram_membus</code>)、 coreモジュールとmmio_controllerモジュールを接続するインターフェース(<code>mmio_membus</code>)を定義し、 <code>membus</code>を<code>ram_membus</code>に改名します ( リスト25、 リスト26 )。</p><p><span class="caption">▼リスト11.25: インターフェースの定義 / インスタンス名を変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="custom-hl-bold"><span class="hljs-keyword">inst</span> mmio_membus    : Membus;</span>
<span class="custom-hl-bold"><span class="hljs-keyword">inst</span> mmio_ram_membus: Membus;</span>
<span class="hljs-keyword">inst</span> <span class="custom-hl-bold">ram_</span>membus     : membus_if::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;;
</code></pre></div><p><span class="caption">▼リスト11.26: ポート名を変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> ram: memory::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt; #(
    FILEPATH_IS_ENV: RAM_FILEPATH_IS_ENV,
    FILEPATH       : RAM_FILEPATH       ,
) (
    clk               ,
    rst               ,
    <span class="custom-hl-bold">membus:</span> <span class="custom-hl-bold">ram_</span>membus,
);
</code></pre></div><p>coreモジュールからRAMへのメモリアクセスを調停する処理を、 coreモジュールからmmio_controllerモジュールへのアクセスを調停する処理に変更します (リスト27)。</p><p><span class="caption">▼リスト11.27: 調停する対象をmmio_membusに変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// <span class="custom-hl-bold">mmio_controller</span>へのメモリアクセスを調停する</span>
<span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        memarb_last_i     = <span class="hljs-number">0</span>;
        memarb_last_iaddr = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> <span class="custom-hl-bold">mmio_</span>membus.ready {
            memarb_last_i     = !d_membus.valid;
            memarb_last_iaddr = i_membus.addr;
        }
    }
}

<span class="hljs-keyword">always_comb</span> {
    i_membus.ready  = <span class="custom-hl-bold">mmio_</span>membus.ready &amp;&amp; !d_membus.valid;
    i_membus.rvalid = <span class="custom-hl-bold">mmio_</span>membus.rvalid &amp;&amp; memarb_last_i;
    i_membus.rdata  = <span class="hljs-keyword">if</span> memarb_last_iaddr[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span> ? <span class="custom-hl-bold">mmio_</span>membus.rdata[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] : mmio_|membus.rdata[<span class="hljs-number">63</span>:<span class="hljs-number">32</span>];

    d_membus.ready  = <span class="custom-hl-bold">mmio_</span>membus.ready;
    d_membus.rvalid = <span class="custom-hl-bold">mmio_</span>membus.rvalid &amp;&amp; !memarb_last_i;
    d_membus.rdata  = <span class="custom-hl-bold">mmio_</span>membus.rdata;

    <span class="custom-hl-bold">mmio_</span>membus.valid = i_membus.valid | d_membus.valid;
    <span class="hljs-keyword">if</span> d_membus.valid {
        <span class="custom-hl-bold">mmio_</span>membus.addr  = <span class="custom-hl-bold">d_membus.addr</span>;
        <span class="custom-hl-bold">mmio_</span>membus.wen   = d_membus.wen;
        <span class="custom-hl-bold">mmio_</span>membus.wdata = d_membus.wdata;
        <span class="custom-hl-bold">mmio_</span>membus.wmask = d_membus.wmask;
    } <span class="hljs-keyword">else</span> {
        <span class="custom-hl-bold">mmio_</span>membus.addr  = <span class="custom-hl-bold">i_membus.addr</span>;
        <span class="custom-hl-bold">mmio_</span>membus.wen   = <span class="hljs-number">0</span>; <span class="hljs-comment">// 命令フェッチは常に読み込み</span>
        <span class="custom-hl-bold">mmio_</span>membus.wdata = &#39;x;
        <span class="custom-hl-bold">mmio_</span>membus.wmask = &#39;x;
    }
}
</code></pre></div><p>mmio_controllerをインスタンス化し、RAMと接続します。 ( リスト28、 リスト29 )。 RAMのアドレスへの変換は調停処理から接続部分に移動しています。</p><p><span class="caption">▼リスト11.28: mmio_controllerモジュールをインスタンス化する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> mmioc: mmio_controller (
    clk                        ,
    rst                        ,
    req_core  : mmio_membus    ,
    ram_membus: mmio_ram_membus,
);
</code></pre></div><p><span class="caption">▼リスト11.29: mmio_controllerモジュールとRAMを接続する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_comb</span> {
    <span class="hljs-comment">// mmio &lt;&gt; RAM</span>
    ram_membus.valid       = mmio_ram_membus.valid;
    mmio_ram_membus.ready  = ram_membus.ready;
    ram_membus.addr        = addr_to_memaddr::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;(mmio_ram_membus.addr);
    ram_membus.wen         = mmio_ram_membus.wen;
    ram_membus.wdata       = mmio_ram_membus.wdata;
    ram_membus.wmask       = mmio_ram_membus.wmask;
    mmio_ram_membus.rvalid = ram_membus.rvalid;
    mmio_ram_membus.rdata  = ram_membus.rdata;
}
</code></pre></div><h3 id="pcの初期値の変更" tabindex="-1">PCの初期値の変更 <a class="header-anchor" href="#pcの初期値の変更" aria-label="Permalink to “PCの初期値の変更”">​</a></h3><p>PCの初期値を<code>MMAP_RAM_BEGIN</code>にすることで、RAMのベースアドレスからプログラムの実行を開始するように変更します。 eeiパッケージに<code>INITIAL_PC</code>を定義し、PCのリセット時に利用します ( リスト30、 リスト31 )。</p><p><span class="caption">▼リスト11.30: PCの初期値を定義する (eei.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// pc on reset</span>
<span class="hljs-keyword">const</span> INITIAL_PC: Addr = MMAP_RAM_BEGIN;
</code></pre></div><p><span class="caption">▼リスト11.31: PCの初期値を設定する (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        if_pc           = <span class="custom-hl-bold">INITIAL_PC</span>;
        if_is_requested = <span class="hljs-number">0</span>;
        if_pc_requested = <span class="hljs-number">0</span>;
        if_fifo_wvalid  = <span class="hljs-number">0</span>;
        if_fifo_wdata   = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
</code></pre></div><p>riscv-testsを実行してRAMにアクセスできているか確認します。 今のところriscv-testsはアドレス<code>0</code>から配置されるようにリンクしているため、 riscv-testsの<code>env/p/link.ld</code>を変更します (リスト32)。</p><p><span class="caption">▼リスト11.32: プログラムの先頭のアドレスを変更する (riscv-tests/env/p/link.ld)</span></p><div class="language-ld"><button title="Copy Code" class="copy"></button><span class="lang">ld</span><pre class="hljs"><code>OUTPUT_ARCH( &quot;riscv&quot; )
ENTRY(_start)

SECTIONS
{
  . = <span class="custom-hl-bold">0x00000000</span>; ← 先頭を0x80000000に変更する (戻す)
</code></pre></div><p>riscv-testsをビルドしなおし、成果物をtestディレクトリに配置してください。 ビルドしなおしたので、HEXファイルを再度生成します (リスト33)。</p><p><span class="caption">▼リスト11.33: HEXファイルの再生成</span></p><div class="language-terminal"><button title="Copy Code" class="copy"></button><span class="lang">terminal</span><pre class="hljs"><code><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span></span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">find share/ -<span class="hljs-built_in">type</span> f -not -name <span class="hljs-string">&quot;*.dump&quot;</span> -<span class="hljs-built_in">exec</span> riscv64-unknown-elf-objcopy -O binary { {}.bin \;}</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">find share/ -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.bin&quot;</span> -<span class="hljs-built_in">exec</span> sh -c <span class="hljs-string">&quot;python3 bin2hex.py 8 { &gt; {}.hex&quot;</span> \;}</span>
</code></pre></div><p>riscv-testsの終了判定用のアドレスを<code>MMAP_RAM_BEGIN</code>基準のアドレスに変更します (リスト34)。</p><p><span class="caption">▼リスト11.34: .tohostのアドレスを変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>#[ifdef(TEST_MODE)]
<span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">let</span> RISCVTESTS_TOHOST_ADDR: Addr = <span class="custom-hl-bold">MMAP_RAM_BEGIN +</span> <span class="hljs-number">&#39;h1000</span> <span class="hljs-keyword">as</span> Addr;
    <span class="hljs-keyword">if</span> d_membus.valid &amp;&amp; d_membus.ready &amp;&amp; d_membus.wen == <span class="hljs-number">1</span> &amp;&amp; d_membus.addr == RISCVTESTS_TOHOST_ADDR &amp;&amp; d_membus.wdata[<span class="hljs-keyword">lsb</span>] == <span class="hljs-number">1&#39;b1</span> {
        test_success = d_membus.wdata == <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> d_membus.wdata == <span class="hljs-number">1</span> {
            $display(<span class="hljs-string">&quot;riscv-tests success!&quot;</span>);
        } <span class="hljs-keyword">else</span> {
            $display(<span class="hljs-string">&quot;riscv-tests failed!&quot;</span>);
            $error  (<span class="hljs-string">&quot;wdata : %h&quot;</span>, d_membus.wdata);
        }
        $finish();
    }
}
</code></pre></div><p>riscv-testsを実行し、RAMにアクセスできてテストに成功することを確認してください。</p><h2 id="romの実装" tabindex="-1">ROMの実装 <a class="header-anchor" href="#romの実装" aria-label="Permalink to “ROMの実装”">​</a></h2><h3 id="mmio-controllerモジュールにromを追加する" tabindex="-1">mmio_controllerモジュールにROMを追加する <a class="header-anchor" href="#mmio-controllerモジュールにromを追加する" aria-label="Permalink to “mmio_controllerモジュールにROMを追加する”">​</a></h3><p>mmio_controllerモジュールにROMとのインターフェースを実装します。</p><p><code>Device</code>型にROMを追加して、アドレスにROMをマップします ( リスト35、 リスト36 )。</p><p><span class="caption">▼リスト11.35: Device型にROMを変更する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">enum</span> Device {
    UNKNOWN,
    RAM,
    <span class="custom-hl-bold">ROM,</span>
}
</code></pre></div><p><span class="caption">▼リスト11.36: get_device関数でROMの範囲を定義する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> get_device (
    addr: <span class="hljs-keyword">input</span> Addr,
) -&gt; Device {
    <span class="custom-hl-bold"><span class="hljs-keyword">if</span> MMAP_ROM_BEGIN &lt;= addr &amp;&amp; addr &lt;= MMAP_ROM_END {</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">return</span> Device::ROM;</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">if</span> addr &gt;= MMAP_RAM_BEGIN {
        <span class="hljs-keyword">return</span> Device::RAM;
    }
    <span class="hljs-keyword">return</span> Device::UNKNOWN;
}
</code></pre></div><p>ROMとのインターフェースを追加します ( リスト37、 リスト38 )。 reset_all_device_masters関数でインターフェースをリセットします。</p><p><span class="caption">▼リスト11.37: ROMとのインターフェースを追加する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> mmio_controller (
    clk       : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">clock</span>         ,
    rst       : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">reset</span>         ,
    req_core  : <span class="hljs-keyword">modport</span> Membus::slave ,
    ram_membus: <span class="hljs-keyword">modport</span> Membus::master,
    <span class="custom-hl-bold">rom_membus: <span class="hljs-keyword">modport</span> Membus::master,</span>
) {
</code></pre></div><p><span class="caption">▼リスト11.38: インターフェースの要求部分をリセットする (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> reset_all_device_masters () {
    reset_membus_master(ram_membus);
    <span class="custom-hl-bold">reset_membus_master(rom_membus);</span>
}
</code></pre></div><p><code>ready</code>、<code>rvalid</code>を取得する関数にROMを登録します ( リスト39、 リスト40 )。</p><p><span class="caption">▼リスト11.39: インターフェースのreadyを返す (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> device {
    Device::RAM: <span class="hljs-keyword">return</span> ram_membus.ready;
    <span class="custom-hl-bold">Device::ROM: <span class="hljs-keyword">return</span> rom_membus.ready;</span>
    <span class="hljs-keyword">default</span>    : {}
}
</code></pre></div><p><span class="caption">▼リスト11.40: インターフェースのrvalidを返す (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> device {
    Device::RAM: <span class="hljs-keyword">return</span> ram_membus.rvalid;
    <span class="custom-hl-bold">Device::ROM: <span class="hljs-keyword">return</span> rom_membus.rvalid;</span>
    <span class="hljs-keyword">default</span>    : {}
}
</code></pre></div><p>ROMの<code>rvalid</code>、<code>rdata</code>を<code>req_core</code>に割り当てます ( リスト41 )。</p><p><span class="caption">▼リスト11.41: assign_device_slave関数でROMの結果をreqに割り当てる (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> device {
    Device::RAM: req &lt;&gt; ram_membus;
    <span class="custom-hl-bold">Device::ROM: req &lt;&gt; rom_membus;</span>
    <span class="hljs-keyword">default</span>    : {}
}
</code></pre></div><p>ROMのインターフェースに要求を割り当てます ( リスト42 )。 RAMと同じようにメモリマップのベースアドレスを引いたアドレスを割り当てます。</p><p><span class="caption">▼リスト11.42: get_device関数でROMにreqを割り当ててアクセス要求する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> get_device(req.addr) {
    Device::RAM: {
        ram_membus      &lt;&gt; req;
        ram_membus.addr -= MMAP_RAM_BEGIN;
    }
    <span class="custom-hl-bold">Device::ROM: {</span>
    <span class="custom-hl-bold">    rom_membus      &lt;&gt; req;</span>
    <span class="custom-hl-bold">    rom_membus.addr -= MMAP_ROM_BEGIN;</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">default</span>: {}
}
</code></pre></div><h3 id="romの初期値のパラメータを作成する" tabindex="-1">ROMの初期値のパラメータを作成する <a class="header-anchor" href="#romの初期値のパラメータを作成する" aria-label="Permalink to “ROMの初期値のパラメータを作成する”">​</a></h3><p>topモジュールにROMの初期値を指定するパラメータを定義します ( リスト43 )。</p><p><span class="caption">▼リスト11.43: パラメータを定義する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> top #(
    <span class="hljs-keyword">param</span> RAM_FILEPATH_IS_ENV: <span class="hljs-keyword">bit</span>    = <span class="hljs-number">1</span>              ,
    <span class="hljs-keyword">param</span> RAM_FILEPATH       : <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;RAM_FILE_PATH&quot;</span>,
    <span class="custom-hl-bold"><span class="hljs-keyword">param</span> ROM_FILEPATH_IS_ENV: <span class="hljs-keyword">bit</span>    = <span class="hljs-number">1</span>              ,</span>
    <span class="custom-hl-bold"><span class="hljs-keyword">param</span> ROM_FILEPATH       : <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;ROM_FILE_PATH&quot;</span>,</span>
) (
</code></pre></div><p>RAMと同じように、シミュレータ用のプログラムでROMのHEXファイルのパスを指定するようにします。 1番目の引数をROM用のHEXファイルのパスに変更し、環境変数<code>ROM_FILE_PATH</code>をその値に設定します ( リスト44、 リスト45、 リスト46、 リスト47、 リスト48 )。</p><p><span class="caption">▼リスト11.44: 引数の名称を変える (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-keyword">if</span> (argc &lt; <span class="custom-hl-bold"><span class="hljs-number">3</span></span>) {
    std::cout &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; <span class="custom-hl-bold">ROM_FILE_PATH</span> RAM_FILE_PATH [CYCLE]&quot;</span> &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre></div><p><span class="caption">▼リスト11.45: ROMのHEXファイルのパスを生成する (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-comment">// メモリの初期値を格納しているファイル名</span>
<span class="custom-hl-bold">std::string rom_file_path = argv[<span class="hljs-number">1</span>];</span>
std::string ram_file_path = argv[<span class="custom-hl-bold"><span class="hljs-number">2</span></span>];
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 絶対パスに変換する</span>
    <span class="custom-hl-bold">rom_file_path = fs::<span class="hljs-built_in">absolute</span>(rom_file_path).<span class="hljs-built_in">string</span>();</span>
    <span class="custom-hl-bold">ram_file_path = fs::<span class="hljs-built_in">absolute</span>(ram_file_path).<span class="hljs-built_in">string</span>();</span>
} <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {
    std::cerr &lt;&lt; <span class="hljs-string">&quot;Invalid memory file path : &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre></div><p><span class="caption">▼リスト11.46: 引数の数が変わったのでインデックスを変更する (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> cycles = <span class="hljs-number">0</span>;
<span class="hljs-keyword">if</span> (argc &gt;= <span class="custom-hl-bold"><span class="hljs-number">4</span></span>) {
    std::string cycles_string = argv[<span class="custom-hl-bold"><span class="hljs-number">3</span></span>];
    <span class="hljs-keyword">try</span> {
        cycles = <span class="hljs-built_in">stoull</span>(cycles_string);
    } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span class="hljs-string">&quot;Invalid number: &quot;</span> &lt;&lt; argv[<span class="custom-hl-bold"><span class="hljs-number">3</span></span>] &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}
</code></pre></div><p><span class="caption">▼リスト11.47: 環境変数を変更する (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="custom-hl-bold"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* original_env_rom = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;ROM_FILE_PATH&quot;</span>);</span>
<span class="hljs-type">const</span> <span class="hljs-type">char</span>* original_env_ram = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;RAM_FILE_PATH&quot;</span>);
<span class="custom-hl-bold"><span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;ROM_FILE_PATH&quot;</span>, rom_file_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">1</span>);</span>
<span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;RAM_FILE_PATH&quot;</span>, ram_file_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">1</span>);
</code></pre></div><p><span class="caption">▼リスト11.48: 環境変数を元に戻す (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="custom-hl-bold"><span class="hljs-keyword">if</span> (original_env_rom != <span class="hljs-literal">nullptr</span>){</span>
<span class="custom-hl-bold">    <span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;ROM_FILE_PATH&quot;</span>, original_env_rom, <span class="hljs-number">1</span>);</span>
<span class="custom-hl-bold">}</span>
<span class="hljs-keyword">if</span> (original_env_ram != <span class="hljs-literal">nullptr</span>){
    <span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;RAM_FILE_PATH&quot;</span>, original_env_ram, <span class="hljs-number">1</span>);
}
</code></pre></div><p>テストを実行するためのPythonプログラムでROMのHEXファイルを指定できるようにします ( リスト49、 リスト50、 リスト51 )。 デフォルト値はカレントディレクトリの<code>bootrom.hex</code>にしておきます。</p><p><span class="caption">▼リスト11.49: 引数--romを追加する (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code>parser.add_argument(<span class="hljs-string">&quot;--rom&quot;</span>, default=<span class="hljs-string">&quot;bootrom.hex&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;hex file of rom&quot;</span>)
</code></pre></div><p><span class="caption">▼リスト11.50: シミュレータにROMのHEXファイルのパスを渡す (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="custom-hl-bold">romhex, </span>file_name</span>):
    result_file_path = os.path.join(args.output_dir, file_name.replace(os.sep, <span class="hljs-string">&quot;_&quot;</span>) + <span class="hljs-string">&quot;.txt&quot;</span>)
    cmd = <span class="custom-hl-bold"><span class="hljs-string">f&quot;<span class="hljs-subst">{args.sim_path}</span> <span class="hljs-subst">{romhex}</span> <span class="hljs-subst">{file_name}</span> 0&quot;</span></span>
    success = <span class="hljs-literal">False</span>
</code></pre></div><p><span class="caption">▼リスト11.51: test関数にROMのHEXファイルのパスを渡す (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">for</span> hexpath <span class="hljs-keyword">in</span> dir_walk(args.<span class="hljs-built_in">dir</span>):
    f, s = test(<span class="custom-hl-bold">os.path.abspath(args.rom),</span> os.path.abspath(hexpath))
    res_strs.append((<span class="hljs-string">&quot;PASS&quot;</span> <span class="hljs-keyword">if</span> s <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;FAIL&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span> + f)
    res_statuses.append(s)
</code></pre></div><h3 id="romとmmio-controllerモジュールを接続する" tabindex="-1">ROMとmmio_controllerモジュールを接続する <a class="header-anchor" href="#romとmmio-controllerモジュールを接続する" aria-label="Permalink to “ROMとmmio_controllerモジュールを接続する”">​</a></h3><p>ROMをインスタンス化してmmio_controllerモジュールと接続します。</p><p>ROMとmmio_controllerモジュールを接続するインターフェース(<code>mmio_rom_membus</code>)、 ROMのインターフェース(<code>rom_membus</code>)を定義します (リスト52)。</p><p><span class="caption">▼リスト11.52: ROMのインターフェースの定義 (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> mmio_membus    : Membus;
<span class="hljs-keyword">inst</span> mmio_ram_membus: Membus;
<span class="custom-hl-bold"><span class="hljs-keyword">inst</span> mmio_rom_membus: Membus;</span>
<span class="hljs-keyword">inst</span> ram_membus     : membus_if::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;;
<span class="custom-hl-bold"><span class="hljs-keyword">inst</span> rom_membus     : membus_if::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt;;</span>
</code></pre></div><p>ROMをインスタンス化します ( リスト53 )。 パラメータにはtopモジュールのパラメータを割り当てます。</p><p><span class="caption">▼リスト11.53: ROMをインスタンス化する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> rom: memory::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt; #(
    FILEPATH_IS_ENV: ROM_FILEPATH_IS_ENV,
    FILEPATH       : ROM_FILEPATH       ,
) (
    clk               ,
    rst               ,
    membus: rom_membus,
);
</code></pre></div><p>mmio_controllerモジュールに<code>rom_membus</code>を接続します ( リスト54 )。</p><p><span class="caption">▼リスト11.54: ROMのインターフェースを接続する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> mmioc: mmio_controller (
    clk                        ,
    rst                        ,
    req_core  : mmio_membus    ,
    ram_membus: mmio_ram_membus,
    <span class="custom-hl-bold">rom_membus: mmio_rom_membus,</span>
);
</code></pre></div><p>mmio_controllerモジュールとROMを接続します。 アドレスの変換のためにaddr_to_memaddr関数を使用しています ( リスト55 )。</p><p><span class="caption">▼リスト11.55: mmio_controllerモジュールとROMを接続する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_comb</span> {
    <span class="hljs-comment">// mmio &lt;&gt; ROM</span>
    rom_membus.valid       = mmio_rom_membus.valid;
    mmio_rom_membus.ready  = rom_membus.ready;
    rom_membus.addr        = addr_to_memaddr::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt;(mmio_rom_membus.addr);
    rom_membus.wen         = <span class="hljs-number">0</span>;
    rom_membus.wdata       = <span class="hljs-number">0</span>;
    rom_membus.wmask       = <span class="hljs-number">0</span>;
    mmio_rom_membus.rvalid = rom_membus.rvalid;
    mmio_rom_membus.rdata  = rom_membus.rdata;
}
</code></pre></div><h3 id="romからramにジャンプする" tabindex="-1">ROMからRAMにジャンプする <a class="header-anchor" href="#romからramにジャンプする" aria-label="Permalink to “ROMからRAMにジャンプする”">​</a></h3><p>PCの初期値をROMのベースアドレスに変更し、 ROMからRAMにジャンプする仕組みを実現します。</p><p>一般的にCPUの電源をつけると、CPUはROMのようなメモリデバイスに入ったソフトウェアから実行を開始します。 そのソフトウェアは次に実行するソフトウェアを外部記憶装置から読み取り、 RAMにソフトウェアを適切にコピー、配置して実行します。</p><p>本章ではRAM、ROMともに<code>$readmemh</code>システムタスクで初期化するように実装しているので、 RAMのベースアドレスにジャンプするだけのプログラムをROMに設定します。</p><p>ROMに設定するためのHEXファイルを作成します (リスト56)。</p><p><span class="caption">▼リスト11.56: RAMの開始アドレスにジャンプするプログラム (bootrom.hex)</span></p><div class="language-hex"><button title="Copy Code" class="copy"></button><span class="lang">hex</span><pre class="hljs"><code>00409093080000b7 // 0: lui x1, 0x08000 4: slli x1, x1, 4
0000000000008067 // 8: jalr x0, 0(x1)  c:
0000000000000000 // zero

</code></pre></div><p>PCの初期値をROMのベースアドレスに変更します ( リスト57 )。</p><p><span class="caption">▼リスト11.57: PCの初期値の変更 (eei.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">const</span> INITIAL_PC: Addr = <span class="custom-hl-bold">MMAP_ROM_BEGIN</span>;
</code></pre></div><p>riscv-testsを実行し、 ROM(<code>0x1000</code>)から実行を開始して RAM(<code>0x80000000</code>)にジャンプしてテストを開始していることを確かめてください。</p><h2 id="デバッグ用の入出力デバイスの実装" tabindex="-1">デバッグ用の入出力デバイスの実装 <a class="header-anchor" href="#デバッグ用の入出力デバイスの実装" aria-label="Permalink to “デバッグ用の入出力デバイスの実装”">​</a></h2><p>CPUが文字を送信したり受信するためのデバッグ用の入出力デバイスを実装します。 今のところriscv-testsの結果を受け取るためのアドレスをRAMのベースアドレス + <code>0x1000</code>にしていますが、 この処理もデバイスに実装します。</p><p>本章では、デバッグ用の入出力デバイスに次のような64ビットレジスタを実装します。</p><dl><dt>上位20ビットが`20&#39;h01010`な値を書き込み</dt><dd> 下位8ビットを文字として解釈し`$write`システムタスクで出力します。 </dd><dt>上位20ビットが`20&#39;h01010`ではないLSBが`1`な値を書き込み</dt><dd> 今までのriscv-testsの終了判定処理を行います。 </dd><dt>読み込み</dt><dd> C++プログラムの関数を利用して1文字入力を受け取ります。 有効な入力の場合は上位20ビットが`20&#39;h01010`、無効な入力の場合は`0`になります。 </dd></dl><h3 id="デバイスのアドレスを設定する" tabindex="-1">デバイスのアドレスを設定する <a class="header-anchor" href="#デバイスのアドレスを設定する" aria-label="Permalink to “デバイスのアドレスを設定する”">​</a></h3><p>リスト9でデバイスのアドレスをポートで設定できるようにしたので、 <code>tb_verilator.cpp</code>で環境変数の値をデバイスのアドレスに設定するようにします。</p><p>環境変数<code>DBG_ADDR</code>を読み込み、<code>DBG_ADDR</code>ポートに設定します ( リスト58 )。</p><p><span class="caption">▼リスト11.58: DBG_ADDRポートに環境変数の値を設定する (tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-comment">// デバッグ用の入出力デバイスのアドレスを取得する</span>
<span class="custom-hl-bold"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbg_addr_c = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;DBG_ADDR&quot;</span>);</span>
<span class="custom-hl-bold"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> DBG_ADDR = dbg_addr_c == <span class="hljs-literal">nullptr</span> ? <span class="hljs-number">0</span> : std::<span class="hljs-built_in">strtoull</span>(dbg_addr_c, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);</span>

<span class="hljs-comment">// top</span>
Vcore_top *dut = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vcore_top</span>();
<span class="custom-hl-bold">dut-&gt;MMAP_DBG_ADDR = DBG_ADDR;</span>
</code></pre></div><h3 id="mmio-controllerモジュールにデバイスを追加する" tabindex="-1">mmio_controllerモジュールにデバイスを追加する <a class="header-anchor" href="#mmio-controllerモジュールにデバイスを追加する" aria-label="Permalink to “mmio_controllerモジュールにデバイスを追加する”">​</a></h3><p>mmio_controllerモジュールにデバイスを追加します。</p><p><code>Device</code>型に<code>Device::DEBUG</code>を追加します ( リスト59 )。</p><p><span class="caption">▼リスト11.59: Device型にデバッグ用の入出力デバイスを追加する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">enum</span> Device {
    UNKNOWN,
    RAM,
    ROM,
    <span class="custom-hl-bold">DEBUG,</span>
}
</code></pre></div><p>ポートにインターフェースとデバイスのアドレスを追加します ( リスト60、 リスト61 )。</p><p><span class="caption">▼リスト11.60: DBG_ADDR、インターフェースを追加する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> mmio_controller (
    clk       : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">clock</span>         ,
    rst       : <span class="hljs-keyword">input</span>   <span class="hljs-keyword">reset</span>         ,
    <span class="custom-hl-bold">DBG_ADDR  : <span class="hljs-keyword">input</span>   Addr          ,</span>
    req_core  : <span class="hljs-keyword">modport</span> Membus::slave ,
    ram_membus: <span class="hljs-keyword">modport</span> Membus::master,
    rom_membus: <span class="hljs-keyword">modport</span> Membus::master,
    <span class="custom-hl-bold">dbg_membus: <span class="hljs-keyword">modport</span> Membus::master,</span>
) {
</code></pre></div><p><span class="caption">▼リスト11.61: インターフェースの要求部分をリセットする (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> reset_all_device_masters () {
    reset_membus_master(ram_membus);
    reset_membus_master(rom_membus);
    <span class="custom-hl-bold">reset_membus_master(dbg_membus);</span>
}
</code></pre></div><p>デバイスの位置を設定します。 最初にチェックすることで、他のデバイスとアドレスを被らせたとしてもデバッグ用の入出力デバイスを優先します ( リスト62 )。</p><p><span class="caption">▼リスト11.62: get_device関数でデバイスの範囲を定義する (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> get_device (
    addr: <span class="hljs-keyword">input</span> Addr,
) -&gt; Device {
    <span class="custom-hl-bold"><span class="hljs-keyword">if</span> DBG_ADDR &lt;= addr &amp;&amp; addr &lt;= DBG_ADDR + <span class="hljs-number">7</span> {</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">return</span> Device::DEBUG;</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">if</span> MMAP_ROM_BEGIN &lt;= addr &amp;&amp; addr &lt;= MMAP_ROM_END {
        <span class="hljs-keyword">return</span> Device::ROM;
    }
    <span class="hljs-keyword">if</span> addr &gt;= MMAP_RAM_BEGIN {
        <span class="hljs-keyword">return</span> Device::RAM;
    }
    <span class="hljs-keyword">return</span> Device::UNKNOWN;
}
</code></pre></div><p>インターフェースを設定します ( リスト63、 リスト64、 リスト65、 リスト66 )。 この変更はROMを追加したときとほとんど同じです。</p><p><span class="caption">▼リスト11.63: assign_device_master関数の変更 (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> get_device(req.addr) {
    Device::RAM: {
        ram_membus      &lt;&gt; req;
        ram_membus.addr -= MMAP_RAM_BEGIN;
    }
    Device::ROM: {
        rom_membus      &lt;&gt; req;
        rom_membus.addr -= MMAP_ROM_BEGIN;
    }
    <span class="custom-hl-bold">Device::DEBUG: {</span>
    <span class="custom-hl-bold">    dbg_membus      &lt;&gt; req;</span>
    <span class="custom-hl-bold">    dbg_membus.addr -= DBG_ADDR;</span>
    <span class="custom-hl-bold">}</span>
    <span class="hljs-keyword">default</span>: {}
}
</code></pre></div><p><span class="caption">▼リスト11.64: assign_device_slave関数の変更 (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> device {
    Device::RAM  : req &lt;&gt; ram_membus;
    Device::ROM  : req &lt;&gt; rom_membus;
    <span class="custom-hl-bold">Device::DEBUG: req &lt;&gt; dbg_membus;</span>
    <span class="hljs-keyword">default</span>      : {}
}
</code></pre></div><p><span class="caption">▼リスト11.65: get_device_ready関数の変更 (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> device {
    Device::RAM  : <span class="hljs-keyword">return</span> ram_membus.ready;
    Device::ROM  : <span class="hljs-keyword">return</span> rom_membus.ready;
    <span class="custom-hl-bold">Device::DEBUG: <span class="hljs-keyword">return</span> dbg_membus.ready;</span>
    <span class="hljs-keyword">default</span>      : {}
}
</code></pre></div><p><span class="caption">▼リスト11.66: get_device_rvalid関数の変更 (mmio_controller.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> device {
    Device::RAM  : <span class="hljs-keyword">return</span> ram_membus.rvalid;
    Device::ROM  : <span class="hljs-keyword">return</span> rom_membus.rvalid;
    <span class="custom-hl-bold">Device::DEBUG: <span class="hljs-keyword">return</span> dbg_membus.rvalid;</span>
    <span class="hljs-keyword">default</span>      : {}
}
</code></pre></div><p>topモジュールにデバッグ用の入出力デバイスのインターフェース(<code>dbg_membus</code>)を定義し、 mmio_controllerモジュールと接続します ( リスト67、 リスト68 )。</p><p><span class="caption">▼リスト11.67: インターフェースのインスタンス化 (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> ram_membus     : membus_if::&lt;RAM_DATA_WIDTH, RAM_ADDR_WIDTH&gt;;
<span class="hljs-keyword">inst</span> rom_membus     : membus_if::&lt;ROM_DATA_WIDTH, ROM_ADDR_WIDTH&gt;;
<span class="custom-hl-bold"><span class="hljs-keyword">inst</span> dbg_membus     : Membus;</span>
</code></pre></div><p><span class="caption">▼リスト11.68: インターフェースを接続する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> mmioc: mmio_controller (
    clk                        ,
    rst                        ,
    DBG_ADDR  : MMAP_DBG_ADDR  ,
    req_core  : mmio_membus    ,
    ram_membus: mmio_ram_membus,
    rom_membus: mmio_rom_membus,
    <span class="custom-hl-bold">dbg_membus                 ,</span>
);
</code></pre></div><h3 id="出力を実装する" tabindex="-1">出力を実装する <a class="header-anchor" href="#出力を実装する" aria-label="Permalink to “出力を実装する”">​</a></h3><p><code>dbg_membus</code>を使い、デバッグ出力処理を実装します。 既存のriscv-testsの終了検知処理を次のように書き換えます ( リスト69 )。</p><p><span class="caption">▼リスト11.69: riscv-testsの終了検知処理をデバッグ用の入出力デバイスに変更する (top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// デバッグ用のIO</span>
<span class="hljs-keyword">always_ff</span> {
    dbg_membus.ready  = <span class="hljs-number">1</span>;
    dbg_membus.rvalid = dbg_membus.valid;
    <span class="hljs-keyword">if</span> dbg_membus.valid {
        <span class="hljs-keyword">if</span> dbg_membus.wen {
            <span class="hljs-keyword">if</span> dbg_membus.wdata[MEMBUS_DATA_WIDTH - <span class="hljs-number">1</span>-:<span class="hljs-number">20</span>] == <span class="hljs-number">20&#39;h01010</span> {
                $write(<span class="hljs-string">&quot;%c&quot;</span>, dbg_membus.wdata[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dbg_membus.wdata[<span class="hljs-keyword">lsb</span>] == <span class="hljs-number">1&#39;b1</span> {
                #[ifdef(TEST_MODE)]
                {
                    test_success = dbg_membus.wdata == <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">if</span> dbg_membus.wdata == <span class="hljs-number">1</span> {
                    $display(<span class="hljs-string">&quot;test success!&quot;</span>);
                } <span class="hljs-keyword">else</span> {
                    $display(<span class="hljs-string">&quot;test failed!&quot;</span>);
                    $error  (<span class="hljs-string">&quot;wdata : %h&quot;</span>, dbg_membus.wdata);
                }
                $finish();
            }
        }
    }
}
</code></pre></div><p>常に要求を受け付け、書き込みの時は書き込むデータ(<code>wdata</code>)を確認します。 <code>wdata</code>の上位20ビットが<code>20&#39;h01010</code>なら下位8ビットを出力し、 LSBが<code>1</code>ならテストの成功判定をして<code>$finish</code>システムタスクを呼び出します。</p><h3 id="出力をテストする" tabindex="-1">出力をテストする <a class="header-anchor" href="#出力をテストする" aria-label="Permalink to “出力をテストする”">​</a></h3><p>実装した出力デバイスで文字を出力できることを確認します。</p><p>デバッグ用に<code>$display</code>システムタスクで表示している情報が邪魔になるので、 デバッグ情報の表示を環境変数<code>PRINT_DEBUG</code>で制御できるようにします ( リスト70 )。</p><p><span class="caption">▼リスト11.70: デバッグ出力をdefineで囲う (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">///////////////////////////////// DEBUG /////////////////////////////////</span>
<span class="custom-hl-bold">#[ifdef(PRINT_DEBUG)]</span>
<span class="custom-hl-bold">{</span>
    <span class="hljs-keyword">var</span> clock_count: <span class="hljs-keyword">u64</span>;

    <span class="hljs-keyword">always_ff</span> {
        <span class="hljs-keyword">if_reset</span> {
            clock_count = <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            clock_count = clock_count + <span class="hljs-number">1</span>;

            $display(<span class="hljs-string">&quot;&quot;</span>);
            $display(<span class="hljs-string">&quot;# %d&quot;</span>, clock_count);
</code></pre></div><p><code>test/debug_output.c</code>を作成し、次のように記述します ( リスト71 )。 これは<code>Hello,world!</code>と出力するプログラムです。</p><p><span class="caption">▼リスト11.71: Hello,world!を出力するプログラム (test/debug_output.c)</span></p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_REG ((volatile unsigned long long*)0x40000000)</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">int</span> <span class="hljs-built_in">strlen</span> = <span class="hljs-number">13</span>;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">13</span>];

    str[<span class="hljs-number">0</span>]  = <span class="hljs-string">&#39;H&#39;</span>;
    str[<span class="hljs-number">1</span>]  = <span class="hljs-string">&#39;e&#39;</span>;
    str[<span class="hljs-number">2</span>]  = <span class="hljs-string">&#39;l&#39;</span>;
    str[<span class="hljs-number">3</span>]  = <span class="hljs-string">&#39;l&#39;</span>;
    str[<span class="hljs-number">4</span>]  = <span class="hljs-string">&#39;o&#39;</span>;
    str[<span class="hljs-number">5</span>]  = <span class="hljs-string">&#39;,&#39;</span>;
    str[<span class="hljs-number">6</span>]  = <span class="hljs-string">&#39;w&#39;</span>;
    str[<span class="hljs-number">7</span>]  = <span class="hljs-string">&#39;o&#39;</span>;
    str[<span class="hljs-number">8</span>]  = <span class="hljs-string">&#39;r&#39;</span>;
    str[<span class="hljs-number">9</span>]  = <span class="hljs-string">&#39;l&#39;</span>;
    str[<span class="hljs-number">10</span>] = <span class="hljs-string">&#39;d&#39;</span>;
    str[<span class="hljs-number">11</span>] = <span class="hljs-string">&#39;!&#39;</span>;
    str[<span class="hljs-number">12</span>] = <span class="hljs-string">&#39;\n&#39;</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>; i++) {
        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> c = str[i];
        *DEBUG_REG = c | (<span class="hljs-number">0x01010U</span>LL &lt;&lt; <span class="hljs-number">44</span>);
    }
    *DEBUG_REG = <span class="hljs-number">1</span>;
}
</code></pre></div><p><code>DEBUG_REG</code>は出力デバイスのアドレスです。 ここに<code>0x01010</code>を44ビット左シフトした値と文字をOR演算した値を書き込むことで文字を出力します。 最後に<code>1</code>を書き込み、テストを終了しています。</p><p>main関数をそのままコンパイルしてRAMに配置すると、 スタックポインタ(stack pointer, sp)の値が適切に設定されていないのでうまく動きません。 スタックポインタとは、プログラムが一時的に利用する値を格納しておくためのメモリ(スタック)のアドレスへのポインタのことです。 RISC-Vの規約ではsp(x2)レジスタをスタックポインタとして利用することが定められています。</p><p>そのため、レジスタの値を適切な値にリセットしてmain関数を呼び出す別のプログラムが必要です。 <code>test/entry.S</code>を作成し、次のように記述します ( リスト72 )。</p><p><span class="caption">▼リスト11.72: test/entry.S</span></p><div class="language-S"><button title="Copy Code" class="copy"></button><span class="lang">S</span><pre class="hljs"><code>.global _start
.section .text.init
_start:
    add x1, x0, x0
    la  x2, _stack_bottom
    add x3, x0, x0
    add x4, x0, x0
    add x5, x0, x0
    add x6, x0, x0
    add x7, x0, x0
    add x8, x0, x0
    add x9, x0, x0
    add x10, x0, x0
    add x11, x0, x0
    add x12, x0, x0
    add x13, x0, x0
    add x14, x0, x0
    add x15, x0, x0
    add x16, x0, x0
    add x17, x0, x0
    add x18, x0, x0
    add x19, x0, x0
    add x20, x0, x0
    add x21, x0, x0
    add x22, x0, x0
    add x23, x0, x0
    add x24, x0, x0
    add x25, x0, x0
    add x26, x0, x0
    add x27, x0, x0
    add x28, x0, x0
    add x29, x0, x0
    add x30, x0, x0
    add x31, x0, x0
    call main
</code></pre></div><p>このアセンブリはsp(x2)レジスタを<code>_stack_bottom</code>のアドレスに設定し、 他のレジスタを<code>0</code>でリセットしたあとに<code>main</code>にジャンプします。</p><p><code>_stack_bottom</code>は、リンカの設定ファイルに記述します。 <code>test/link.ld</code>を作成し、次のように記述します ( リスト73 )。</p><p><span class="caption">▼リスト11.73: test/link.ld</span></p><div class="language-ld"><button title="Copy Code" class="copy"></button><span class="lang">ld</span><pre class="hljs"><code>OUTPUT_ARCH( &quot;riscv&quot; )
ENTRY(_start)

SECTIONS
{
  . = 0x80000000;
  .text.init : { *(.text.init) }
  .text : { *(.text*) }
  .data : { *(.data*) }
  .bss : {*(.bss*)}
  .stack : {
    . = ALIGN(0x10);
    _stack_top = .;
    . += 4K;
    _stack_bottom = .;
  }
  _end = .;
}
</code></pre></div><p><code>_stack_bottom</code>と<code>_stack_top</code>の間は4KBあるので、スタックのサイズは4KBになります。 <code>_start</code>を<code>.text.init</code>に配置し(リスト72)、 <code>SECTIONS</code>の先頭に<code>.text.init</code>を配置しているため、 アドレス<code>0x80000000</code>に<code>_start</code>が配置されます。</p><p>これらのファイルを利用し、テストプログラムをコンパイルします (リスト74)。 gccの<code>-march</code>フラグではC拡張を抜いたISAを指定しています。 このフラグを記述しないと、まだ実装していない命令が含まれたELFファイルにコンパイルされてしまいます。</p><p><span class="caption">▼リスト11.74: テストプログラムをコンパイル、HEXファイルに変換する</span></p><div class="language-terminal"><button title="Copy Code" class="copy"></button><span class="lang">terminal</span><pre class="hljs"><code><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span></span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-gcc -nostartfiles -nostdlib -mcmodel=medany -T link.ld -march=rv64imad debug_output.c entry.S</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-objcopy a.out -O binary test.bin</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 bin2hex.py 8 test.bin &gt; test.bin.hex ← HEXファイルに変換する</span>
</code></pre></div><p>シミュレータをビルドし、テストプログラムを実行します (リスト75)。</p><p><span class="caption">▼リスト11.75: テストプログラムを実行する</span></p><div class="language-terminal"><button title="Copy Code" class="copy"></button><span class="lang">terminal</span><pre class="hljs"><code><span class="hljs-meta prompt_">$ </span><span class="language-bash">make build sim</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">DBG_ADDR=0x40000000 ./obj_dir/sim bootrom.hex <span class="hljs-built_in">test</span>/test.bin.hex</span>
Hello,world!
- ~/core/src/top.sv:62: Verilog $finish
</code></pre></div><p><code>Hello,world!</code>と出力されたあと、プログラムが終了しました。</p><h3 id="riscv-testsに対応する" tabindex="-1">riscv-testsに対応する <a class="header-anchor" href="#riscv-testsに対応する" aria-label="Permalink to “riscv-testsに対応する”">​</a></h3><p>riscv-testsを実行するとき、 終了判定用のレジスタの位置を<code>DBG_ADDR</code>に設定するようにします。</p><p><code>test/test.py</code>を、 ELFファイルを探して自動で<code>DBG_ADDR</code>を設定してテストを実行するプログラムに変更します。</p><p>elftools<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>を使用し、ELFファイルの判定、セクションのアドレスを取得する関数を定義します ( リスト76、 リスト77 )。</p><p><span class="caption">▼リスト11.76: elftoolsのimport (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">from</span> elftools.elf.elffile <span class="hljs-keyword">import</span> ELFFile
</code></pre></div><p><span class="caption">▼リスト11.77: ELFの判定、セクションのアドレスを取得する関数の定義 (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_elf</span>(<span class="hljs-params">filepath</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">&#39;rb&#39;</span>) <span class="hljs-keyword">as</span> f:
            magic_number = f.read(<span class="hljs-number">4</span>)
            <span class="hljs-keyword">return</span> magic_number == <span class="hljs-string">b&#39;\x7fELF&#39;</span>
    <span class="hljs-keyword">except</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_section_address</span>(<span class="hljs-params">filepath, section_name</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">&#39;rb&#39;</span>) <span class="hljs-keyword">as</span> f:
            elffile = ELFFile(f)
            <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> elffile.iter_sections():
                <span class="hljs-keyword">if</span> section.name == section_name:
                    <span class="hljs-keyword">return</span> section.header[<span class="hljs-string">&#39;sh_addr&#39;</span>]
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">except</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</code></pre></div><p>デバッグ用の入出力デバイスのセクション名を指定する引数を作成します ( リスト78 )。 また、テストするファイルの拡張子を指定していた引数を、 ELFファイルに付加することでHEXファイルのパスを得るための引数に変更します。</p><p><span class="caption">▼リスト11.78: オプションを追加する (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code>parser.add_argument(<span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;--extension&quot;</span>, default=<span class="hljs-string">&quot;<span class="custom-hl-bold">.bin.</span>hex&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;<span class="custom-hl-bold">hex</span> file extension&quot;</span>)
<span class="hljs-meta"><span class="custom-hl-bold">parser.add_argument(<span class="hljs-params"><span class="hljs-string">&quot;-d&quot;</span>, <span class="hljs-string">&quot;--debug_label&quot;</span>, default=<span class="hljs-string">&quot;.tohost&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;debug device label&quot;</span></span>)</span></span>
</code></pre></div><p>dir_walk関数を、ELFファイルを探す関数に変更します ( リスト79 )。</p><p><span class="caption">▼リスト11.79: dir_walk関数でELFファイルを探す (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">if</span> entry.is_file():
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="custom-hl-bold">is_elf(entry.path)</span>:
        <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args.files) == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">yield</span> entry.path
</code></pre></div><p>シミュレータの実行で<code>DBG_ADDR</code>を指定するようにします ( リスト80、 リスト81 )。</p><p><span class="caption">▼リスト11.80: DBG_ADDRをシミュレータに渡す (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="custom-hl-bold">dbg_addr,</span> romhex, file_name</span>):
    result_file_path = os.path.join(args.output_dir, file_name.replace(os.sep, <span class="hljs-string">&quot;_&quot;</span>) + <span class="hljs-string">&quot;.txt&quot;</span>)
<span class="hljs-meta">    <span class="custom-hl-bold">env = <span class="hljs-string">f&quot;DBG_ADDR=<span class="hljs-subst">{dbg_addr}</span> &quot;</span></span></span>
    cmd = <span class="hljs-string">f&quot;<span class="hljs-subst">{args.sim_path}</span> <span class="hljs-subst">{romhex}</span> <span class="hljs-subst">{file_name}</span> 0&quot;</span>
    success = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(result_file_path, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        no = f.fileno()
        p = subprocess.Popen(<span class="custom-hl-bold"><span class="hljs-string">&quot; &quot;</span>.join([env, <span class="hljs-string">&quot;exec&quot;</span>, cmd])</span>, shell=<span class="hljs-literal">True</span>, stdout=no, stderr=no)
</code></pre></div><p><span class="caption">▼リスト11.81: DBG_ADDRをtest関数に渡す (test/test.py)</span></p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="hljs"><code><span class="hljs-keyword">for</span> <span class="custom-hl-bold">elf</span>path <span class="hljs-keyword">in</span> dir_walk(args.<span class="hljs-built_in">dir</span>):
<span class="hljs-meta">    <span class="custom-hl-bold">hexpath = elfpath + args.extension</span></span>
<span class="hljs-meta">    <span class="custom-hl-bold">if not os.path.exists(<span class="hljs-params">hexpath</span>):</span></span>
<span class="hljs-meta">    <span class="custom-hl-bold">    print(<span class="hljs-params"><span class="hljs-string">&quot;SKIP :&quot;</span>, elfpath</span>)</span></span>
<span class="hljs-meta">    <span class="custom-hl-bold">    continue</span></span>
<span class="hljs-meta">    <span class="custom-hl-bold">dbg_addr = get_section_address(<span class="hljs-params">elfpath, args.debug_label</span>)</span></span>
    f, s = test(<span class="custom-hl-bold">dbg_addr,</span> os.path.abspath(args.rom), os.path.abspath(hexpath))
    res_strs.append((<span class="hljs-string">&quot;PASS&quot;</span> <span class="hljs-keyword">if</span> s <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;FAIL&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span> + f)
    res_statuses.append(s)
</code></pre></div><p><code>VERILATOR_FLAGS=&quot;-DTEST_MODE&quot;</code>をつけてシミュレータをビルドし、 riscv-testsが正常終了することを確かめてください。</p><h3 id="入力を実装する" tabindex="-1">入力を実装する <a class="header-anchor" href="#入力を実装する" aria-label="Permalink to “入力を実装する”">​</a></h3><p><code>dbg_membus</code>を使い、デバッグ入力処理を実装します。</p><p>まず、<code>src/tb_verilator.cpp</code>に、標準入力から1文字取得する関数を定義します ( リスト82 )。 入力がない場合は<code>0</code>、ある場合は上位20ビットを<code>0x01010</code>にした値を返します。</p><p><span class="caption">▼リスト11.82: 標準入力を1文字取得する関数の定義 (src/tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">get_input_dpic</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = <span class="hljs-number">0</span>;
    <span class="hljs-type">ssize_t</span> bytes_read = <span class="hljs-built_in">read</span>(STDIN_FILENO, &amp;c, <span class="hljs-number">1</span>);

    <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(c) | (<span class="hljs-number">0x01010ULL</span> &lt;&lt; <span class="hljs-number">44</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div><p>ここで、read関数の呼び出しでシミュレータを止めず(<code>O_NONBLOCK</code>)、 シェルが入力をバッファリングしなくする(<code>~ICANON</code>)ために設定を変えるコードを挿入します。 また、シェルが文字列をローカルエコー(入力した文字列を表示)しないようにします(<code>~ECHO</code>) ( リスト83、 リスト84、 リスト85 )。</p><p><span class="caption">▼リスト11.83: includeを追加する (src/tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;termios.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span>
</code></pre></div><p><span class="caption">▼リスト11.84: 設定を変更、復元する関数の定義 (src/tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">termios</span> old_setting;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore_termios_setting</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{
    <span class="hljs-built_in">tcsetattr</span>(STDIN_FILENO, TCSANOW, &amp;old_setting);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sighandler</span><span class="hljs-params">(<span class="hljs-type">int</span> signum)</span> </span>{
    <span class="hljs-built_in">restore_termios_setting</span>();
    <span class="hljs-built_in">exit</span>(signum);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_nonblocking</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">termios</span> new_setting;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tcgetattr</span>(STDIN_FILENO, &amp;old_setting) == <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;tcgetattr&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }
    new_setting = old_setting;
    new_setting.c_lflag &amp;= ~(ICANON | ECHO);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tcsetattr</span>(STDIN_FILENO, TCSANOW, &amp;new_setting) == <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;tcsetattr&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">signal</span>(SIGINT, sighandler);
    <span class="hljs-built_in">signal</span>(SIGTERM, sighandler);
    <span class="hljs-built_in">signal</span>(SIGQUIT, sighandler);
    <span class="hljs-built_in">atexit</span>(restore_termios_setting);

    <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(STDIN_FILENO, F_GETFL, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (flags == <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fcntl(F_GETFL)&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK) == <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fcntl(F_SETFL)&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }
}
</code></pre></div><p><span class="caption">▼リスト11.85: 設定を変える関数をmain関数から呼び出す (src/tb_verilator.cpp)</span></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>{
    Verilated::<span class="hljs-built_in">commandArgs</span>(argc, argv);

    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) {
        std::cout &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; ROM_FILE_PATH RAM_FILE_PATH [CYCLE]&quot;</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="custom-hl-bold"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ENABLE_DEBUG_INPUT</span></span>
        <span class="custom-hl-bold"><span class="hljs-built_in">set_nonblocking</span>();</span>
    <span class="custom-hl-bold"><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></span>
</code></pre></div><p><code>src/util.veryl</code>にget_input_dpic関数を呼び出す関数を実装します ( リスト86 )。</p><p><span class="caption">▼リスト11.86: get_input関数を定義する (src/util.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">embed</span> (inline) sv{{{
    <span class="hljs-keyword">package</span> svutil;
        ...
        <span class="custom-hl-bold"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> context <span class="hljs-keyword">function</span> longint get_input_dpic();</span>
        <span class="custom-hl-bold"><span class="hljs-keyword">function</span> longint get_input();</span>
        <span class="custom-hl-bold">    <span class="hljs-keyword">return</span> get_input_dpic();</span>
        <span class="custom-hl-bold">endfunction</span>
    endpackage
}}}

<span class="hljs-keyword">package</span> util {
    ...
    <span class="custom-hl-bold"><span class="hljs-keyword">function</span> get_input () -&gt; <span class="hljs-keyword">u64</span> {</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">return</span> $sv::svutil::get_input();</span>
    <span class="custom-hl-bold">}</span>
}
</code></pre></div><p>デバッグ用の入出力デバイスのロードで<code>util::get_input</code>の結果を返すようにします ( リスト87 )。 このコードは合成できないので、有効化オプション<code>ENABLE_DEBUG_INPUT</code>をつけます。</p><p><span class="caption">▼リスト11.87: 読み込みでget_input関数を呼び出す (src/top.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_ff</span> {
    dbg_membus.ready  = <span class="hljs-number">1</span>;
    dbg_membus.rvalid = dbg_membus.valid;
    <span class="hljs-keyword">if</span> dbg_membus.valid {
        <span class="hljs-keyword">if</span> dbg_membus.wen {
            ...
        <span class="custom-hl-bold">} <span class="hljs-keyword">else</span> {</span>
        <span class="custom-hl-bold">    #[ifdef(ENABLE_DEBUG_INPUT)]</span>
        <span class="custom-hl-bold">    {</span>
        <span class="custom-hl-bold">        dbg_membus.rdata = util::get_input();</span>
        <span class="custom-hl-bold">    }</span>
        }
    }
}
</code></pre></div><h3 id="入力をテストする" tabindex="-1">入力をテストする <a class="header-anchor" href="#入力をテストする" aria-label="Permalink to “入力をテストする”">​</a></h3><p>実装した入出力デバイスで文字を入出力できることを確認します。</p><p><code>test/debug_input.c</code>を作成し、次のように記述します ( リスト88 )。 これは入力された文字に<code>1</code>を足した値を出力するプログラムです。</p><p><span class="caption">▼リスト11.88: test/debug_input.c</span></p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_REG ((volatile unsigned long long*)0x40000000)</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> c = *DEBUG_REG;
        <span class="hljs-keyword">if</span> (c &amp; (<span class="hljs-number">0x01010U</span>LL &lt;&lt; <span class="hljs-number">44</span>) == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">continue</span>;
        }
        c = c &amp; <span class="hljs-number">255</span>;
        *DEBUG_REG = (c + <span class="hljs-number">1</span>) | (<span class="hljs-number">0x01010U</span>LL &lt;&lt; <span class="hljs-number">44</span>);
    }
}
</code></pre></div><p>プログラムをコンパイルしてシミュレータを実行し、入力した文字が1文字ずれて表示されることを確認してください (リスト89)。</p><p><span class="caption">▼リスト11.89: テストプログラムを実行する</span></p><div class="language-terminal"><button title="Copy Code" class="copy"></button><span class="lang">terminal</span><pre class="hljs"><code><span class="hljs-meta prompt_">$ </span><span class="language-bash">make build sim VERILATOR_FLAGS=<span class="hljs-string">&quot;-DENABLE_DEBUG_INPUT&quot;</span> ← 入力を有効にしてシミュレータをビルド</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">./obj_dir/sim bootrom.hex <span class="hljs-built_in">test</span>/test.bin.hex ← (事前にHEXファイルを作成しておく</span>
bcd← abcと入力して改行
   efg← defと入力する
</code></pre></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>本章では実際のRAMデバイスへのアクセスを実装せずmemoryモジュールで代用します。FPGAに合成するときに実際のデバイスへのアクセスに置き換えます。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>pipでインストールできます <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/11-impl-exception.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>10 例外の実装</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/13-impl-a.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>12 A拡張の実装</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"00-preface.md\":\"CYEphBX8\",\"02-setup.md\":\"da1pIHNs\",\"03-veryl.md\":\"VOHmUq3V\",\"04-impl-rv32i.md\":\"FgWBQBal\",\"04a-zicsr.md\":\"Byr-K33R\",\"04b-riscvtests.md\":\"B4GMYxg-\",\"05-impl-rv64i.md\":\"DVfSQV68\",\"05a-pipeline.md\":\"DtXP2GXx\",\"05b-synth.md\":\"NGZD_xuU\",\"10-impl-m.md\":\"CnhgZ3g7\",\"100-contribute.md\":\"DBSud0cg\",\"11-impl-exception.md\":\"JeKJu-NB\",\"12-impl-mmio.md\":\"CHiBJDdb\",\"13-impl-a.md\":\"CQ1P-hqL\",\"14-impl-c.md\":\"Drvqq3UO\",\"20-mmode-csr.md\":\"C1moV3lH\",\"21-impl-interrupt.md\":\"DIdFSguo\",\"22-umode-csr.md\":\"BR3vJ2Cm\",\"23-smode-csr.md\":\"DPRd2qbY\",\"24-impl-paging.md\":\"FH2l8By1\",\"25-impl-plic.md\":\"C-IgoZUO\",\"26-run-linux.md\":\"CwWfT7wp\",\"99-postface.md\":\"DKyCFrvU\",\"99b-postface.md\":\"Cxpm5DbS\",\"index.md\":\"DsKG6qhs\"}");function deserializeFunctions(r){return Array.isArray(r)?r.map(deserializeFunctions):typeof r=="object"&&r!==null?Object.keys(r).reduce((t,n)=>(t[n]=deserializeFunctions(r[n]),t),{}):typeof r=="string"&&r.startsWith("_vp-fn_")?new Function(`return ${r.slice(7)}`)():r};window.__VP_SITE_DATA__=deserializeFunctions(JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Verylで作るCPU\",\"description\":\"Write RISC-V CPU in Veryl\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[],\"sidebar\":[{\"text\":\"第I部 RV32I/RV64Iの実装\",\"items\":[{\"text\":\"まえがき\",\"link\":\"/00-preface\"},{\"text\":\"1 環境構築\",\"link\":\"/02-setup\"},{\"text\":\"2 ハードウェア記述言語 Veryl\",\"link\":\"/03-veryl\"},{\"text\":\"3 RV32Iの実装\",\"link\":\"/04-impl-rv32i\"},{\"text\":\"4 Zicsr拡張の実装\",\"link\":\"/04a-zicsr\"},{\"text\":\"5 riscv-testsによるテスト\",\"link\":\"/04b-riscvtests\"},{\"text\":\"6 RV64Iの実装\",\"link\":\"/05-impl-rv64i\"},{\"text\":\"7 CPUのパイプライン化\",\"link\":\"/05a-pipeline\"},{\"text\":\"8 CPUの合成\",\"link\":\"/05b-synth\"}]},{\"text\":\"第II部 RV64IMACの実装\",\"items\":[{\"text\":\"9 M拡張の実装\",\"link\":\"/10-impl-m\"},{\"text\":\"10 例外の実装\",\"link\":\"/11-impl-exception\"},{\"text\":\"11 Memory-mapped I/Oの実装\",\"link\":\"/12-impl-mmio\"},{\"text\":\"12 A拡張の実装\",\"link\":\"/13-impl-a\"},{\"text\":\"13 C拡張の実装\",\"link\":\"/14-impl-c\"}]},{\"text\":\"第III部 特権/割り込みの実装\",\"items\":[{\"text\":\"14 M-modeの実装 (1. CSRの実装)\",\"link\":\"/20-mmode-csr\"},{\"text\":\"15 M-modeの実装 (2. 割り込みの実装)\",\"link\":\"/21-impl-interrupt\"},{\"text\":\"16 U-modeの実装\",\"link\":\"/22-umode-csr\"},{\"text\":\"17 S-modeの実装 (1. CSRの実装)\",\"link\":\"/23-smode-csr\"},{\"text\":\"18 S-modeの実装 (2. 仮想記憶システム)\",\"link\":\"/24-impl-paging\"},{\"text\":\"19 PLICの実装\",\"link\":\"/25-impl-plic\"},{\"text\":\"20 Linuxを動かす\",\"link\":\"/26-run-linux\"},{\"text\":\"あとがき (第Ⅰ部)\",\"link\":\"/99-postface\"},{\"text\":\"あとがき (第Ⅱ部、第Ⅲ部)\",\"link\":\"/99b-postface\"},{\"text\":\"このプロジェクトに貢献する\",\"link\":\"/100-contribute\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/nananapo/veryl-riscv-book\"}],\"outline\":{\"level\":[2,4]},\"search\":{\"provider\":\"local\",\"options\":{\"miniSearch\":{\"options\":{\"tokenize\":\"_vp-fn_(term) => {\\n              if (typeof term === \\\"string\\\") term = term.toLowerCase();\\n              const segmenter = Intl.Segmenter && new Intl.Segmenter(\\\"ja-JP\\\", { granularity: \\\"word\\\" });\\n              if (!segmenter) return [term];\\n              const tokens = [];\\n              for (const seg of segmenter.segment(term)) {\\n                if (seg.segment.trim() !== \\\"\\\") tokens.push(seg.segment);\\n              }\\n              return tokens;\\n            }\"}}}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}"));</script>
    
  </body>
</html>