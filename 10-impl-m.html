<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>M拡張の実装 | Verylで作るCPU</title>
    <meta name="description" content="Write RISC-V CPU in Veryl">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/assets/style.BkDLSfDv.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.C5T7VUJy.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.Bi7Ru2r6.js">
    <link rel="modulepreload" href="/assets/chunks/framework.D5l_65jD.js">
    <link rel="modulepreload" href="/assets/10-impl-m.md.UxkEDKtO.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-9f75dce3><div class="VPNavBar" data-v-9f75dce3 data-v-2a96a3d0><div class="wrapper" data-v-2a96a3d0><div class="container" data-v-2a96a3d0><div class="title" data-v-2a96a3d0><div class="VPNavBarTitle has-sidebar" data-v-2a96a3d0 data-v-1e38c6bc><a class="title" href="/" data-v-1e38c6bc><!--[--><!--]--><!----><span data-v-1e38c6bc>Verylで作るCPU</span><!--[--><!--]--></a></div></div><div class="content" data-v-2a96a3d0><div class="content-body" data-v-2a96a3d0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2a96a3d0><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2a96a3d0 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2a96a3d0 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2a96a3d0 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/nananapo/veryl-riscv-book" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2a96a3d0 data-v-bb2aa2f0 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/nananapo/veryl-riscv-book" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2a96a3d0 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-2a96a3d0><div class="divider-line" data-v-2a96a3d0></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-8acdfeb5><div class="container" data-v-8acdfeb5><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-8acdfeb5><span class="vpi-align-left menu-icon" data-v-8acdfeb5></span><span class="menu-text" data-v-8acdfeb5>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-8acdfeb5 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-e7c6e512><div class="curtain" data-v-e7c6e512></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e7c6e512><span class="visually-hidden" id="sidebar-aria-label" data-v-e7c6e512> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>第I部 RV32I/RV64Iの実装</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/00-preface.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>まえがき</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/02-setup.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>1 環境構築</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/03-veryl.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>2 ハードウェア記述言語 Veryl</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/04-impl-rv32i.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>3 RV32Iの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/04a-zicsr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>4 Zicsr拡張の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/04b-riscvtests.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>5 riscv-testsによるテスト</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/05-impl-rv64i.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>6 RV64Iの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/05a-pipeline.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>7 CPUのパイプライン化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/05b-synth.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>8 CPUの合成</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>第II部 RV64IMACの実装</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/10-impl-m.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>9 M拡張の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/11-impl-exception.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>10 例外の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/12-impl-mmio.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>11 Memory-mapped I/Oの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/13-impl-a.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>12 A拡張の実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/14-impl-c.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>13 C拡張の実装</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>第III部 特権/割り込みの実装</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/20-mmode-csr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>14 M-modeの実装 (1. CSRの実装)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/21-impl-interrupt.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>15 M-modeの実装 (2. 割り込みの実装)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/22-umode-csr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>16 U-modeの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/23-smode-csr.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>17 S-modeの実装 (1. CSRの実装)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/24-impl-paging.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>18 S-modeの実装 (2. 仮想記憶システム)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/25-impl-plic.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>19 PLICの実装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/26-run-linux.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>20 Linuxを動かす</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/99-postface.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>あとがき (第Ⅰ部)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/99b-postface.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>あとがき (第Ⅱ部、第Ⅲ部)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/100-contribute.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>このプロジェクトに貢献する</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-aff0b8d7><div class="VPDoc has-sidebar has-aside" data-v-aff0b8d7 data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-2d0bdf9b><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _10-impl-m" data-v-7011f0d8><div><h1 id="m拡張の実装" tabindex="-1">M拡張の実装 <a class="header-anchor" href="#m拡張の実装" aria-label="Permalink to “M拡張の実装”">​</a></h1><h2 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to “概要”">​</a></h2><p>「第I部 RV32I / RV64Iの実装」ではRV64IのCPUを実装しました。 「第II部 RV64IMACの実装」では、次のような機能を実装します。</p><ul><li>乗算、除算、剰余演算命令 (M拡張)</li><li>不可分操作命令 (A拡張)</li><li>圧縮命令 (C拡張)</li><li>例外</li><li>Memory-mapped I/O</li></ul><p>本章では積、商、剰余を求める命令を実装します。 RISC-Vの乗算、除算、剰余演算を行う命令はM拡張に定義されており、 M拡張を実装したRV64IのISAのことを<code>RV64IM</code>と表記します。</p><p>M拡張には、XLENが<code>32</code>のときは表1の命令が定義されています。 XLENが<code>64</code>のときは表2の命令が定義されています。</p><div id="m.instructions.32" class="table"><p class="caption">表9.1: M拡張の命令 (XLEN=32)</p><table><tr class="hline"><th>命令</th><th>動作</th></tr><tr class="hline"><td>MUL</td><td>rs1(符号付き) × rs2(符号付き)の結果(64ビット)の下位32ビットを求める</td></tr><tr class="hline"><td>MULH</td><td>rs1(符号付き) × rs2(符号付き)の結果(64ビット)の上位32ビットを求める</td></tr><tr class="hline"><td>MULHU</td><td>rs1(符号無し) × rs2(符号無し)の結果(64ビット)の上位32ビットを求める</td></tr><tr class="hline"><td>MULHSU</td><td>rs1(符号付き) × rs2(符号無し)の結果(64ビット)の上位32ビットを求める</td></tr><tr class="hline"><td>DIV</td><td>rs1(符号付き) / rs2(符号付き)を求める</td></tr><tr class="hline"><td>DIVU</td><td>rs1(符号無し) / rs2(符号無し)を求める</td></tr><tr class="hline"><td>REM</td><td>rs1(符号付き) % rs2(符号付き)を求める</td></tr><tr class="hline"><td>REMU</td><td>rs1(符号無し) % rs2(符号無し)を求める</td></tr></table></div><div id="m.instructions.64" class="table"><p class="caption">表9.2: M拡張の命令 (XLEN=64)</p><table><tr class="hline"><th>命令</th><th>動作</th></tr><tr class="hline"><td>MUL</td><td>rs1(符号付き) × rs2(符号付き)の結果(128ビット)の下位64ビットを求める</td></tr><tr class="hline"><td>MULW</td><td>rs1[31:0](符号付き) × rs2[31:0](符号付き)の結果(64ビット)の下位32ビットを求める<br>結果は符号拡張する</td></tr><tr class="hline"><td>MULH</td><td>rs1(符号付き) × rs2(符号付き)の結果(128ビット)の上位64ビットを求める</td></tr><tr class="hline"><td>MULHU</td><td>rs1(符号無し) × rs2(符号無し)の結果(128ビット)の上位64ビットを求める</td></tr><tr class="hline"><td>MULHSU</td><td>rs1(符号付き) × rs2(符号無し)の結果(128ビット)の上位64ビットを求める</td></tr><tr class="hline"><td>DIV</td><td>rs1(符号付き) / rs2(符号付き)を求める</td></tr><tr class="hline"><td>DIVW</td><td>rs1[31:0](符号付き) / rs2[31:0](符号付き)を求める<br>結果は符号拡張する</td></tr><tr class="hline"><td>DIVU</td><td>rs1(符号無し) / rs2(符号無し)を求める</td></tr><tr class="hline"><td>DIVWU</td><td>rs1[31:0](符号無し) / rs2[31:0](符号無し)を求める<br>結果は符号拡張する</td></tr><tr class="hline"><td>REM</td><td>rs1(符号付き) % rs2(符号付き)を求める</td></tr><tr class="hline"><td>REMW</td><td>rs1[31:0](符号付き) % rs2[31:0](符号付き)を求める<br>結果は符号拡張する</td></tr><tr class="hline"><td>REMU</td><td>rs1(符号無し) % rs2(符号無し)を求める</td></tr><tr class="hline"><td>REMUW</td><td>rs1[31:0](符号無し) % rs2[31:0](符号無し)を求める<br>結果は符号拡張する</td></tr></table></div> Verylには積、商、剰余を求める演算子`*`、`/`、`%`が定義されており、 これを利用することで簡単に計算を実装できます(リスト1)。 <p><span class="caption">▼リスト9.1: 演算子による実装例</span></p><div class="language-by"><button title="Copy Code" class="copy"></button><span class="lang">by</span><pre class="hljs"><code>assign mul = op1 * op2;
assign div = op1 / op2;
assign rem = op1 % op2;
</code></pre></div><p>例えば乗算回路をFPGA上に実装する場合、通常は合成系によってFPGAに搭載されている乗算器が自動的に利用されます<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。 これにより、低遅延、低リソースコストで効率的な乗算回路を自動的に実現できます。 しかし、32ビットや64ビットの乗算を実装する際、 FPGA上の乗算器の数が不足すると、LUTを用いた大規模な乗算回路が構築されることがあります。 このような大規模な回路はFPGAのリソースの使用量や遅延に大きな影響を与えるため好ましくありません。 除算や剰余演算でも同じ問題<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>が生じることがあります。</p><p><code>*</code>、<code>/</code>、<code>%</code>演算子がどのような回路に合成されるかは、 合成系が全体の実装を考慮して自動的に決定するため、 その挙動をコントロールするのは難しいです。 そこで本章では、<code>*</code>、<code>/</code>、<code>%</code>演算子を使用せず、 足し算やシフト演算などの基本的な論理だけを用いて同等の演算を実装します。</p><p>基本編では積、商、剰余を効率よく<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>求める実装は検討せず、できるだけ単純な方法で実装します。</p><h2 id="命令のデコード" tabindex="-1">命令のデコード <a class="header-anchor" href="#命令のデコード" aria-label="Permalink to “命令のデコード”">​</a></h2><p>まず、M拡張の命令をデコードします。 M拡張の命令はすべてR形式であり、レジスタの値同士の演算を行います。 funct7は<code>7&#39;b0000001</code>です。 MUL、MULH、MULHSU、MULHU、DIV、DIVU、REM、REMU命令のopcodeは<code>7&#39;b0110011</code>(OP)で、 MULW、DIVW、DIVUW、REMW、REMUW命令のopcodeは<code>7&#39;b0111011</code>(OP-32)です。</p><p>それぞれの命令はfunct3で区別します(表3)。 乗算命令のfunct3はMSBが<code>0</code>、除算と剰余演算命令は<code>1</code>になっています。</p><div id="m.funct3.64" class="table"><p class="caption">表9.3: M拡張の命令の区別</p><table><tr class="hline"><th>命令</th><th>funct3</th></tr><tr class="hline"><td>MUL、MULW</td><td>000</td></tr><tr class="hline"><td>MULH</td><td>001</td></tr><tr class="hline"><td>MULHU</td><td>010</td></tr><tr class="hline"><td>MULHSU</td><td>011</td></tr><tr class="hline"><td>DIV、DIVW</td><td>100</td></tr><tr class="hline"><td>DIVU、DIVWU</td><td>101</td></tr><tr class="hline"><td>REM、REMW</td><td>110</td></tr><tr class="hline"><td>REMU、REMUW</td><td>111</td></tr></table></div> `InstCtrl`構造体に、 M拡張の命令であることを示す`is_muldiv`フラグを追加します (リスト2)。 <p><span class="caption">▼リスト9.2: is_muldivフラグを追加する (corectrl.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// 制御に使うフラグ用の構造体</span>
<span class="hljs-keyword">struct</span> InstCtrl {
    itype    : InstType   , <span class="hljs-comment">// 命令の形式</span>
    rwb_en   : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// レジスタに書き込むかどうか</span>
    is_lui   : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// LUI命令である</span>
    is_aluop : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// ALUを利用する命令である</span>
    <span class="custom-hl-bold">is_muldiv: <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// M拡張の命令である</span></span>
    is_op32  : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// OP-32またはOP-IMM-32である</span>
    is_jump  : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// ジャンプ命令である</span>
    is_load  : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// ロード命令である</span>
    is_csr   : <span class="hljs-keyword">logic</span>      , <span class="hljs-comment">// CSR命令である</span>
    funct3   : <span class="hljs-keyword">logic</span>   &lt;<span class="hljs-number">3</span>&gt;, <span class="hljs-comment">// 命令のfunct3フィールド</span>
    funct7   : <span class="hljs-keyword">logic</span>   &lt;<span class="hljs-number">7</span>&gt;, <span class="hljs-comment">// 命令のfunct7フィールド</span>
}
</code></pre></div><p>inst_decoderモジュールの<code>InstCtrl</code>を生成している部分を変更します。 opcodeが<code>OP</code>か<code>OP-32</code>の場合はfunct7の値によって<code>is_muldiv</code>を設定します(リスト3)。 その他のopcodeの<code>is_muldiv</code>は<code>F</code>に設定してください。</p><p><span class="caption">▼リスト9.3: is_muldivを設定する (inst_decoder.veryl) (一部)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>OP_OP: {
    InstType::R, T, F, T, <span class="custom-hl-bold">f7 == <span class="hljs-number">7&#39;b0000001</span>,</span> F, F, F, F
},
OP_OP_IMM: {
    InstType::I, T, F, T, <span class="custom-hl-bold">F,</span> F, F, F, F
},
OP_OP_32: {
    InstType::R, T, F, T, <span class="custom-hl-bold">f7 == <span class="hljs-number">7&#39;b0000001</span>,</span> T, F, F, F
},
</code></pre></div><h2 id="muldivunitモジュールの実装" tabindex="-1">muldivunitモジュールの実装 <a class="header-anchor" href="#muldivunitモジュールの実装" aria-label="Permalink to “muldivunitモジュールの実装”">​</a></h2><h3 id="muldivunitモジュールを作成する" tabindex="-1">muldivunitモジュールを作成する <a class="header-anchor" href="#muldivunitモジュールを作成する" aria-label="Permalink to “muldivunitモジュールを作成する”">​</a></h3><p>M拡張の計算を処理するモジュールを作成し、 M拡張の命令がALUの結果ではなくモジュールの結果を利用するように変更します。</p><p><code>src/muldivunit.veryl</code>を作成し、次のように記述します(リスト4)。</p><p><span class="caption">▼リスト9.4: muldivunit.veryl</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">import</span> eei::*;

<span class="hljs-keyword">module</span> muldivunit (
    clk   : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">clock</span>   ,
    rst   : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">reset</span>   ,
    ready : <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>   ,
    valid : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>   ,
    funct3: <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;,
    op1   : <span class="hljs-keyword">input</span>  UIntX   ,
    op2   : <span class="hljs-keyword">input</span>  UIntX   ,
    rvalid: <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>   ,
    result: <span class="hljs-keyword">output</span> UIntX   ,
) {

    <span class="hljs-keyword">enum</span> State {
        Idle,
        WaitValid,
        Finish,
    }

    <span class="hljs-keyword">var</span> state: State;

    <span class="hljs-comment">// saved_data</span>
    <span class="hljs-keyword">var</span> funct3_saved: <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;;

    <span class="hljs-keyword">always_comb</span> {
        ready  = state == State::Idle;
        rvalid = state == State::Finish;
    }

    <span class="hljs-keyword">always_ff</span> {
        <span class="hljs-keyword">if_reset</span> {
            state        = State::Idle;
            result       = <span class="hljs-number">0</span>;
            funct3_saved = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">case</span> state {
                State::Idle: <span class="hljs-keyword">if</span> ready &amp;&amp; valid {
                    state        = State::WaitValid;
                    funct3_saved = funct3;
                }
                State::WaitValid: state = State::Finish;
                State::Finish   : state = State::Idle;
                <span class="hljs-keyword">default</span>         : {}
            }
        }
    }
}
</code></pre></div><p>muldivunitモジュールは<code>ready</code>が<code>1</code>のときに計算のリクエストを受け付けます。 <code>valid</code>が<code>1</code>なら計算を開始し、 計算が終了したら<code>rvalid</code>を<code>1</code>、計算結果を<code>result</code>に設定します。</p><p>まだ計算処理を実装しておらず、<code>result</code>は常に<code>0</code>を返します。 次の計算を開始するまで<code>result</code>の値を維持します。</p><h3 id="exステージを変更する" tabindex="-1">EXステージを変更する <a class="header-anchor" href="#exステージを変更する" aria-label="Permalink to “EXステージを変更する”">​</a></h3><p>M拡張の命令がEXステージにあるとき、ALUの結果の代わりにmuldivunitモジュールの結果を利用するように変更します。</p><p>まず、muldivunitモジュールをインスタンス化します(リスト5)。</p><p><span class="caption">▼リスト9.5: muldivunitモジュールをインスタンス化する (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> exs_muldiv_valid : <span class="hljs-keyword">logic</span> = exs_valid &amp;&amp; exs_ctrl.is_muldiv &amp;&amp; !exs_data_hazard &amp;&amp; !exs_muldiv_is_requested;
<span class="hljs-keyword">var</span> exs_muldiv_ready : <span class="hljs-keyword">logic</span>;
<span class="hljs-keyword">var</span> exs_muldiv_rvalid: <span class="hljs-keyword">logic</span>;
<span class="hljs-keyword">var</span> exs_muldiv_result: UIntX;

<span class="hljs-keyword">inst</span> mdu: muldivunit (
    clk                      ,
    rst                      ,
    valid : exs_muldiv_valid ,
    ready : exs_muldiv_ready ,
    funct3: exs_ctrl.funct3  ,
    op1   : exs_op1          ,
    op2   : exs_op2          ,
    rvalid: exs_muldiv_rvalid,
    result: exs_muldiv_result,
);
</code></pre></div><p>muldivunitモジュールで計算を開始するのは、 EXステージに命令が存在し(<code>exs_valid</code>)、 命令がM拡張の命令であり(<code>exs_ctrl.is_muldiv</code>)、 データハザードが発生しておらず(<code>!exs_data_hazard</code>)、 既に計算を要求していない(<code>!exs_muldiv_is_requested</code>) 場合です。</p><p><code>exs_muldiv_is_requested</code>変数を定義し、 ステージの遷移条件とmuldivunitに計算を要求したかの状態によって値を更新します(リスト6)。</p><p><span class="caption">▼リスト9.6: exs_muldiv_is_requested変数 (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">var</span> exs_muldiv_is_requested: <span class="hljs-keyword">logic</span>;

<span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        exs_muldiv_is_requested = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 次のステージに遷移</span>
        <span class="hljs-keyword">if</span> exq_rvalid &amp;&amp; exq_rready {
            exs_muldiv_is_requested = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// muldivunitにリクエストしたか判定する</span>
            <span class="hljs-keyword">if</span> exs_muldiv_valid &amp;&amp; exs_muldiv_ready {
                exs_muldiv_is_requested = <span class="hljs-number">1</span>;
            }
        }
    }
}
</code></pre></div><p>muldivunitモジュールはALUのように1クロックの間に入力から出力を生成しないため、 計算中はEXステージをストールさせる必要があります。 そのために<code>exs_muldiv_stall</code>変数を定義して、ストールの条件に追加します(リスト7、リスト8)。 また、M拡張の命令の場合はMEMステージに渡す<code>alu_result</code>の値をmuldivunitモジュールの結果に設定します(リスト8)。</p><p><span class="caption">▼リスト9.7: EXステージのストール条件の変更 (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">var</span> exs_muldiv_rvalided: <span class="hljs-keyword">logic</span>;
<span class="hljs-keyword">let</span> exs_muldiv_stall   : <span class="hljs-keyword">logic</span> = exs_ctrl.is_muldiv &amp;&amp; !exs_muldiv_rvalid &amp;&amp; !exs_muldiv_rvalided;

<span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        exs_muldiv_rvalided = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 次のステージに遷移</span>
        <span class="hljs-keyword">if</span> exq_rvalid &amp;&amp; exq_rready {
            exs_muldiv_rvalided = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// muldivunitの処理が完了していたら1にする</span>
            exs_muldiv_rvalided |= exs_muldiv_rvalid;
        }
    }
}
</code></pre></div><p><span class="caption">▼リスト9.8: EXステージのストール条件の変更とM拡張の命令の結果の設定 (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="custom-hl-bold"><span class="hljs-keyword">let</span> exs_stall: <span class="hljs-keyword">logic</span> = exs_data_hazard || exs_muldiv_stall;</span>

<span class="hljs-keyword">always_comb</span> {
    <span class="hljs-comment">// EX -&gt; MEM</span>
    exq_rready            = memq_wready &amp;&amp; <span class="custom-hl-bold">!exs_stall</span>;
    memq_wvalid           = exq_rvalid &amp;&amp; <span class="custom-hl-bold">!exs_stall</span>;
    memq_wdata.addr       = exq_rdata.addr;
    memq_wdata.bits       = exq_rdata.bits;
    memq_wdata.ctrl       = exq_rdata.ctrl;
    memq_wdata.imm        = exq_rdata.imm;
    memq_wdata.rs1_addr   = exs_rs1_addr;
    memq_wdata.rs1_data   = exs_rs1_data;
    memq_wdata.rs2_data   = exs_rs2_data;
    memq_wdata.alu_result = <span class="custom-hl-bold"><span class="hljs-keyword">if</span> exs_ctrl.is_muldiv ? exs_muldiv_result : exs_alu_result</span>;
    memq_wdata.br_taken   = exs_ctrl.is_jump || inst_is_br(exs_ctrl) &amp;&amp; exs_brunit_take;
    memq_wdata.jump_addr  = <span class="hljs-keyword">if</span> inst_is_br(exs_ctrl) ? exs_pc + exs_imm : exs_alu_result &amp; ~<span class="hljs-number">1</span>;
}
</code></pre></div><p>muldivunitモジュールは計算が完了したクロックでしか<code>rvalid</code>を<code>1</code>にしないため、 既に計算が完了したことを示す<code>exs_muldiv_rvalided</code>変数で完了状態を管理します。 これにより、M拡張の命令によってストールする条件は、 命令がM拡張の命令であり(<code>exs_ctrl.is_muldiv</code>)、 現在のクロックで計算が完了しておらず(<code>!exs_muldiv_rvalid</code>)、 以前のクロックでも計算が完了していない(<code>!exs_muldiv_rvalided</code>) 場合になります。</p><h2 id="符号無しの乗算器の実装" tabindex="-1">符号無しの乗算器の実装 <a class="header-anchor" href="#符号無しの乗算器の実装" aria-label="Permalink to “符号無しの乗算器の実装”">​</a></h2><h3 id="mulunitモジュールを実装する" tabindex="-1">mulunitモジュールを実装する <a class="header-anchor" href="#mulunitモジュールを実装する" aria-label="Permalink to “mulunitモジュールを実装する”">​</a></h3><p><code>WIDTH</code>ビットの符号無しの値同士の積を計算する乗算器を実装します。</p><p><code>src/muldivunit.veryl</code>の中にmulunitモジュールを作成します(リスト9)。</p><p><span class="caption">▼リスト9.9: muldivunit.veryl</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> mulunit #(
    <span class="hljs-keyword">param</span> WIDTH: <span class="hljs-keyword">u32</span> = <span class="hljs-number">0</span>,
) (
    clk   : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">clock</span>           ,
    rst   : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">reset</span>           ,
    valid : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>           ,
    op1   : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;    ,
    op2   : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;    ,
    rvalid: <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>           ,
    result: <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>&lt;WIDTH * <span class="hljs-number">2</span>&gt;,
) {
    <span class="hljs-keyword">enum</span> State {
        Idle,
        AddLoop,
        Finish,
    }

    <span class="hljs-keyword">var</span> state: State;

    <span class="hljs-keyword">var</span> op1zext: <span class="hljs-keyword">logic</span>&lt;WIDTH * <span class="hljs-number">2</span>&gt;;
    <span class="hljs-keyword">var</span> op2zext: <span class="hljs-keyword">logic</span>&lt;WIDTH * <span class="hljs-number">2</span>&gt;;

    <span class="hljs-keyword">always_comb</span> {
        rvalid = state == State::Finish;
    }

    <span class="hljs-keyword">var</span> add_count: <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">32</span>&gt;;

    <span class="hljs-keyword">always_ff</span> {
        <span class="hljs-keyword">if_reset</span> {
            state     = State::Idle;
            result    = <span class="hljs-number">0</span>;
            add_count = <span class="hljs-number">0</span>;
            op1zext   = <span class="hljs-number">0</span>;
            op2zext   = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">case</span> state {
                State::Idle: <span class="hljs-keyword">if</span> valid {
                    state     = State::AddLoop;
                    result    = <span class="hljs-number">0</span>;
                    add_count = <span class="hljs-number">0</span>;
                    op1zext   = {<span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> WIDTH, op1};
                    op2zext   = {<span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> WIDTH, op2};
                }
                State::AddLoop: <span class="hljs-keyword">if</span> add_count == WIDTH {
                    state = State::Finish;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> op2zext[add_count] {
                        result += op1zext;
                    }
                    op1zext   &lt;&lt;= <span class="hljs-number">1</span>;
                    add_count +=  <span class="hljs-number">1</span>;
                }
                State::Finish: state = State::Idle;
                <span class="hljs-keyword">default</span>      : {}
            }
        }
    }
}
</code></pre></div><p>mulunitモジュールは<code>op1 * op2</code>を計算するモジュールです。 <code>valid</code>が<code>1</code>になったら計算を開始し、 計算が完了したら<code>rvalid</code>を<code>1</code>、<code>result</code>を<code>WIDTH * 2</code>ビットの計算結果に設定します。</p><p>積は<code>WIDTH</code>回の足し算を<code>WIDTH</code>クロックかけて行って求めています(図1)。 計算を開始すると入力をゼロで<code>WIDTH * 2</code>ビットに拡張し、 <code>result</code>を<code>0</code>でリセットします。</p><p><code>State::AddLoop</code>では、次の操作を<code>WIDTH</code>回行います。 <code>i</code>回目では次の操作を行います。</p><ol><li><code>op2[i-1]</code>が<code>1</code>なら<code>result</code>に<code>op1</code>を足す</li><li><code>op1</code>を1ビット左シフトする</li><li>カウンタをインクリメントする</li></ol><p><img src="/assets/mul_process.BkOlnOCC.png" alt="符号無し4ビットの乗算"></p><h3 id="mulunitモジュールをインスタンス化する" tabindex="-1">mulunitモジュールをインスタンス化する <a class="header-anchor" href="#mulunitモジュールをインスタンス化する" aria-label="Permalink to “mulunitモジュールをインスタンス化する”">​</a></h3><p>mulunitモジュールをmuldivunitモジュールでインスタンス化します (リスト10)。 まだ結果は利用しません。</p><p><span class="caption">▼リスト9.10: mulunitモジュールをインスタンス化する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// multiply unit</span>
<span class="hljs-keyword">const</span> MUL_OP_WIDTH : <span class="hljs-keyword">u32</span> = XLEN;
<span class="hljs-keyword">const</span> MUL_RES_WIDTH: <span class="hljs-keyword">u32</span> = MUL_OP_WIDTH * <span class="hljs-number">2</span>;

<span class="hljs-keyword">let</span> is_mul   : <span class="hljs-keyword">logic</span>                = <span class="hljs-keyword">if</span> state == State::Idle ? !funct3[<span class="hljs-number">2</span>] : !funct3_saved[<span class="hljs-number">2</span>];
<span class="hljs-keyword">var</span> mu_rvalid: <span class="hljs-keyword">logic</span>               ;
<span class="hljs-keyword">var</span> mu_result: <span class="hljs-keyword">logic</span>&lt;MUL_RES_WIDTH&gt;;

<span class="hljs-keyword">inst</span> mu: mulunit #(
    WIDTH: MUL_OP_WIDTH,
) (
    clk                             ,
    rst                             ,
    valid : ready &amp;&amp; valid &amp;&amp; is_mul,
    op1   : op1                     ,
    op2   : op2                     ,
    rvalid: mu_rvalid               ,
    result: mu_result               ,
);
</code></pre></div><h2 id="mulhu命令の実装" tabindex="-1">MULHU命令の実装 <a class="header-anchor" href="#mulhu命令の実装" aria-label="Permalink to “MULHU命令の実装”">​</a></h2><p>MULHU命令は、2つの符号無しのXLENビットの値の乗算を実行し、 デスティネーションレジスタに結果(XLEN * 2ビット)の上位XLENビットを書き込む命令です。 funct3の下位2ビットによってmulunitモジュールの結果を選択するようにします (リスト11)。</p><p><span class="caption">▼リスト9.11: MULHUモジュールの結果を取得する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::WaitValid: <span class="hljs-keyword">if</span> is_mul &amp;&amp; mu_rvalid {
    state  = State::Finish;
    <span class="custom-hl-bold">result = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {</span>
    <span class="custom-hl-bold">    <span class="hljs-number">2&#39;b11</span>  : mu_result[XLEN+:XLEN], <span class="hljs-comment">// MULHU</span></span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span>,</span>
    <span class="custom-hl-bold">};</span>
}
</code></pre></div><p>riscv-testsの<code>rv64um-p-mulhu</code>を実行し、成功することを確認してください。</p><h2 id="mul、mulh命令の実装" tabindex="-1">MUL、MULH命令の実装 <a class="header-anchor" href="#mul、mulh命令の実装" aria-label="Permalink to “MUL、MULH命令の実装”">​</a></h2><h3 id="符号付き乗算を符号無し乗算器で実現する" tabindex="-1">符号付き乗算を符号無し乗算器で実現する <a class="header-anchor" href="#符号付き乗算を符号無し乗算器で実現する" aria-label="Permalink to “符号付き乗算を符号無し乗算器で実現する”">​</a></h3><p>MUL、MULH命令は、2つの符号付きのXLENビットの値の乗算を実行し、 デスティネーションレジスタにそれぞれ結果の下位XLENビット、上位XLENビットを書き込む命令です。</p><p>本章ではmulunitモジュールを使って、次のように符号付き乗算を実現します。</p><ol><li>符号付きのXLENビットの値を符号無しの値(絶対値)に変換する</li><li>符号無しで積を計算する</li><li>計算結果の符号を修正する</li></ol><p>絶対値で計算することで符号ビットを考慮する必要がなくなり、 既に実装してある符号無しの乗算器を変更せずに符号付きの乗算を実現できます。</p><h3 id="符号付き乗算を実装する" tabindex="-1">符号付き乗算を実装する <a class="header-anchor" href="#符号付き乗算を実装する" aria-label="Permalink to “符号付き乗算を実装する”">​</a></h3><p><code>WIDTH</code>ビットの符号付きの値を<code>WIDTH</code>ビットの符号無しの絶対値に変換するabs関数を作成します (リスト12)。 abs関数は、値のMSBが<code>1</code>ならビットを反転して<code>1</code>を足すことで符号を反転しています。 最小値<code>-2 ** (WIDTH - 1)</code>の絶対値も求められることを確認してください。</p><p><span class="caption">▼リスト9.12: abs関数を実装する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> abs::&lt;WIDTH: <span class="hljs-keyword">u32</span>&gt; (
    value: <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;,
) -&gt; <span class="hljs-keyword">logic</span>&lt;WIDTH&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> value[<span class="hljs-keyword">msb</span>] ? ~value + <span class="hljs-number">1</span> : value;
}
</code></pre></div><p>abs関数を利用して、MUL、MULH命令のときにmulunitに渡す値を絶対値に設定します (リスト13、リスト14)。</p><p><span class="caption">▼リスト9.13: op1とop2を生成する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> mu_op1: <span class="hljs-keyword">logic</span>&lt;MUL_OP_WIDTH&gt; = <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b01</span>: abs::&lt;XLEN&gt;(op1), <span class="hljs-comment">// MUL, MULH</span>
    <span class="hljs-number">2&#39;b11</span>       : op1, <span class="hljs-comment">// MULHU</span>
    <span class="hljs-keyword">default</span>     : <span class="hljs-number">0</span>,
};
<span class="hljs-keyword">let</span> mu_op2: <span class="hljs-keyword">logic</span>&lt;MUL_OP_WIDTH&gt; = <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b01</span>: abs::&lt;XLEN&gt;(op2), <span class="hljs-comment">// MUL, MULH</span>
    <span class="hljs-number">2&#39;b11</span>       : op2, <span class="hljs-comment">// MULHU</span>
    <span class="hljs-keyword">default</span>     : <span class="hljs-number">0</span>,
};
</code></pre></div><p><span class="caption">▼リスト9.14: mulunitに渡す値を変更する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> mu: mulunit #(
    WIDTH: MUL_OP_WIDTH,
) (
    clk                             ,
    rst                             ,
    valid : ready &amp;&amp; valid &amp;&amp; is_mul,
    op1   : <span class="custom-hl-bold">mu_op1</span>                  ,
    op2   : <span class="custom-hl-bold">mu_op2</span>                  ,
    rvalid: mu_rvalid               ,
    result: mu_result               ,
);
</code></pre></div><p>計算結果の符号は<code>op1</code>と<code>op2</code>の符号が異なる場合に負になります。 後で符号の情報を利用するために、muldivunitモジュールが要求を受け入れる時に符号を保存します ( リスト15、 リスト16、 リスト17 )。</p><p><span class="caption">▼リスト9.15: 符号を保存する変数を作成する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// saved_data</span>
<span class="hljs-keyword">var</span> funct3_saved : <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;;
<span class="custom-hl-bold"><span class="hljs-keyword">var</span> op1sign_saved: <span class="hljs-keyword">logic</span>   ;</span>
<span class="custom-hl-bold"><span class="hljs-keyword">var</span> op2sign_saved: <span class="hljs-keyword">logic</span>   ;</span>
</code></pre></div><p><span class="caption">▼リスト9.16: 変数のリセット (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        state         = State::Idle;
        result        = <span class="hljs-number">0</span>;
        funct3_saved  = <span class="hljs-number">0</span>;
        <span class="custom-hl-bold">op1sign_saved = <span class="hljs-number">0</span>;</span>
        <span class="custom-hl-bold">op2sign_saved = <span class="hljs-number">0</span>;</span>
    } <span class="hljs-keyword">else</span> {
</code></pre></div><p><span class="caption">▼リスト9.17: 符号を変数に保存する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">case</span> state {
    State::Idle: <span class="hljs-keyword">if</span> ready &amp;&amp; valid {
        state         = State::WaitValid;
        funct3_saved  = funct3;
        <span class="custom-hl-bold">op1sign_saved = op1[<span class="hljs-keyword">msb</span>];</span>
        <span class="custom-hl-bold">op2sign_saved = op2[<span class="hljs-keyword">msb</span>];</span>
    }
</code></pre></div><p>保存した符号を利用して計算結果の符号を復元します (リスト18)。</p><p><span class="caption">▼リスト9.18: 計算結果の符号を復元する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::WaitValid: <span class="hljs-keyword">if</span> is_mul &amp;&amp; mu_rvalid {
    <span class="custom-hl-bold"><span class="hljs-keyword">let</span> res_signed: <span class="hljs-keyword">logic</span>&lt;MUL_RES_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved != op2sign_saved ? ~mu_result + <span class="hljs-number">1</span> : mu_result;</span>
    state      = State::Finish;
    result     = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="custom-hl-bold"><span class="hljs-number">2&#39;b00</span>  : res_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// MUL</span></span>
        <span class="custom-hl-bold"><span class="hljs-number">2&#39;b01</span>  : res_signed[XLEN+:XLEN], <span class="hljs-comment">// MULH</span></span>
        <span class="hljs-number">2&#39;b11</span>  : mu_result[XLEN+:XLEN], <span class="hljs-comment">// MULHU</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span>,
    };
}
</code></pre></div><p>riscv-testsの<code>rv64um-p-mul</code>と<code>rv64um-p-mulh</code>を実行し、成功することを確認してください。</p><h3 id="mulhsu命令の実装" tabindex="-1">MULHSU命令の実装 <a class="header-anchor" href="#mulhsu命令の実装" aria-label="Permalink to “MULHSU命令の実装”">​</a></h3><p>MULHSU命令は、符号付きのXLENビットのrs1と符号無しのXLENビットのrs2の乗算を実行し、 デスティネーションレジスタに結果の上位XLENビットを書き込む命令です。 計算結果は符号付きの値になります。</p><p>MULHSU命令も、MUL、MULH命令と同様に符号無しの乗算器で実現します。</p><p><code>op1</code>を絶対値に変換し、<code>op2</code>はそのままに設定します (リスト19)。</p><p><span class="caption">▼リスト9.19: MULHSU命令用にop1、op2を設定する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> mu_op1: <span class="hljs-keyword">logic</span>&lt;MUL_OP_WIDTH&gt; = <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b01</span><span class="custom-hl-bold">, <span class="hljs-number">2&#39;b10</span></span>: abs::&lt;XLEN&gt;(op1), <span class="hljs-comment">// MUL, MULH<span class="custom-hl-bold">, MULHSU</span></span>
    <span class="hljs-number">2&#39;b11</span>              : op1, <span class="hljs-comment">// MULHU</span>
    <span class="hljs-keyword">default</span>            : <span class="hljs-number">0</span>,
};
<span class="hljs-keyword">let</span> mu_op2: <span class="hljs-keyword">logic</span>&lt;MUL_OP_WIDTH&gt; = <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b01</span>: abs::&lt;XLEN&gt;(op2), <span class="hljs-comment">// MUL, MULH</span>
    <span class="hljs-number">2&#39;b11</span><span class="custom-hl-bold">, <span class="hljs-number">2&#39;b10</span></span>: op2, <span class="hljs-comment">// MULHU<span class="custom-hl-bold">, MULHSU</span></span>
    <span class="hljs-keyword">default</span>     : <span class="hljs-number">0</span>,
};
</code></pre></div><p>計算結果は<code>op1</code>の符号にします (リスト20)。</p><p><span class="caption">▼リスト9.20: 計算結果の符号を復元する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::WaitValid: <span class="hljs-keyword">if</span> is_mul &amp;&amp; mu_rvalid {
    <span class="hljs-keyword">let</span> res_signed: <span class="hljs-keyword">logic</span>&lt;MUL_RES_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved != op2sign_saved ? ~mu_result + <span class="hljs-number">1</span> : mu_result;
    <span class="custom-hl-bold"><span class="hljs-keyword">let</span> res_mulhsu: <span class="hljs-keyword">logic</span>&lt;MUL_RES_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved == <span class="hljs-number">1</span> ? ~mu_result + <span class="hljs-number">1</span> : mu_result;</span>
    state      = State::Finish;
    result     = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="hljs-number">2&#39;b00</span>  : res_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// MUL</span>
        <span class="hljs-number">2&#39;b01</span>  : res_signed[XLEN+:XLEN], <span class="hljs-comment">// MULH</span>
        <span class="custom-hl-bold"><span class="hljs-number">2&#39;b10</span>  : res_mulhsu[XLEN+:XLEN], <span class="hljs-comment">// MULHSU</span></span>
        <span class="hljs-number">2&#39;b11</span>  : mu_result[XLEN+:XLEN], <span class="hljs-comment">// MULHU</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span>,
    };
}
</code></pre></div><p>riscv-testsの<code>rv64um-p-mulhsu</code>を実行し、成功することを確認してください。</p><h3 id="mulw命令の実装" tabindex="-1">MULW命令の実装 <a class="header-anchor" href="#mulw命令の実装" aria-label="Permalink to “MULW命令の実装”">​</a></h3><p>MULW命令は、2つの符号付きの32ビットの値の乗算を実行し、 デスティネーションレジスタに結果の下位32ビットを符号拡張した値を書き込む命令です。</p><p>32ビット演算の命令であることを判定するために、 muldivunitモジュールに<code>is_op32</code>ポートを作成します ( リスト21、 リスト22 )。</p><p><span class="caption">▼リスト9.21: is_op32ポートを追加する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> muldivunit (
    clk    : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">clock</span>   ,
    rst    : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">reset</span>   ,
    ready  : <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>   ,
    valid  : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>   ,
    funct3 : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;,
    <span class="custom-hl-bold">is_op32: <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>   ,</span>
    op1    : <span class="hljs-keyword">input</span>  UIntX   ,
    op2    : <span class="hljs-keyword">input</span>  UIntX   ,
    rvalid : <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>   ,
    result : <span class="hljs-keyword">output</span> UIntX   ,
) {
</code></pre></div><p><span class="caption">▼リスト9.22: is_op32ポートに値を割り当てる (core.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> mdu: muldivunit (
    clk                       ,
    rst                       ,
    valid  : exs_muldiv_valid ,
    ready  : exs_muldiv_ready ,
    funct3 : exs_ctrl.funct3  ,
    <span class="custom-hl-bold">is_op32: exs_ctrl.is_op32 ,</span>
    op1    : exs_op1          ,
    op2    : exs_op2          ,
    rvalid : exs_muldiv_rvalid,
    result : exs_muldiv_result,
);
</code></pre></div><p>muldivunitモジュールが要求を受け入れる時に<code>is_op32</code>を保存します ( リスト23、 リスト24、 リスト25 )。</p><p><span class="caption">▼リスト9.23: is_op32を保存する変数を作成する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// saved_data</span>
<span class="hljs-keyword">var</span> funct3_saved : <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;;
<span class="custom-hl-bold"><span class="hljs-keyword">var</span> is_op32_saved: <span class="hljs-keyword">logic</span>   ;</span>
<span class="hljs-keyword">var</span> op1sign_saved: <span class="hljs-keyword">logic</span>   ;
<span class="hljs-keyword">var</span> op2sign_saved: <span class="hljs-keyword">logic</span>   ;
</code></pre></div><p><span class="caption">▼リスト9.24: 変数のリセット (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_ff</span> {
    <span class="hljs-keyword">if_reset</span> {
        state         = State::Idle;
        result        = <span class="hljs-number">0</span>;
        funct3_saved  = <span class="hljs-number">0</span>;
        <span class="custom-hl-bold">is_op32_saved = <span class="hljs-number">0</span>;</span>
        op1sign_saved = <span class="hljs-number">0</span>;
        op2sign_saved = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
</code></pre></div><p><span class="caption">▼リスト9.25: is_op32を変数に保存する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::Idle: <span class="hljs-keyword">if</span> ready &amp;&amp; valid {
    state         = State::WaitValid;
    funct3_saved  = funct3;
    <span class="custom-hl-bold">is_op32_saved = is_op32;</span>
    op1sign_saved = op1[<span class="hljs-keyword">msb</span>];
    op2sign_saved = op2[<span class="hljs-keyword">msb</span>];
}
</code></pre></div><p>mulunitモジュールの<code>op1</code>と<code>op2</code>に、64ビットの値の下位32ビットを符号拡張した値を割り当てます。 符号拡張を行うsext関数を作成し、<code>mu_op1</code>、<code>mu_op2</code>の割り当てに利用します ( リスト26、 リスト27 )。</p><p><span class="caption">▼リスト9.26: 符号拡張する関数を作成する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> sext::&lt;WIDTH_IN: <span class="hljs-keyword">u32</span>, WIDTH_OUT: <span class="hljs-keyword">u32</span>&gt; (
    value: <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;WIDTH_IN&gt;,
) -&gt; <span class="hljs-keyword">logic</span>&lt;WIDTH_OUT&gt; {
    <span class="hljs-keyword">return</span> {value[<span class="hljs-keyword">msb</span>] <span class="hljs-keyword">repeat</span> WIDTH_OUT - WIDTH_IN, value};
}
</code></pre></div><p><span class="caption">▼リスト9.27: MULW命令用にop1、op2を設定する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">let</span> mu_op1: <span class="hljs-keyword">logic</span>&lt;MUL_OP_WIDTH&gt; = <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b01</span>, <span class="hljs-number">2&#39;b10</span>: abs::&lt;XLEN&gt;(<span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_op32 ? sext::&lt;<span class="hljs-number">32</span>, XLEN&gt;(op1[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]) : </span>op1), <span class="hljs-comment">// MUL, MULH, MULHSU<span class="custom-hl-bold">, MULW</span></span>
    <span class="hljs-number">2&#39;b11</span>              : op1, <span class="hljs-comment">// MULHU</span>
    <span class="hljs-keyword">default</span>            : <span class="hljs-number">0</span>,
};
<span class="hljs-keyword">let</span> mu_op2: <span class="hljs-keyword">logic</span>&lt;MUL_OP_WIDTH&gt; = <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b01</span>: abs::&lt;XLEN&gt;(<span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_op32 ? sext::&lt;<span class="hljs-number">32</span>, XLEN&gt;(op2[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]) : </span>op2), <span class="hljs-comment">// MUL, MULH<span class="custom-hl-bold">, MULW</span></span>
    <span class="hljs-number">2&#39;b11</span>, <span class="hljs-number">2&#39;b10</span>: op2, <span class="hljs-comment">// MULHU, MULHSU</span>
    <span class="hljs-keyword">default</span>     : <span class="hljs-number">0</span>,
};
</code></pre></div><p>最後に、計算結果を符号拡張した値に設定します (リスト28)。</p><p><span class="caption">▼リスト9.28: 計算結果を符号拡張する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::WaitValid: <span class="hljs-keyword">if</span> is_mul &amp;&amp; mu_rvalid {
    <span class="hljs-keyword">let</span> res_signed: <span class="hljs-keyword">logic</span>&lt;MUL_RES_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved != op2sign_saved ? ~mu_result + <span class="hljs-number">1</span> : mu_result;
    <span class="hljs-keyword">let</span> res_mulhsu: <span class="hljs-keyword">logic</span>&lt;MUL_RES_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved == <span class="hljs-number">1</span> ? ~mu_result + <span class="hljs-number">1</span> : mu_result;
    state      = State::Finish;
    result     = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="hljs-number">2&#39;b00</span>  : <span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_op32_saved ? sext::&lt;<span class="hljs-number">32</span>, <span class="hljs-number">64</span>&gt;(res_signed[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]) :</span> res_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// MUL<span class="custom-hl-bold">, MULW</span></span>
        <span class="hljs-number">2&#39;b01</span>  : res_signed[XLEN+:XLEN], <span class="hljs-comment">// MULH</span>
</code></pre></div><p>riscv-testsの<code>rv64um-p-mulw</code>を実行し、成功することを確認してください。</p><h2 id="符号無し除算の実装" tabindex="-1">符号無し除算の実装 <a class="header-anchor" href="#符号無し除算の実装" aria-label="Permalink to “符号無し除算の実装”">​</a></h2><h3 id="divunitモジュールを実装する" tabindex="-1">divunitモジュールを実装する <a class="header-anchor" href="#divunitモジュールを実装する" aria-label="Permalink to “divunitモジュールを実装する”">​</a></h3><p><code>WIDTH</code>ビットの除算を計算する除算器を実装します。</p><p><code>src/muldivunit.veryl</code>の中にdivunitモジュールを作成します (リスト29)。</p><p><span class="caption">▼リスト9.29: muldivunit.veryl</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">module</span> divunit #(
    <span class="hljs-keyword">param</span> WIDTH: <span class="hljs-keyword">u32</span> = <span class="hljs-number">0</span>,
) (
    clk      : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">clock</span>       ,
    rst      : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">reset</span>       ,
    valid    : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       ,
    dividend : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;,
    divisor  : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;,
    rvalid   : <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>       ,
    quotient : <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;,
    remainder: <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>&lt;WIDTH&gt;,
) {
    <span class="hljs-keyword">enum</span> State {
        Idle,
        ZeroCheck,
        SubLoop,
        Finish,
    }

    <span class="hljs-keyword">var</span> state: State;

    <span class="hljs-keyword">var</span> dividend_saved: <span class="hljs-keyword">logic</span>&lt;WIDTH * <span class="hljs-number">2</span>&gt;;
    <span class="hljs-keyword">var</span> divisor_saved : <span class="hljs-keyword">logic</span>&lt;WIDTH * <span class="hljs-number">2</span>&gt;;

    <span class="hljs-keyword">always_comb</span> {
        rvalid    = state == State::Finish;
        remainder = dividend_saved[WIDTH - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">var</span> sub_count: <span class="hljs-keyword">u32</span>;

    <span class="hljs-keyword">always_ff</span> {
        <span class="hljs-keyword">if_reset</span> {
            state          = State::Idle;
            quotient       = <span class="hljs-number">0</span>;
            sub_count      = <span class="hljs-number">0</span>;
            dividend_saved = <span class="hljs-number">0</span>;
            divisor_saved  = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">case</span> state {
                State::Idle: <span class="hljs-keyword">if</span> valid {
                    state          = State::ZeroCheck;
                    dividend_saved = {<span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> WIDTH, dividend};
                    divisor_saved  = {<span class="hljs-number">1&#39;b0</span>, divisor, <span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> WIDTH - <span class="hljs-number">1</span>};
                    quotient       = <span class="hljs-number">0</span>;
                    sub_count      = <span class="hljs-number">0</span>;
                }
                State::ZeroCheck: <span class="hljs-keyword">if</span> divisor_saved == <span class="hljs-number">0</span> {
                    state    = State::Finish;
                    quotient = &#39;<span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> {
                    state = State::SubLoop;
                }
                State::SubLoop: <span class="hljs-keyword">if</span> sub_count == WIDTH {
                    state = State::Finish;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> dividend_saved &gt;= divisor_saved {
                        dividend_saved -= divisor_saved;
                        quotient       =  (quotient &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
                    } <span class="hljs-keyword">else</span> {
                        quotient &lt;&lt;= <span class="hljs-number">1</span>;
                    }
                    divisor_saved &gt;&gt;= <span class="hljs-number">1</span>;
                    sub_count     +=  <span class="hljs-number">1</span>;
                }
                State::Finish: state = State::Idle;
                <span class="hljs-keyword">default</span>      : {}
            }
        }
    }
}
</code></pre></div><p>divunitモジュールは被除数(<code>dividend</code>)と除数(<code>divisor</code>)の 商(<code>quotient</code>)と剰余(<code>remainder</code>)を計算するモジュールです。 <code>valid</code>が<code>1</code>になったら計算を開始し、 計算が完了したら<code>rvalid</code>を<code>1</code>に設定します。</p><p>商と剰余は<code>WIDTH</code>回の引き算を<code>WIDTH</code>クロックかけて行って求めています。 計算を開始すると被除数を<code>0</code>で<code>WIDTH * 2</code>ビットに拡張し、 除数を<code>WIDTH-1</code>ビット左シフトします。 また、商を<code>0</code>でリセットします。</p><p><code>State::SubLoop</code>では、次の操作を<code>WIDTH</code>回行います。</p><ol><li>被除数が除数よりも大きいなら、被除数から除数を引き、商のLSBを1にする</li><li>商を1ビット左シフトする</li><li>除数を1ビット右シフトする</li><li>カウンタをインクリメントする</li></ol><p>RISC-Vでは、除数が<code>0</code>だったり結果がオーバーフローするようなLビットの除算の結果は表4のようになると定められています。 このうちdivunitモジュールは符号無しの除算(DIVU、REMU命令)のゼロ除算だけを対処しています。</p><div id="riscv.div.expt" class="table"><p class="caption">表9.4: 除算の例外的な動作と結果</p><table><tr class="hline"><th>操作</th><th>ゼロ除算</th><th>オーバーフロー</th></tr><tr class="hline"><td>符号付き除算</td><td>-1</td><td>-2**(L-1)</td></tr><tr class="hline"><td>符号付き剰余</td><td>被除数</td><td>0</td></tr><tr class="hline"><td>符号無し除算</td><td>2**L-1</td><td>発生しない</td></tr><tr class="hline"><td>符号無し剰余</td><td>被除数</td><td>発生しない</td></tr></table></div><h3 id="divunitモジュールをインスタンス化する" tabindex="-1">divunitモジュールをインスタンス化する <a class="header-anchor" href="#divunitモジュールをインスタンス化する" aria-label="Permalink to “divunitモジュールをインスタンス化する”">​</a></h3><p>divunitモジュールをmuldivunitモジュールでインスタンス化します (リスト30)。 まだ結果は利用しません。</p><p><span class="caption">▼リスト9.30: divunitモジュールをインスタンス化する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-comment">// divider unit</span>
<span class="hljs-keyword">const</span> DIV_WIDTH: <span class="hljs-keyword">u32</span> = XLEN;

<span class="hljs-keyword">var</span> du_rvalid   : <span class="hljs-keyword">logic</span>           ;
<span class="hljs-keyword">var</span> du_quotient : <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt;;
<span class="hljs-keyword">var</span> du_remainder: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt;;

<span class="hljs-keyword">inst</span> du: divunit #(
    WIDTH: DIV_WIDTH,
) (
    clk                                 ,
    rst                                 ,
    valid    : ready &amp;&amp; valid &amp;&amp; !is_mul,
    dividend : op1                      ,
    divisor  : op2                      ,
    rvalid   : du_rvalid                ,
    quotient : du_quotient              ,
    remainder: du_remainder             ,
);
</code></pre></div><h2 id="divu、remu命令の実装" tabindex="-1">DIVU、REMU命令の実装 <a class="header-anchor" href="#divu、remu命令の実装" aria-label="Permalink to “DIVU、REMU命令の実装”">​</a></h2><p>DIVU、REMU命令は、符号無しのXLENビットのrs1(被除数)と符号無しのXLENビットのrs2(除数)の商、剰余を計算し、 デスティネーションレジスタにそれぞれ結果を書き込む命令です。</p><p>muldivunitモジュールで、divunitモジュールの処理が終わったら結果を<code>result</code>レジスタに割り当てるようにします (リスト31)。</p><p><span class="caption">▼リスト9.31: divunitモジュールの結果をresultに割り当てる (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::WaitValid: <span class="hljs-keyword">if</span> is_mul &amp;&amp; mu_rvalid {
    ...
<span class="custom-hl-bold">} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !is_mul &amp;&amp; du_rvalid {</span>
    <span class="custom-hl-bold">result = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {</span>
    <span class="custom-hl-bold">    <span class="hljs-number">2&#39;b01</span>  : du_quotient, <span class="hljs-comment">// DIVU</span></span>
    <span class="custom-hl-bold">    <span class="hljs-number">2&#39;b11</span>  : du_remainder, <span class="hljs-comment">// REMU</span></span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span>,</span>
    <span class="custom-hl-bold">};</span>
    <span class="custom-hl-bold">state = State::Finish;</span>
}
</code></pre></div><p>riscv-testsの<code>rv64um-p-divu</code>、<code>rv64um-p-remu</code>を実行し、成功することを確認してください。</p><h2 id="div、rem命令の実装" tabindex="-1">DIV、REM命令の実装 <a class="header-anchor" href="#div、rem命令の実装" aria-label="Permalink to “DIV、REM命令の実装”">​</a></h2><h3 id="符号付き除算を符号無し除算器で実現する" tabindex="-1">符号付き除算を符号無し除算器で実現する <a class="header-anchor" href="#符号付き除算を符号無し除算器で実現する" aria-label="Permalink to “符号付き除算を符号無し除算器で実現する”">​</a></h3><p>DIV、REM命令は、それぞれDIVU、REMU命令の動作を符号付きに変えた命令です。 本章では、符号付き乗算と同じように値を絶対値に変換して計算することで符号付き除算を実現します。</p><p>RISC-Vの符号付き除算の結果は0の方向に丸められた整数になり、剰余演算の結果は被除数と同じ符号になります。 符号付き剰余の絶対値は符号無し剰余の結果と一致するため、 絶対値で計算してから符号を戻すことで、符号無し除算器だけで符号付きの剰余演算を実現できます。</p><h3 id="符号付き除算を実装する" tabindex="-1">符号付き除算を実装する <a class="header-anchor" href="#符号付き除算を実装する" aria-label="Permalink to “符号付き除算を実装する”">​</a></h3><p>abs関数を利用して、DIV、REM命令のときにdivunitモジュールに渡す値を絶対値に設定します ( リスト32 リスト33 )。</p><p><span class="caption">▼リスト9.32: 除数と被除数を生成する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> generate_div_op (
    funct3: <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;   ,
    value : <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;XLEN&gt;,
) -&gt; <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b10</span>: abs::&lt;DIV_WIDTH&gt;(value), <span class="hljs-comment">// DIV, REM</span>
        <span class="hljs-number">2&#39;b01</span>, <span class="hljs-number">2&#39;b11</span>: value, <span class="hljs-comment">// DIVU, REMU</span>
        <span class="hljs-keyword">default</span>     : <span class="hljs-number">0</span>,
    };
}

<span class="hljs-keyword">let</span> du_dividend: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = generate_div_op(funct3, op1);
<span class="hljs-keyword">let</span> du_divisor : <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = generate_div_op(funct3, op2);
</code></pre></div><p><span class="caption">▼リスト9.33: divunitに渡す値を変更する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">inst</span> du: divunit #(
    WIDTH: DIV_WIDTH,
) (
    clk                                                     ,
    rst                                                     ,
    valid    : ready &amp;&amp; valid &amp;&amp; !is_mul <span class="custom-hl-bold">&amp;&amp; !du_signed_error</span>,
    dividend : <span class="custom-hl-bold">du_dividend</span>                                  ,
    divisor  : <span class="custom-hl-bold">du_divisor</span>                                   ,
    rvalid   : du_rvalid                                    ,
    quotient : du_quotient                                  ,
    remainder: du_remainder                                 ,
);
</code></pre></div><p>表4にあるように、符号付き演算は結果がオーバーフローする場合とゼロで割る場合の結果が定められています。 その場合には、divunitモジュールで除算を実行せず、muldivunitで計算結果を直接生成するようにします ( リスト34 リスト35 )。 符号付き演算かどうかを<code>funct3</code>のLSBで確認し、例外的な処理ではない場合にのみdivunitモジュールで計算を開始するようにします。</p><p><span class="caption">▼リスト9.34: 符号付き除算がオーバーフローするか、ゼロ除算かどうかを判定する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">var</span> du_signed_overflow: <span class="hljs-keyword">logic</span>;
<span class="hljs-keyword">var</span> du_signed_divzero : <span class="hljs-keyword">logic</span>;
<span class="hljs-keyword">var</span> du_signed_error   : <span class="hljs-keyword">logic</span>;

<span class="hljs-keyword">always_comb</span> {
    du_signed_overflow = !funct3[<span class="hljs-number">0</span>] &amp;&amp; op1[<span class="hljs-keyword">msb</span>] == <span class="hljs-number">1</span> &amp;&amp; op1[<span class="hljs-keyword">msb</span> - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; &amp;op2;
    du_signed_divzero  = !funct3[<span class="hljs-number">0</span>] &amp;&amp; op2 == <span class="hljs-number">0</span>;
    du_signed_error    = du_signed_overflow || du_signed_divzero;
}
</code></pre></div><p><span class="caption">▼リスト9.35: 符号付き除算の例外的な結果を処理する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>State::Idle: <span class="hljs-keyword">if</span> ready &amp;&amp; valid {
    funct3_saved  = funct3;
    is_op32_saved = is_op32;
    op1sign_saved = op1[<span class="hljs-keyword">msb</span>];
    op2sign_saved = op2[<span class="hljs-keyword">msb</span>];
    <span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_mul {</span>
        state = State::WaitValid;
    <span class="custom-hl-bold">} <span class="hljs-keyword">else</span> {</span>
    <span class="custom-hl-bold">    <span class="hljs-keyword">if</span> du_signed_overflow {</span>
    <span class="custom-hl-bold">        state  = State::Finish;</span>
    <span class="custom-hl-bold">        result = <span class="hljs-keyword">if</span> funct3[<span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : {<span class="hljs-number">1&#39;b1</span>, <span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> XLEN - <span class="hljs-number">1</span>}; <span class="hljs-comment">// REM : DIV</span></span>
    <span class="custom-hl-bold">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> du_signed_divzero {</span>
    <span class="custom-hl-bold">        state  = State::Finish;</span>
    <span class="custom-hl-bold">        result = <span class="hljs-keyword">if</span> funct3[<span class="hljs-number">1</span>] ? op1 : &#39;<span class="hljs-number">1</span>; <span class="hljs-comment">// REM : DIV</span></span>
    <span class="custom-hl-bold">    } <span class="hljs-keyword">else</span> {</span>
    <span class="custom-hl-bold">        state = State::WaitValid;</span>
    <span class="custom-hl-bold">    }</span>
    <span class="custom-hl-bold">}</span>
}
</code></pre></div><p>計算が終了したら、商と剰余の符号を復元します。 商の符号は除数と被除数の符号が異なる場合に負になります。 剰余の符号は被除数の符号にします (リスト36)。</p><p><span class="caption">▼リスト9.36: 計算結果の符号を復元する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !is_mul &amp;&amp; du_rvalid {
    <span class="custom-hl-bold"><span class="hljs-keyword">let</span> quo_signed: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved != op2sign_saved ? ~du_quotient + <span class="hljs-number">1</span> : du_quotient;</span>
    <span class="custom-hl-bold"><span class="hljs-keyword">let</span> rem_signed: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved == <span class="hljs-number">1</span> ? ~du_remainder + <span class="hljs-number">1</span> : du_remainder;</span>
    result     = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="custom-hl-bold"><span class="hljs-number">2&#39;b00</span>  : quo_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// DIV</span></span>
        <span class="hljs-number">2&#39;b01</span>  : du_quotient[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// DIVU</span>
        <span class="custom-hl-bold"><span class="hljs-number">2&#39;b10</span>  : rem_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// REM</span></span>
        <span class="hljs-number">2&#39;b11</span>  : du_remainder[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// REMU</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span>,
    };
    state = State::Finish;
}
</code></pre></div><p>riscv-testsの<code>rv64um-p-div</code>、<code>rv64um-p-rem</code>を実行し、成功することを確認してください。</p><h2 id="divw、divuw、remw、remuw命令の実装" tabindex="-1">DIVW、DIVUW、REMW、REMUW命令の実装 <a class="header-anchor" href="#divw、divuw、remw、remuw命令の実装" aria-label="Permalink to “DIVW、DIVUW、REMW、REMUW命令の実装”">​</a></h2><p>DIVW、DIVUW、REMW、REMUW命令は、それぞれDIV、DIVU、REM、REMU命令の動作を32ビット同士の演算に変えた命令です。 32ビットの結果をXLENビットに符号拡張した値をデスティネーションレジスタに書き込みます。</p><p>generate_div_op関数に<code>is_op32</code>フラグを追加して、 <code>is_op32</code>が<code>1</code>なら値を<code>DIV_WIDTH</code>ビットに拡張したものに変更します (リスト37)。</p><p><span class="caption">▼リスト9.37: 除数、被除数を32ビットの値にする (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">function</span> generate_div_op (
    <span class="custom-hl-bold">is_op32: <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>      ,</span>
    funct3 : <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">3</span>&gt;   ,
    value  : <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span>&lt;XLEN&gt;,
) -&gt; <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">case</span> funct3[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="hljs-number">2&#39;b00</span>, <span class="hljs-number">2&#39;b10</span>: abs::&lt;DIV_WIDTH&gt;(<span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_op32 ? sext::&lt;<span class="hljs-number">32</span>, DIV_WIDTH&gt;(value[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]) :</span> value), <span class="hljs-comment">// DIV, REM</span>
        <span class="hljs-number">2&#39;b01</span>, <span class="hljs-number">2&#39;b11</span>: <span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_op32 ? {<span class="hljs-number">1&#39;b0</span> <span class="hljs-keyword">repeat</span> DIV_WIDTH - <span class="hljs-number">32</span>, value[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]} :</span> value, <span class="hljs-comment">// DIVU, REMU</span>
        <span class="hljs-keyword">default</span>     : <span class="hljs-number">0</span>,
    };
}

<span class="hljs-keyword">let</span> du_dividend: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = generate_div_op(<span class="custom-hl-bold">is_op32,</span> funct3, op1);
<span class="hljs-keyword">let</span> du_divisor : <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = generate_div_op(<span class="custom-hl-bold">is_op32,</span> funct3, op2);
</code></pre></div><p>符号付き除算のオーバーフローとゼロ除算の判定を<code>is_op32</code>で変更します (リスト38)。</p><p><span class="caption">▼リスト9.38: 32ビット演算のときの例外的な処理に対応する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code><span class="hljs-keyword">always_comb</span> {
    <span class="custom-hl-bold"><span class="hljs-keyword">if</span> is_op32 {</span>
    <span class="custom-hl-bold">    du_signed_overflow = !funct3[<span class="hljs-number">0</span>] &amp;&amp; op1[<span class="hljs-number">31</span>] == <span class="hljs-number">1</span> &amp;&amp; op1[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; &amp;op2[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];</span>
    <span class="custom-hl-bold">    du_signed_divzero  = !funct3[<span class="hljs-number">0</span>] &amp;&amp; op2[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>;</span>
    <span class="custom-hl-bold">} <span class="hljs-keyword">else</span> {</span>
        du_signed_overflow = !funct3[<span class="hljs-number">0</span>] &amp;&amp; op1[<span class="hljs-keyword">msb</span>] == <span class="hljs-number">1</span> &amp;&amp; op1[<span class="hljs-keyword">msb</span> - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; &amp;op2;
        du_signed_divzero  = !funct3[<span class="hljs-number">0</span>] &amp;&amp; op2 == <span class="hljs-number">0</span>;
    <span class="custom-hl-bold">}</span>
    du_signed_error = du_signed_overflow || du_signed_divzero;
}
</code></pre></div><p>最後に、32ビットの結果をXLENビットに符号拡張します (リスト39)。 符号付き、符号無し演算のどちらも32ビットの結果を符号拡張したものが結果になります。</p><p><span class="caption">▼リスト9.39: 32ビット演算のとき、結果を符号拡張する (muldivunit.veryl)</span></p><div class="language-veryl"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="hljs"><code>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !is_mul &amp;&amp; du_rvalid {
    <span class="hljs-keyword">let</span> quo_signed: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved != op2sign_saved ? ~du_quotient + <span class="hljs-number">1</span> : du_quotient;
    <span class="hljs-keyword">let</span> rem_signed: <span class="hljs-keyword">logic</span>&lt;DIV_WIDTH&gt; = <span class="hljs-keyword">if</span> op1sign_saved == <span class="hljs-number">1</span> ? ~du_remainder + <span class="hljs-number">1</span> : du_remainder;
    <span class="custom-hl-bold"><span class="hljs-keyword">let</span> resultX   : UIntX</span>            = <span class="hljs-keyword">case</span> funct3_saved[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
        <span class="hljs-number">2&#39;b00</span>  : quo_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// DIV</span>
        <span class="hljs-number">2&#39;b01</span>  : du_quotient[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// DIVU</span>
        <span class="hljs-number">2&#39;b10</span>  : rem_signed[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// REM</span>
        <span class="hljs-number">2&#39;b11</span>  : du_remainder[XLEN - <span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-comment">// REMU</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span>,
    };
    state  = State::Finish;
    <span class="custom-hl-bold">result = <span class="hljs-keyword">if</span> is_op32_saved ? sext::&lt;<span class="hljs-number">32</span>, <span class="hljs-number">64</span>&gt;(resultX[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]) : resultX;</span>
}
</code></pre></div><p>riscv-testsの<code>rv64um-p-</code>から始まるテストを実行し、成功することを確認してください。</p><p>これでM拡張を実装できました。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>手動で何をどのように利用するかを選択することもできます。既に用意された回路(IP)を使うこともできますが、本書は自作することを主軸としているため利用しません。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>そもそも除算器が搭載されていない場合があります。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>「効率」は、計算に要する時間やスループット、回路面積のことです。効率的に計算する方法については応用編で検討します。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/05b-synth.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>8 CPUの合成</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/11-impl-exception.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>10 例外の実装</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"00-preface.md\":\"DDGdJIg5\",\"02-setup.md\":\"NAwwJXp_\",\"03-veryl.md\":\"CfdP0nz9\",\"04-impl-rv32i.md\":\"D6HQhn-G\",\"04a-zicsr.md\":\"CThtddlO\",\"04b-riscvtests.md\":\"CW6e-oy1\",\"05-impl-rv64i.md\":\"DIMikneB\",\"05a-pipeline.md\":\"D92Nx-aw\",\"05b-synth.md\":\"CzClCWWq\",\"10-impl-m.md\":\"UxkEDKtO\",\"100-contribute.md\":\"CVKavJib\",\"11-impl-exception.md\":\"wScD8kDX\",\"12-impl-mmio.md\":\"BwxxU3HD\",\"13-impl-a.md\":\"CnPlYOpQ\",\"14-impl-c.md\":\"DqX93--N\",\"20-mmode-csr.md\":\"BSmJhJfG\",\"21-impl-interrupt.md\":\"BoBntBW9\",\"22-umode-csr.md\":\"BxF3jNM8\",\"23-smode-csr.md\":\"BTgvI4wQ\",\"24-impl-paging.md\":\"lA83XObo\",\"25-impl-plic.md\":\"BxNtHdp_\",\"26-run-linux.md\":\"CZfjbJCn\",\"99-postface.md\":\"CDNPw-b0\",\"99b-postface.md\":\"B_P9oVa3\",\"index.md\":\"7pP7Y4R2\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Verylで作るCPU\",\"description\":\"Write RISC-V CPU in Veryl\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[],\"sidebar\":[{\"text\":\"第I部 RV32I/RV64Iの実装\",\"items\":[{\"text\":\"まえがき\",\"link\":\"/00-preface\"},{\"text\":\"1 環境構築\",\"link\":\"/02-setup\"},{\"text\":\"2 ハードウェア記述言語 Veryl\",\"link\":\"/03-veryl\"},{\"text\":\"3 RV32Iの実装\",\"link\":\"/04-impl-rv32i\"},{\"text\":\"4 Zicsr拡張の実装\",\"link\":\"/04a-zicsr\"},{\"text\":\"5 riscv-testsによるテスト\",\"link\":\"/04b-riscvtests\"},{\"text\":\"6 RV64Iの実装\",\"link\":\"/05-impl-rv64i\"},{\"text\":\"7 CPUのパイプライン化\",\"link\":\"/05a-pipeline\"},{\"text\":\"8 CPUの合成\",\"link\":\"/05b-synth\"}]},{\"text\":\"第II部 RV64IMACの実装\",\"items\":[{\"text\":\"9 M拡張の実装\",\"link\":\"/10-impl-m\"},{\"text\":\"10 例外の実装\",\"link\":\"/11-impl-exception\"},{\"text\":\"11 Memory-mapped I/Oの実装\",\"link\":\"/12-impl-mmio\"},{\"text\":\"12 A拡張の実装\",\"link\":\"/13-impl-a\"},{\"text\":\"13 C拡張の実装\",\"link\":\"/14-impl-c\"}]},{\"text\":\"第III部 特権/割り込みの実装\",\"items\":[{\"text\":\"14 M-modeの実装 (1. CSRの実装)\",\"link\":\"/20-mmode-csr\"},{\"text\":\"15 M-modeの実装 (2. 割り込みの実装)\",\"link\":\"/21-impl-interrupt\"},{\"text\":\"16 U-modeの実装\",\"link\":\"/22-umode-csr\"},{\"text\":\"17 S-modeの実装 (1. CSRの実装)\",\"link\":\"/23-smode-csr\"},{\"text\":\"18 S-modeの実装 (2. 仮想記憶システム)\",\"link\":\"/24-impl-paging\"},{\"text\":\"19 PLICの実装\",\"link\":\"/25-impl-plic\"},{\"text\":\"20 Linuxを動かす\",\"link\":\"/26-run-linux\"},{\"text\":\"あとがき (第Ⅰ部)\",\"link\":\"/99-postface\"},{\"text\":\"あとがき (第Ⅱ部、第Ⅲ部)\",\"link\":\"/99b-postface\"},{\"text\":\"このプロジェクトに貢献する\",\"link\":\"/100-contribute\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/nananapo/veryl-riscv-book\"}],\"outline\":{\"level\":[2,4]}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>