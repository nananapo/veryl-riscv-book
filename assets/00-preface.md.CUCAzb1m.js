import{_ as e,c as l,o as s,ah as r}from"./chunks/framework.n0uClWLT.js";const u=JSON.parse('{"title":"まえがき","description":"","frontmatter":{},"headers":[],"relativePath":"00-preface.md","filePath":"00-preface.md"}'),n={name:"00-preface.md"};function o(t,a,i,p,c,h){return s(),l("div",null,[...a[0]||(a[0]=[r(`<h1 id="まえがき" tabindex="-1">まえがき <a class="header-anchor" href="#まえがき" aria-label="Permalink to “まえがき”">​</a></h1><p>こんにちは! あなたはCPUを自作したことがありますか? 自作したことがあってもなくても大歓迎、この本はCPU自作の面白さを世に広めるために執筆されました。</p><p>パソコンの主要な部品であるCPUは、とても規模が大きくて複雑な電子回路で構成されています。現代的で、高速で、ゲームができるようなCPUを作るのは非常に難しいです。ですが、ちょっと遅くて機能が少ないCPUなら、誰でも簡単に作ることができます。</p><p>本書では、<strong>Veryl</strong>という「ハードウェアを記述するための言語」でCPUを自作する方法を解説しています。Verylを使うと、例えば32ビットの足し算をする回路を次のように記述できます。</p><div class="language-verilog"><button title="Copy Code" class="copy"></button><span class="lang">verilog</span><pre class="hljs"><code><span class="hljs-keyword">module</span> Adder (
    x  : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">32</span>&gt;,
    y  : <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">32</span>&gt;,
    sum: <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>&lt;<span class="hljs-number">32</span>&gt;,
) {
    <span class="hljs-keyword">always_comb</span> {
        sum = x + y;
    }
}
</code></pre></div><p><code>x</code>と<code>y</code>を受け取って、<code>sum</code>に<code>x + y</code>を割り当てるだけ....簡単ですね。これと同様に、入出力を書いて、足し算やAND、OR、NOT演算などを書くだけで、CPUを書くことができます。</p><p>CPUは大きな論理回路です。でも、Verylで書いた小さな部品を組み合わせていけば、簡単に作ることができます。</p><p><strong>あなたもCPUを自作してみませんか？</strong>自分好みのCPUを作る第一歩を踏み出しましょう。</p><h2 id="本書を読むとわかること" tabindex="-1">本書を読むとわかること <a class="header-anchor" href="#本書を読むとわかること" aria-label="Permalink to “本書を読むとわかること”">​</a></h2><ul><li>CPUの仕組み、動作、実装</li><li>Verylの基本文法</li><li>VerylでのCPUの実装方法</li><li>RISC-Vの基本整数命令セット</li></ul><h2 id="対象読者" tabindex="-1">対象読者 <a class="header-anchor" href="#対象読者" aria-label="Permalink to “対象読者”">​</a></h2><ul><li><strong>自作CPUに興味がある人</strong></li><li>コンピュータアーキテクチャに興味がある人</li><li>Verylが気になっている人</li></ul><h2 id="必要な知識" tabindex="-1">必要な知識 <a class="header-anchor" href="#必要な知識" aria-label="Permalink to “必要な知識”">​</a></h2><ul><li>基本的な論理演算 (AND、OR、NOTくらいしか使いません)</li><li>C、C++、JavaScript、Python、Ruby、Rustのような一般的なプログラミング言語の経験</li></ul><p>本書では、Verylの他にC++, Python, Makefile, シェルスクリプトを使用します。Verylについては詳細を解説しています。他の言語については、動作とどのような機能を持つかは解説しますが、言語の仕様や書き方、ライブラリなどは説明しません。</p><h2 id="本書のソースコード-問い合わせ先" tabindex="-1">本書のソースコード / 問い合わせ先 <a class="header-anchor" href="#本書のソースコード-問い合わせ先" aria-label="Permalink to “本書のソースコード / 問い合わせ先”">​</a></h2><p>本書で利用するソースコードは、以下のリポジトリから入手できます。</p><ul><li><a href="https://github.com/nananapo/bluecore" target="_blank" rel="noreferrer">https://github.com/nananapo/bluecore</a></li></ul><p>本書は次のリポジトリで管理されています。質問や報告があるときは、以下のリポジトリでissueを作成してください。</p><ul><li><a href="https://github.com/nananapo/veryl-riscv-book" target="_blank" rel="noreferrer">https://github.com/nananapo/veryl-riscv-book</a></li></ul><h2 id="cpuの自作" tabindex="-1">CPUの自作 <a class="header-anchor" href="#cpuの自作" aria-label="Permalink to “CPUの自作”">​</a></h2><p>CPUって自作できるのでしょうか? そもそもCPUの自作って何でしょうか? CPUの自作の一般的な定義はありませんが、 筆者は 「命令セットアーキテクチャの設計」 「論理設計」 「物理的に製造する」 に分類できると考えています。</p><p><strong>命令セットアーキテクチャ</strong>(Instruction Set Architecture, <strong>ISA</strong>)とは、 CPUがどのような命令を実行できるかを定めたもの(仕様)です。 <strong>論理設計</strong>とは、簡単に言うと、 仕様の動作を実現する論理回路を設計することです。 CPUは論理回路で構成されているため、CPUの設計には論理設計が必要になります。 最近のCPUは、物理的には<strong>VLSI</strong>(Very Large Scale Integration, 超大規模集積回路)によって実装されています。 VLSIの製造には莫大なお金が必要です<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>ISAと実装(設計と製造)には深い関わりがあるため、 ISAを知らずして実装はできないし、 実装を知らずしてISAを作ることはできません。 本書では、RISC-VというISAのCPUを実装することで、 一般的なCPUの作り方やアーキテクチャについて学びます。</p><p>物理的な製造のハードルは高いですが、 FPGAを使うことで簡単にお試しできます。 <strong>FPGA</strong>(Field Programmable Gate Array)とは、 任意の論理回路を実現できる集積回路のことです。 最近では、安価(数千 ～ 数万円)でFPGAを入手できます。</p><p>CPUのテストはシミュレータとFPGAで行います。 本書では、Tang Nano 9KとPYNQ-Z1というFPGAを利用します。 FPGAを持っていると、 自作CPUによってLEDを制御したり、 手持ちのパソコンと直接通信したりして楽しむことができます。</p><h2 id="risc-v" tabindex="-1">RISC-V <a class="header-anchor" href="#risc-v" aria-label="Permalink to “RISC-V”">​</a></h2><p><strong>RISC-V</strong>は、カリフォルニア大学バークレー校で開発されたISAです。 仕様書の初版は2011年に公開されました。 ISAとしての歴史はまだ浅いですが、 仕様が広く公開されていてカスタマイズ可能であるという特徴もあって、 着実に広がりつつあります。</p><p>インターネット上には多くのRISC-Vの実装が公開されています。 例として、 <a href="https://github.com/chipsalliance/rocket-chip" target="_blank" rel="noreferrer">RocketChip</a>(Chiselによる実装)、 <a href="https://shakti.org.in/" target="_blank" rel="noreferrer">Shakti</a>(Bluespec SystemVerilogによる実装)、 <a href="https://github.com/rsd-devel/rsd" target="_blank" rel="noreferrer">RSD</a>(SystemVerilogによる実装)が挙げられます。</p><p>本書では、RISC-VのバージョンRISC-V ISA Manual, version 20240411 を利用します。 RISC-Vの最新の仕様は、GitHubの <a href="https://github.com/riscv/riscv-isa-manual/" target="_blank" rel="noreferrer">riscv/riscv-isa-manual</a> で確認できます。</p><p>RISC-Vには、基本整数命令セットとしてRV32I、RV64I、RV32E、RV64E<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>が定義されています。 RVの後ろにつく数字はレジスタの長さが何ビットかです。 基本整数命令セットには最低限の命令しか定義されていません。 それ以外のかけ算や割り算、不可分操作などの命令や機能は拡張として定義されています。</p><p>どの拡張を実装しているかを示す文字列では、 例えばかけ算と割り算、不可分操作ができるRV32IのCPUは<code>RV32IMA</code>と表現されます。 本書では、まず、<code>RV32I</code>のCPUを実装します。 これを、OSを実行できる程度までに進化させることを目標に実装を進めます。</p><h2 id="本書の構成" tabindex="-1">本書の構成 <a class="header-anchor" href="#本書の構成" aria-label="Permalink to “本書の構成”">​</a></h2><p>本シリーズ(基本編)では、次のようにCPUを実装していきます。</p><ol><li>RV32IのCPUを実装する (第3章)</li><li>Zicsr拡張を実装する (第4章)</li><li>CPUをテストする (第5章)</li><li>RV64Iを実装する (第6章)</li><li>パイプライン化する (第7章)</li><li>実機でテストする (第8章)</li><li>M拡張、A拡張、C拡張を実装する</li><li>UARTと割り込みを実装する</li><li>OSを実行するために必要なCSRを実装する</li><li>OSを実行する</li></ol><h2 id="凡例" tabindex="-1">凡例 <a class="header-anchor" href="#凡例" aria-label="Permalink to “凡例”">​</a></h2><p>プログラムコードの差分は次のように修飾されます。 ただし、リスト内のコードが全て新しく追加されるときは修飾しません。 削除されたコードを示さない場合もあります。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="custom-hl-del">print(&quot;Hello, world!\\n&quot;);</span>       ← 削除したコード
<span class="custom-hl-bold">print(&quot;Hello, &quot;+name+&quot;!\\n&quot;);</span>    ← 追加、変更したコード
</code></pre></div><p>ターミナル画面は、次のように表示します。</p><div class="language-terminal"><button title="Copy Code" class="copy"></button><span class="lang">terminal</span><pre class="hljs"><code><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> Hello       ← 行頭の「$」はプロンプト、それ以降がユーザ入力</span>
</code></pre></div><p>プログラムコードやターミナル画面は、<code>...</code>などの複数の点で省略することがあります。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>小さいチップなら安く(数万 ～ 数百万円で)製造できます。OpenMPWやTinyTapeoutで検索してください <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>RV128Iもありますが、まだDraft段階(準備中)です <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>`,43)])])}const f=e(n,[["render",o]]);export{u as __pageData,f as default};
