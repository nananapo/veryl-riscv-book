<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>M-modeの実装 (2. 割り込みの実装) | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="U-modeの実装" href="22-umode-csr.html">
    <link rel="prev" title="M-modeの実装 (1. CSRの実装)" href="20-mmode-csr.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき</a></li>
<li class="toc-part">第I部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">1 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">2 例外の実装</a></li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">3 Memory-mapped I/Oの実装</a></li>
    <li class="toc-chapter"><a href="./13-impl-a.html">4 A拡張の実装</a></li>
    <li class="toc-chapter"><a href="./14-impl-c.html">5 C拡張の実装</a></li>
  </ul>
</li>
<li class="toc-part">第II部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">6 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">7 M-modeの実装 (2. 割り込みの実装)</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-1">7.1 概要</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-2">7.2 RISC-Vの割り込み</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-3">7.3 aclint_memoryモジュールの作成</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-4">7.4 ソフトウェア割り込みの実装 (MSWI)</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-5">7.5 mtvecのVectoredモードの実装</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-6">7.6 タイマ割り込みの実装 (MTIMER)</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-7">7.7 WFI命令の実装</a></li>
        <li class="toc-section"><a href="./21-impl-interrupt.html#h7-8">7.8 time、instret、cycleレジスタの実装</a></li>
      </ul>
    </li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">8 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">9 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">10 S-modeの実装 (2. 仮想記憶システム)</a></li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">11 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">12 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h7"></a><span class="secno">第7章</span> <br/>M-modeの実装 (2. 割り込みの実装)</h1>

<h2 class="numbox"><a id="h7-1"></a><span class="secno">7.1</span> 概要</h2>

<h3 class="none"><a id="h7-1-1"></a><span class="secno">7.1.1</span> 割り込みとは何か？</h3>
<p>アプリケーションを記述するとき、キーボードやマウスの入力、時間の経過のようなイベントに起因して何らかのプログラムを実行したいことがあります。例えばキーボードから入力を得たいとき、ポーリング(Polling)、または割り込み(Interrupt)という手法が利用されます。</p>
<p>TODO図</p>
<p>ポーリングとは、定期的に問い合わせを行う方式のことです。例えばキーボード入力の場合、定期的にキーボードデバイスにアクセスして入力があるかどうかを確かめます。1秒くらいかかる処理Aを繰り返すとして、繰り返しごとに入力の有無を確認する場合、最大1秒の遅延が発生します(TODO 図)。待ち時間減らすために処理Aを分割すると遅延は減少しますが、長時間キーボード入力が無い場合、入力の有無の確認頻度が上がる分だけ何も入力が無いデバイスに対する確認処理が実行されることになります。この問題は、CPUからデバイスに問い合わせをする方式では解決できません。</p>
<p>入力の理想的な確認タイミングは入力が確認できるようになってすぐであるため、入力があったタイミングでデバイス側からCPUにイベントを通知すればいいです。これを実現するのが割り込みです。</p>
<p>TODO 図</p>
<p>割り込みとは、何らかのイベントの通知によって実行中のプログラムを中断して通知内容を処理する方式のことです。割り込みを使うと、ポーリングのように無駄にデバイスにアクセスをすることなく、入力の処理が必要な時にだけ実行できます(TODO 図)。</p>

<h2 id="riscv-interrupts" class="numbox"><a id="h7-2"></a><span class="secno">7.2</span> RISC-Vの割り込み</h2>
<p>RISC-Vでは割り込み機能がCSRによって提供されます。割り込みが発生するとトラップが発生します。割り込みを発生させるようなイベントは外部割り込み、ソフトウェア割り込み、タイマ割り込みの3つに大別されます。</p>
<dl>
<dt>外部割り込み (External Interrupt)</dt>
<dd>
    コア外部のデバイスによって発生する割り込み。
    複数の外部デバイスの割り込みは割り込みコントローラ(<a href="./25-impl-plic.html">第11章「PLICの実装」</a>)などによって調停(制御)されます。
</dd>
<dt>ソフトウェア割り込み (Software Interrupt)</dt>
<dd>
    CPUで動くソフトウェアが発生させる割り込み。
    CSR、もしくはメモリにマップされたレジスタ値の変更によって発生します。
</dd>
<dt>タイマ割り込み (Timer Interrupt)</dt>
<dd>
    タイマ回路(デバイス)によって引き起こされる割り込み。
    タイマの設定と時間経過によって発生します。
</dd>
</dl>
<p><b>M-modeだけ</b>が実装されたRISC-VのCPUでは、次にような順序で割り込みが提供されます。他に実装されている特権レベルがある場合については「<a href="22-umode-csr.html#h8-9">8.9 割り込み条件の変更</a>」、「<a href="23-smode-csr.html#h9-4">9.4 トラップの委譲</a>」で解説します。</p>
<ol start="1" type="1">
<li>割り込みを発生させるようなイベントがデバイスで発生する</li>
<li>割り込み原因に対応したmipレジスタのビットが<code class="inline-code">0</code>から<code class="inline-code">1</code>になる</li>
<li>割り込み原因に対応したmieレジスタのビットが<code class="inline-code">1</code>であることを確認する (<code class="inline-code">0</code>なら割り込みは発生しない)</li>
<li>mstatus.MIEが<code class="inline-code">1</code>であることを確認する (<code class="inline-code">0</code>なら割り込みは発生しない)</li>
<li>(割り込み(トラップ)開始)</li>
<li>mstatus.MPIEにmstatus.MIEを格納する</li>
<li>mstatus.MIEに<code class="inline-code">0</code>を格納する</li>
<li>mtvecレジスタの値にジャンプする</li>
</ol>
<p>TODO mipとmieの図</p>
<p>mip(Machine Interrupt Pending)レジスタは割り込みの発生を待っている(待機)状態を示すMXLENビットのCSRです(TODO 図)。mie(Machine Interrupt Enable)レジスタは割り込みを許可するかを原因ごとに管理する制御するMXLENビットのCSRです(TODO 図)。mstatus.MIEはすべての割り込みを許可するかどうかを制御する1ビットのフィールドです。mieとmstatus.MIEのことを割り込みイネーブル(許可)レジスタと呼び、特にmstatus.MIEのようなすべての割り込みを制御するレジスタのことをグローバル割り込みイネーブルビットと呼びます</p>
<p>割り込みの発生時にmstatus.MIEを0にすることで、割り込みの処理中に割り込みが発生することを防いでいます。また、トラップから戻る(MRET命令を実行する)とき、mstatus.MPIEの値をmstatus.MIEに書き戻すことで割り込みの許可状態を戻します。</p>

<h3 class="none"><a id="h7-2-1"></a><span class="secno">7.2.1</span> 割り込みの優先順位</h3>
<p>RISC-Vには外部割り込み、ソフトウェア割り込み、タイマ割り込みがそれぞれM-mode、S-mode向けに用意されています。それぞれの割り込みにはテーブルTODOのような優先順位が定義されていて、複数の割り込みを発生させられるときは優先順位が高い割り込みを発生させます。</p>
<p>TODOテーブル</p>

<h3 class="none"><a id="h7-2-2"></a><span class="secno">7.2.2</span> 割り込みの原因(cause)</h3>
<p>それぞれの割り込みには原因を区別するための値(cause)が割り当てられています。割り込みのcauseのMSBは1です。</p>
<p><code class="inline-code">CsrCause</code>型に割り込みのcauseを追加します()。</p>
<div id="eei.veryl.mmapcause.CsrCause" class="caption-code">
<span class="caption">リスト7.1: リスト7.1:  (eei.veryl)</span>
<pre class="list language-CsrCause">    enum CsrCause: UIntX {
        INSTRUCTION_ADDRESS_MISALIGNED = 0,
        ILLEGAL_INSTRUCTION = 2,
        BREAKPOINT = 3,
        LOAD_ADDRESS_MISALIGNED = 4,
        STORE_AMO_ADDRESS_MISALIGNED = 6,
        ENVIRONMENT_CALL_FROM_M_MODE = 11,
        <b>SUPERVISOR_SOFTWARE_INTERRUPT = 'h8000_0000_0000_0001,</b>
        <b>MACHINE_SOFTWARE_INTERRUPT = 'h8000_0000_0000_0003,</b>
        <b>SUPERVISOR_TIMER_INTERRUPT = 'h8000_0000_0000_0005,</b>
        <b>MACHINE_TIMER_INTERRUPT = 'h8000_0000_0000_0007,</b>
        <b>SUPERVISOR_EXTERNAL_INTERRUPT = 'h8000_0000_0000_0009,</b>
        <b>MACHINE_EXTERNAL_INTERRUPT = 'h8000_0000_0000_000b,</b>
    }
</pre>
</div>

<h3 class="none"><a id="h7-2-3"></a><span class="secno">7.2.3</span> ACLINT (Advanced Core Local Interruptor)</h3>
<p>RISC-Vにはソフトウェア割り込みとタイマ割り込みを実現するデバイスの仕様であるACLINTが用意されています。ACLINTは、SiFive社が開発したCLINT(Core-Local Interruptor)デバイスが基になった仕様です。</p>
<p>ACLINTにはMTIMER、MSWI、SSWIの3つのデバイスが定義されています。それぞれタイマ割り込み、ソフトウェア割り込み、ソフトウェア割り込み向けのデバイスで、mipレジスタのMTIP、MSIP、SSIPビットに状態を通知します。</p>
<p>本書ではACLINTを図TODOのようなメモリマップで実装します。本章ではMTIMER、MSWIデバイスを実装し、「<a href="23-smode-csr.html#h9-5">9.5 ソフトウェア割り込みの実装 (SSWI)</a>」でSSWIデバイスを実装します。デバイスのの具体的な仕様については後で解説します。</p>
<p>メモリマップ用の定数をeeiパッケージに記述してください()。</p>
<div id="eei.veryl.mmapcause.mmap" class="caption-code">
<span class="caption">リスト7.2: リスト7.2:  (eei.veryl)</span>
<pre class="list language-mmap">    // ACLINT
    const MMAP_ACLINT_BEGIN   : Addr = 'h200_0000 as Addr;
    const MMAP_ACLINT_MSIP    : Addr = 0;
    const MMAP_ACLINT_MTIMECMP: Addr = 'h4000 as Addr;
    const MMAP_ACLINT_MTIME   : Addr = 'h7ff8 as Addr;
    const MMAP_ACLINT_SETSSIP : Addr = 'h8000 as Addr;
    const MMAP_ACLINT_END     : Addr = MMAP_ACLINT_BEGIN + 'hbfff as Addr;
</pre>
</div>

<h2 class="numbox"><a id="h7-3"></a><span class="secno">7.3</span> aclint_memoryモジュールの作成</h2>
<p>本章では、ACLINTのデバイスを1つのaclint_memoryモジュールに実装します。aclint_memoryモジュールは割り込みを起こすためにcsrunitモジュールと接続します。</p>

<h3 class="none"><a id="h7-3-1"></a><span class="secno">7.3.1</span> インターフェースを作成する</h3>
<p>まず、ACLINTのデバイスとcsrunitモジュールを接続するためのインターフェースを作成します。<code class="inline-code">src/aclint_if.veryl</code>を作成し、次のように記述します()。インターフェースの中身は各デバイスの実装時に実装します。</p>
<div id="aclint_if.veryl.createaclint.mmap" class="caption-code">
<span class="caption">リスト7.3: リスト7.3:  (aclint_if.veryl)</span>
<pre class="list language-mmap">interface aclint_if {
    modport master {
        // TODO
    }
    modport slave {
        ..converse(master)
    }
}
</pre>
</div>

<h3 class="none"><a id="h7-3-2"></a><span class="secno">7.3.2</span> aclint_memoryモジュールを作成する</h3>
<p>ACLINTのデバイスを実装するモジュールを作成します。<code class="inline-code">src/aclint_memory.veryl</code>を作成し、次のように記述します()。まだどのレジスタも実装していません。</p>
<div id="aclint_memory.veryl.createaclint.mmap" class="caption-code">
<span class="caption">リスト7.4: リスト7.4:  (aclint_memory.veryl)</span>
<pre class="list language-mmap">import eei::*;

module aclint_memory (
    clk   : input   clock            ,
    rst   : input   reset            ,
    membus: modport Membus::slave    ,
    aclint: modport aclint_if::master,
) {
    assign membus.ready = 1;
    always_ff {
        if_reset {
            membus.rvalid = 0;
            membus.rdata  = 0;
        } else {
            membus.rvalid = membus.valid;
        }
    }
}
</pre>
</div>

<h3 class="none"><a id="h7-3-3"></a><span class="secno">7.3.3</span> mmio_controllerモジュールにACLINTを追加する</h3>
<p>mmio_controllerモジュールにACLINTデバイスを追加して、aclint_memoryモジュールにアクセスできるようにします。</p>
<p><code class="inline-code">Device</code>型にACLINTを追加して、アドレスにACLINTをマップします()。</p>
<div id="mmio_controller.veryl.createaclint.Device" class="caption-code">
<span class="caption">リスト7.5: リスト7.5:  (mmio_controller.veryl)</span>
<pre class="list language-Device">    enum Device {
        UNKNOWN,
        RAM,
        ROM,
        DEBUG,
        <b>ACLINT,</b>
    }
</pre>
</div>
<div id="mmio_controller.veryl.createaclint.get_device" class="caption-code">
<span class="caption">リスト7.6: リスト7.6:  (mmio_controller.veryl)</span>
<pre class="list language-get_device">    if MMAP_ACLINT_BEGIN &lt;= addr &amp;&amp; addr &lt;= MMAP_ACLINT_END {
        return Device::ACLINT;
    }
</pre>
</div>
<p>ACLINTとのインターフェースを追加し、reset_all_device_masters関数にインターフェースをリセットするコードを追加します()。</p>
<div id="mmio_controller.veryl.createaclint.port" class="caption-code">
<span class="caption">リスト7.7: リスト7.7:  (mmio_controller.veryl)</span>
<pre class="list language-port">module mmio_controller (
    clk          : input   clock         ,
    rst          : input   reset         ,
    DBG_ADDR     : input   Addr          ,
    req_core     : modport Membus::slave ,
    ram_membus   : modport Membus::master,
    rom_membus   : modport Membus::master,
    dbg_membus   : modport Membus::master,
    <b>aclint_membus: modport Membus::master,</b>
) {
</pre>
</div>
<div id="mmio_controller.veryl.createaclint.reset_all" class="caption-code">
<span class="caption">リスト7.8: リスト7.8:  (mmio_controller.veryl)</span>
<pre class="list language-reset_all">    function reset_all_device_masters () {
        reset_membus_master(ram_membus);
        reset_membus_master(rom_membus);
        reset_membus_master(dbg_membus);
        <b>reset_membus_master(aclint_membus);</b>
    }
</pre>
</div>
<p><code class="inline-code">ready</code>、<code class="inline-code">rvalid</code>を取得する関数にACLINTを登録します()。</p>
<div id="mmio_controller.veryl.createaclint.get_device_ready" class="caption-code">
<span class="caption">リスト7.9: リスト7.9:  (mmio_controller.veryl)</span>
<pre class="list language-get_device_ready">    Device::ACLINT: return aclint_membus.ready;
</pre>
</div>
<div id="mmio_controller.veryl.createaclint.get_device_rvalid" class="caption-code">
<span class="caption">リスト7.10: リスト7.10:  (mmio_controller.veryl)</span>
<pre class="list language-get_device_rvalid">    Device::ACLINT: return aclint_membus.rvalid;
</pre>
</div>
<p>ACLINTの<code class="inline-code">rvalid</code>、<code class="inline-code">rdata</code>を<code class="inline-code">req_core</code>に割り当てます()。</p>
<div id="mmio_controller.veryl.createaclint.assign_device_slave" class="caption-code">
<span class="caption">リスト7.11: リスト7.11:  (mmio_controller.veryl)</span>
<pre class="list language-assign_device_slave">    Device::ACLINT: req &lt;&gt; aclint_membus;
</pre>
</div>
<p>ACLINTのインターフェースに要求を割り当てます()。</p>
<div id="mmio_controller.veryl.createaclint.assign_device_master" class="caption-code">
<span class="caption">リスト7.12: リスト7.12:  (mmio_controller.veryl)</span>
<pre class="list language-assign_device_master">    Device::ACLINT: {
        aclint_membus      &lt;&gt; req;
        aclint_membus.addr -= MMAP_ACLINT_BEGIN;
    }
</pre>
</div>

<h3 class="none"><a id="h7-3-4"></a><span class="secno">7.3.4</span> ACLINTとmmio_controller、csrunitモジュールを接続する</h3>
<p>aclint_ifインターフェース、aclint_memoryモジュールとmmio_controllerモジュールを接続するインターフェースをインスタンス化します()。</p>
<div id="top.veryl.createaclint.aclint_membus" class="caption-code">
<span class="caption">リスト7.13: リスト7.13:  (top.veryl)</span>
<pre class="list language-aclint_membus">    inst aclint_membus  : Membus;
</pre>
</div>
<div id="top.veryl.createaclint.aclint_core_bus" class="caption-code">
<span class="caption">リスト7.14: リスト7.14:  (top.veryl)</span>
<pre class="list language-aclint_core_bus">    inst aclint_core_bus: aclint_if;
</pre>
</div>
<p>aclint_memoryモジュールをインスタンス化し、mmio_controllerモジュールと接続します()。</p>
<div id="top.veryl.createaclint.inst" class="caption-code">
<span class="caption">リスト7.15: リスト7.15:  (top.veryl)</span>
<pre class="list language-inst">    inst aclintm: aclint_memory (
        clk                    ,
        rst                    ,
        membus: aclint_membus  ,
        aclint: aclint_core_bus,
    );
</pre>
</div>
<div id="top.veryl.createaclint.mmioc" class="caption-code">
<span class="caption">リスト7.16: リスト7.16:  (top.veryl)</span>
<pre class="list language-mmioc">    inst mmioc: mmio_controller (
        clk                           ,
        rst                           ,
        DBG_ADDR     : MMAP_DBG_ADDR  ,
        req_core     : mmio_membus    ,
        ram_membus   : mmio_ram_membus,
        rom_membus   : mmio_rom_membus,
        dbg_membus                    ,
        <b>aclint_membus                 ,</b>
    );
</pre>
</div>
<p>core、csrunitモジュールにaclint_ifポートを追加し、csrunitモジュールとaclint_memoryモジュールを接続します()。</p>
<div id="core.veryl.createaclint.port" class="caption-code">
<span class="caption">リスト7.17: リスト7.17:  (core.veryl)</span>
<pre class="list language-port">module core (
    clk     : input   clock               ,
    rst     : input   reset               ,
    i_membus: modport core_inst_if::master,
    d_membus: modport core_data_if::master,
    led     : output  UIntX               ,
    <b>aclint  : modport aclint_if::slave    ,</b>
) {
</pre>
</div>
<div id="top.veryl.createaclint.core" class="caption-code">
<span class="caption">リスト7.18: リスト7.18:  (top.veryl)</span>
<pre class="list language-core">    inst c: core (
        clk                      ,
        rst                      ,
        i_membus: i_membus_core  ,
        d_membus: d_membus_core  ,
        led                      ,
        <b>aclint  : aclint_core_bus,</b>
    );
</pre>
</div>
<div id="csrunit.veryl.createaclint.port" class="caption-code">
<span class="caption">リスト7.19: リスト7.19:  (csrunit.veryl)</span>
<pre class="list language-port">    minstret   : input   UInt64              ,
    led        : output  UIntX               ,
    <b>aclint     : modport aclint_if::slave    ,</b>
) {
</pre>
</div>
<div id="core.veryl.createaclint.csru" class="caption-code">
<span class="caption">リスト7.20: リスト7.20:  (core.veryl)</span>
<pre class="list language-csru">        minstret                          ,
        led                               ,
        <b>aclint                            ,</b>
    );
</pre>
</div>

<h2 class="numbox"><a id="h7-4"></a><span class="secno">7.4</span> ソフトウェア割り込みの実装 (MSWI)</h2>
<p>MSWIデバイスはソフトウェア割り込み(machine software interrupt)を提供するためのデバイスです。MSWIデバイスにはハードウェアスレッド毎に4バイトのMSIPレジスタが用意されています(TODO テーブル)。MSIPレジスタの上位31ビットは読み込み専用の<code class="inline-code">0</code>であり、最下位ビットのみ変更できます。各MSIPレジスタは、それに対応するハードウェアスレッドのmip.MSIPと接続されています。</p>
<p>TODOテーブル (最大4095個)</p>
<p>仕様上はmhartidとACLINTのレジスタのhartIDが一致する必要はありませんが、本書ではmhartidとhartIDが同じになるように実装します。</p>

<h3 class="none"><a id="h7-4-1"></a><span class="secno">7.4.1</span> MSIPレジスタを実装する</h3>
<p>ACLINTモジュールにMSIPレジスタを実装します。今のところCPUにはmhartidが0のハードウェアスレッドしか存在しないため、MSIP0のみ実装します。</p>
<p>aclint_ifインターフェースに<code class="inline-code">msip</code>を追加します()。</p>
<div id="aclint_if.veryl.msip" class="caption-code">
<span class="caption">リスト7.21: リスト7.21:  (aclint_if.veryl)</span>
<pre class="list language-msip">interface aclint_if {
    <b>var msip: logic;</b>
    modport master {
        <b>msip: output,</b>
    }
    modport slave {
        ..converse(master)
    }
}
</pre>
</div>
<p>aclint_memoryモジュールに<code class="inline-code">msip0</code>レジスタを作成し、読み書きできるようにします()。</p>
<div id="aclint_memory.veryl.msip.reg" class="caption-code">
<span class="caption">リスト7.22: リスト7.22:  (aclint_memory.veryl)</span>
<pre class="list language-reg">var msip0: logic;
</pre>
</div>
<div id="aclint_memory.veryl.msip.if_reset" class="caption-code">
<span class="caption">リスト7.23: リスト7.23:  (aclint_memory.veryl)</span>
<pre class="list language-if_reset">always_ff {
    if_reset {
        membus.rvalid = 0;
        membus.rdata  = 0;
        <b>msip0         = 0;</b>
</pre>
</div>
<div id="aclint_memory.veryl.msip.rw" class="caption-code">
<span class="caption">リスト7.24: リスト7.24:  (aclint_memory.veryl)</span>
<pre class="list language-rw">if membus.valid {
    let addr: Addr = {membus.addr[XLEN - 1:3], 3'b0};
    if membus.wen {
        let M: logic&lt;MEMBUS_DATA_WIDTH&gt; = membus.wmask_expand();
        let D: logic&lt;MEMBUS_DATA_WIDTH&gt; = membus.wdata &amp; M;
        case addr {
            MMAP_ACLINT_MSIP: msip0 = D[0] | msip0 &amp; ~M[0];
            default         : {}
        }
    } else {
        membus.rdata = case addr {
            MMAP_ACLINT_MSIP: {63'b0, msip0},
            default         : 0,
        };
    }
}
</pre>
</div>
<p><code class="inline-code">msip0</code>レジスタとインターフェースの<code class="inline-code">msip</code>を接続します()。</p>
<div id="aclint_memory.veryl.msip.aclint_msip" class="caption-code">
<span class="caption">リスト7.25: リスト7.25:  (aclint_memory.veryl)</span>
<pre class="list language-aclint_msip">always_comb {
    aclint.msip = msip0;
}
</pre>
</div>

<h3 class="none"><a id="h7-4-2"></a><span class="secno">7.4.2</span> mip、mieレジスタを実装する</h3>
<p>mipレジスタのMSIPビット、MIEレジスタのMSIEビットを実装します。mie.MSIEはMSIPビットによる割り込み待機を許可するかを制御するビットです。mip.MSIPとmie.MSIEは同じ位置のビットに配置されています。mip.MSIPに書き込むことはできません。</p>
<p>csrunitモジュールにmieレジスタを作成します()。</p>
<div id="csrunit.veryl.miemip.regmie" class="caption-code">
<span class="caption">リスト7.26: リスト7.26:  (csrunit.veryl)</span>
<pre class="list language-regmie">    var mie     : UIntX ;
</pre>
</div>
<div id="csrunit.veryl.miemip.if_reset" class="caption-code">
<span class="caption">リスト7.27: リスト7.27:  (csrunit.veryl)</span>
<pre class="list language-if_reset">if_reset {
    mode     = PrivMode::M;
    mstatus  = 0;
    mtvec    = 0;
    <b>mie      = 0;</b>
    mscratch = 0;
</pre>
</div>
<p>mipレジスタを作成します。MSIPビットをMSWIデバイスのMSIP0レジスタと接続し、それ以外のビットは<code class="inline-code">0</code>に設定します()。</p>
<div id="csrunit.veryl.miemip.mip" class="caption-code">
<span class="caption">リスト7.28: リスト7.28:  (csrunit.veryl)</span>
<pre class="list language-mip">    let mip: UIntX = {
        1'b0 repeat XLEN - 12, // 0
        1'b0, // MEIP
        1'b0, // 0
        1'b0, // SEIP
        1'b0, // 0
        1'b0, // MTIP
        1'b0, // 0
        1'b0, // STIP
        1'b0, // 0
        aclint.msip, // MSIP
        1'b0, // 0
        1'b0, // SSIP
        1'b0, // 0
    };
</pre>
</div>
<p>mie、mipレジスタの値を読み込めるようにします()。</p>
<div id="csrunit.veryl.miemip.rdata" class="caption-code">
<span class="caption">リスト7.29: リスト7.29:  (csrunit.veryl)</span>
<pre class="list language-rdata">CsrAddr::MTVEC   : mtvec,
<b>CsrAddr::MIP     : mip,</b>
<b>CsrAddr::MIE     : mie,</b>
CsrAddr::MCYCLE  : mcycle,
</pre>
</div>
<p>mieレジスタの書き込みマスクを設定して、MSIEビットを書き込めるようにします()。あとでMTIMEデバイスを実装するときにMTIEビットを使うため、ここでMTIEビットも書き込めるようにしておきます。</p>
<div id="csrunit.veryl.miemip.WMASK" class="caption-code">
<span class="caption">リスト7.30: リスト7.30:  (csrunit.veryl)</span>
<pre class="list language-WMASK">    const MIE_WMASK     : UIntX = 'h0000_0000_0000_0088 as UIntX;
</pre>
</div>
<div id="csrunit.veryl.miemip.wmask" class="caption-code">
<span class="caption">リスト7.31: リスト7.31:  (csrunit.veryl)</span>
<pre class="list language-wmask">CsrAddr::MTVEC   : MTVEC_WMASK,
<b>CsrAddr::MIE     : MIE_WMASK,</b>
CsrAddr::MSCRATCH: MSCRATCH_WMASK,
</pre>
</div>
<div id="csrunit.veryl.miemip.write" class="caption-code">
<span class="caption">リスト7.32: リスト7.32:  (csrunit.veryl)</span>
<pre class="list language-write">if is_wsc {
    case csr_addr {
        CsrAddr::MSTATUS : mstatus  = wdata;
        CsrAddr::MTVEC   : mtvec    = wdata;
        <b>CsrAddr::MIE     : mie      = wdata;</b>
        CsrAddr::MSCRATCH: mscratch = wdata;
</pre>
</div>

<h3 class="none"><a id="h7-4-3"></a><span class="secno">7.4.3</span> mstatusのMIE、MPIEビットを実装する</h3>
<p>mstatus.MIE、MPIEを変更できるようにします()。</p>
<div id="csrunit.veryl.mstatuswmask.WMASK" class="caption-code">
<span class="caption">リスト7.33: リスト7.33:  (csrunit.veryl)</span>
<pre class="list language-WMASK">    const MSTATUS_WMASK : UIntX = 'h0000_0000_0000_0088 as UIntX;
</pre>
</div>
<div id="csrunit.veryl.mstatuswmask.mstatus" class="caption-code">
<span class="caption">リスト7.34: リスト7.34:  (csrunit.veryl)</span>
<pre class="list language-mstatus">    // mstatus bits
    let mstatus_mpie: logic = mstatus[7];
    let mstatus_mie : logic = mstatus[3];
</pre>
</div>
<p>トラップが発生するとき、mstatus.MPIEにmstatus.MIE、mstatus.MIEに<code class="inline-code">0</code>を設定します()。また、MRET命令でmmstatus.MIEにmstatus.MPIE、mstatus.MPIEに<code class="inline-code">0</code>を設定します。</p>
<div id="csrunit.veryl.mstatuswmask.change" class="caption-code">
<span class="caption">リスト7.35: リスト7.35:  (csrunit.veryl)</span>
<pre class="list language-change">if raise_trap {
    if raise_expt {
        mepc   = pc;
        mcause = trap_cause;
        mtval  = expt_value;
        <b>// save mstatus.mie to mstatus.mpie</b>
        <b>// and set mstatus.mie = 0</b>
        <b>mstatus[7] = mstatus[3];</b>
        <b>mstatus[3] = 0;</b>
    } <b>else if trap_return {</b>
        <b>// set mstatus.mie = mstatus.mpie</b>
        <b>//     mstatus.mpie = 0</b>
        <b>mstatus[3] = mstatus[7];</b>
        <b>mstatus[7] = 0;</b>
    <b>}</b>
</pre>
</div>
<p>これによりトラップで割り込みを無効化して、トラップから戻るときにmstatus.MIEを元に戻す、という動作が実現されます。</p>

<h3 class="none"><a id="h7-4-4"></a><span class="secno">7.4.4</span> 割り込み処理の実装</h3>
<p>必要なレジスタを実装できたので、割り込みを起こす処理を実装します。割り込みはmip、mieの両方のビット、mstatus.MIEビットが立っているときに発生します。</p>

<h4><a id="h7-4-4-1"></a>割り込みのタイミング</h4>
<p>割り込みはcsrunitモジュールに有効な命令が供給されているときにのみ発生させることができ、割り込みが発生したときにcsrunitモジュールに供給されていた命令は実行されません。</p>
<p>ここで、割り込みを起こすタイミングに注意が必要です。</p>
<p>今のところ、CSRの処理はMEMステージと同時に行っているため、例えばストア命令をmemunitモジュールで実行している途中に割り込みを発生させてしまうと、ストア命令の結果がメモリに反映されるにもかかわらず、mepcレジスタにストア命令のアドレスを書き込んでしまいます。</p>
<p>それならば、単純に次の命令のアドレスをmepcレジスタに格納するようにすればいいと思うかもしれませんが、そもそも実行中のストア命令が本来は最終的に例外を発生させるものかもしれません。</p>
<p>本章ではこの問題に対処するために、割り込みはMEM(CSR)ステージに新しく命令が供給されたクロックでしか起こせなくして、トラップが発生するときにMEMステージを無効化します。</p>
<p>割り込みを発生させられるかを示すフラグをcsrunitモジュールに定義し、<code class="inline-code">mems_is_new</code>フラグを割り当てます()。</p>
<div id="csrunit.veryl.intr.port" class="caption-code">
<span class="caption">リスト7.36: リスト7.36:  (csrunit.veryl)</span>
<pre class="list language-port">    rs1_data   : input   UIntX               ,
    <b>can_intr   : input   logic               ,</b>
    rdata      : output  UIntX               ,
</pre>
</div>
<div id="core.veryl.intr.csru" class="caption-code">
<span class="caption">リスト7.37: リスト7.37:  (core.veryl)</span>
<pre class="list language-csru">    rs1_data   : memq_rdata.rs1_data  ,
    <b>can_intr   : mems_is_new          ,</b>
    rdata      : csru_rdata           ,
</pre>
</div>
<p>トラップが発生するときにmemunitモジュールを無効にします()。今まではEXステージまでに例外が発生することが分かっていたら無効にしていましたが、csrunitモジュールからトラップが発生するかどうかの情報を直接得るようにします。</p>
<div id="core.veryl.intr.memu" class="caption-code">
<span class="caption">リスト7.38: リスト7.38:  (core.veryl)</span>
<pre class="list language-memu">    inst memu: memunit (
        clk                                   ,
        rst                                   ,
        valid : mems_valid &amp;&amp; !<b>csru_raise_trap</b>,
</pre>
</div>
<p>memunitモジュールが無効(<code class="inline-code">!valid</code>)なとき、<code class="inline-code">state</code>を<code class="inline-code">State::Init</code>にリセットします()。</p>
<div id="memunit.veryl.intr.reset" class="caption-code">
<span class="caption">リスト7.39: リスト7.39:  (core.veryl)</span>
<pre class="list language-reset">    } else {
        if <b>!</b>valid {
            <b>state = State::Init;</b>
        <b>} else {</b>
            case state {
                State::Init: if is_new &amp; inst_is_memop(ctrl) {
</pre>
</div>

<h4><a id="h7-4-4-2"></a>割り込みの判定</h4>
<p>割り込みを起こせるかどうか、cause、ジャンプ先を示す変数を作成します()。</p>
<div id="csrunit.veryl.intr.intr" class="caption-code">
<span class="caption">リスト7.40: リスト7.40:  (csrunit.veryl)</span>
<pre class="list language-intr">    // Interrupt
    let raise_interrupt : logic = valid &amp;&amp; can_intr &amp;&amp; mstatus_mie &amp;&amp; (mip &amp; mie) != 0;
    let interrupt_cause : UIntX = CsrCause::MACHINE_SOFTWARE_INTERRUPT;
    let interrupt_vector: Addr  = mtvec;
</pre>
</div>
<p>トラップ情報の変数に、割り込みの情報を割り当てます()。本書では例外を優先します。</p>
<div id="csrunit.veryl.intr.trap" class="caption-code">
<span class="caption">リスト7.41: リスト7.41:  (csrunit.veryl)</span>
<pre class="list language-trap">    assign raise_trap = raise_expt || <b>raise_interrupt ||</b> trap_return;
    let trap_cause: UIntX = <b>switch {</b>
    <b>    raise_expt     : expt_cause,</b>
    <b>    raise_interrupt: interrupt_cause,</b>
    <b>    default        : 0,</b>
    <b>};</b>
    assign trap_vector = <b>switch {</b>
    <b>    raise_expt     : mtvec,</b>
    <b>    raise_interrupt: interrupt_vector,</b>
    <b>    trap_return    : mepc,</b>
    <b>    default        : 0,</b>
    <b>};</b>
</pre>
</div>
<p>割り込みの時にMRET命令の判定が<code class="inline-code">0</code>になるようにしておきます()。</p>
<div id="csrunit.veryl.intr.ret" class="caption-code">
<span class="caption">リスト7.42: リスト7.42:  (csrunit.veryl)</span>
<pre class="list language-ret">    // Trap Return
    assign trap_return = valid &amp;&amp; is_mret &amp;&amp; !raise_expt <b>&amp;&amp; !raise_interrupt</b>;
</pre>
</div>
<p>トラップが発生するとき、例外の場合にのみmtvalレジスタに例外の情報が書き込まれます。本書では例外を優先するので、<code class="inline-code">raise_expt</code>が<code class="inline-code">1</code>ならmtvalレジスタに書き込むようにします()。</p>
<div id="csrunit.veryl.intr.ff" class="caption-code">
<span class="caption">リスト7.43: リスト7.43:  (csrunit.veryl)</span>
<pre class="list language-ff">    if raise_trap {
        if raise_expt <b>|| raise_interrupt</b> {
            mepc   = pc;
            mcause = trap_cause;
            <b>if raise_expt {</b>
                mtval = expt_value;
            <b>}</b>
</pre>
</div>

<h3 class="none"><a id="h7-4-5"></a><span class="secno">7.4.5</span> ソフトウェア割り込みをテストする</h3>
<p>ソフトウェア割り込みが正しく動くことを確認します。</p>
<p><code class="inline-code">test/mswi.c</code>を作成し、次のように記述します()。</p>
<div id="mswi.c.mswitest" class="caption-code">
<span class="caption">リスト7.44: リスト7.44:  (test/mswi.c)</span>
<pre class="list language-mswitest">#define MSIP0 ((volatile unsigned int *)0x2000000)
#define DEBUG_REG ((volatile unsigned long long*)0x40000000)
#define MIE_MSIE (1 &lt;&lt; 3)
#define MSTATUS_MIE (1 &lt;&lt; 3)

void interrupt_handler(void);

void w_mtvec(unsigned long long x) {
    asm volatile(&quot;csrw mtvec, %0&quot; : : &quot;r&quot; (x));
}

void w_mie(unsigned long long x) {
    asm volatile(&quot;csrw mie, %0&quot; : : &quot;r&quot; (x));
}

void w_mstatus(unsigned long long x) {
    asm volatile(&quot;csrw mstatus, %0&quot; : : &quot;r&quot; (x));
}

void main(void) {
    w_mtvec((unsigned long long)interrupt_handler);
    w_mie(MIE_MSIE);
    w_mstatus(MSTATUS_MIE);
    *MSIP0 = 1;
    while (1) *DEBUG_REG = 3; // fail
}

void interrupt_handler(void) {
    *DEBUG_REG = 1; // success
}
</pre>
</div>
<p>プログラムでは、mtvecにinterrupt_handler関数のアドレスを書き込み、mstatus.MIE、mie.MSIEを<code class="inline-code">1</code>に設定して割り込みを許可してからMSIP0レジスタに1を書き込んでいます。</p>
<p>プログラムをコンパイルして実行<sup><a id="fnb-howtocompile" href="#fn-howtocompile" class="noteref" epub:type="noteref">*1</a></sup>すると、ソフトウェア割り込みが発生することでinterrupt_handlerにジャンプし、デバッグ用のデバイスに<code class="inline-code">1</code>を書き込んで終了することを確認できます。</p>
<div class="footnote-list">
<div class="footnote" id="fn-howtocompile" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>コンパイル、実行方法は「<a href="12-impl-mmio.html#h3-6-4">3.6.4 出力をテストする</a>」を参考にしてください。</p></div>
</div><!--/.footnote-list-->

<h2 class="numbox"><a id="h7-5"></a><span class="secno">7.5</span> mtvecのVectoredモードの実装</h2>
<p>mtvecレジスタにはMODEフィールドがあり、割り込みが発生するときのジャンプ先の決定方法を制御できます。</p>
<p>MODEがDirect(<code class="inline-code">2'b00</code>)のとき、<code class="inline-code">mtvec.BASE &lt;&lt; 2</code>のアドレスにトラップします。Vectored(<code class="inline-code">2'b01</code>)のとき、<code class="inline-code">(mtvec.BASE &lt;&lt; 2) + 4 * cause</code>のアドレスにトラップします。ここでcauseは割り込みのcauseのMSBを除いた値です。例えばmachine software interruptの場合、<code class="inline-code">(mtvec.BASE &lt;&lt; 2) + 4 * 3</code>がジャンプ先になります。</p>
<p>例外のジャンプ先のアドレスは、常にMODEがDirectとして計算します。</p>
<p>下位1ビットに書き込めるようにすることで、mtvec.MODEにVectoredを書き込めるようにします()。</p>
<div id="csrunit.veryl.mtvectored.WMASK" class="caption-code">
<span class="caption">リスト7.45: リスト7.45:  (csrunit.veryl)</span>
<pre class="list language-WMASK">    const MTVEC_WMASK   : UIntX = 'hffff_ffff_ffff_fff<b>d</b>;
</pre>
</div>
<p>割り込みのジャンプ先をMODEとcauseに応じて変更します()。</p>
<div id="csrunit.veryl.mtvectored.interrupt_vector" class="caption-code">
<span class="caption">リスト7.46: リスト7.46:  (csrunit.veryl)</span>
<pre class="list language-interrupt_vector">    let interrupt_vector: Addr  = if mtvec[0] == 0 ? {mtvec[msb:2], 2'b0} : // Direct
     {mtvec[msb:2] + interrupt_cause[msb - 2:0], 2'b0}; // Vectored
</pre>
</div>
<p>例外のジャンプ先を、mtvecレジスタの下位2ビットを<code class="inline-code">0</code>にしたアドレス(Direct)に変更します()。新しく<code class="inline-code">expt_vector</code>を定義し、<code class="inline-code">trap_vector</code>に割り当てます。</p>
<div id="csrunit.veryl.mtvectored.expt_vector" class="caption-code">
<span class="caption">リスト7.47: リスト7.47:  (csrunit.veryl)</span>
<pre class="list language-expt_vector">    let expt_vector: Addr = {mtvec[msb:2], 2'b0};
</pre>
</div>
<div id="csrunit.veryl.mtvectored.trap_vector" class="caption-code">
<span class="caption">リスト7.48: リスト7.48:  (csrunit.veryl)</span>
<pre class="list language-trap_vector">    assign trap_vector = switch {
        raise_expt     : <b>expt_vector</b>,
        raise_interrupt: interrupt_vector,
        trap_return    : mepc,
        default        : 0,
    };
</pre>
</div>

<h2 class="numbox"><a id="h7-6"></a><span class="secno">7.6</span> タイマ割り込みの実装 (MTIMER)</h2>

<h3 class="none"><a id="h7-6-1"></a><span class="secno">7.6.1</span> タイマ割り込みの仕組み</h3>
<p>MTIMERデバイスは、タイマ割り込み(machine timer interrupt)を提供するためのデバイスです。MTIMERデバイスには1つの8バイトのMTIMEレジスタ、ハードウェアスレッド毎に8バイトのMTIMECMPレジスタが用意されています(TODOテーブル)。本書ではMTIMECMPの後ろにMTIMEを配置します。</p>
<p>TODO テーブル (MTIME)TODO テーブル (MTIMECMP 最大4095個)</p>
<p>MTIMEレジスタは、固定された周波数でのサイクル数をカウントするレジスタです。リセット時に<code class="inline-code">0</code>になります。</p>
<p>MTIMERデバイスは、それに対応するハードウェアスレッドのmip.MTIPと接続されており、MTIMEがMTIMECMPを上回ったときmip.MTIPを<code class="inline-code">1</code>にします。これにより、指定した時間に割り込みを発生させることが可能になります。</p>

<h3 class="none"><a id="h7-6-2"></a><span class="secno">7.6.2</span> MTIME、MTIMECMPレジスタを実装する</h3>
<p>ACLINTモジュールにMTIME、MTIMECMPレジスタを実装します。今のところmhartidが<code class="inline-code">0</code>のハードウェアスレッドしか存在しないため、MTIMECMP0のみ実装します。</p>
<p><code class="inline-code">mtime</code>、<code class="inline-code">mtimecmp0</code>レジスタを作成し、読み書きできるようにします()。<code class="inline-code">mtime</code>レジスタはクロック毎にインクリメントします。</p>
<div id="aclint_memory.veryl.mtime.reg" class="caption-code">
<span class="caption">リスト7.49: リスト7.49:  (aclint_memory.veryl)</span>
<pre class="list language-reg">    var msip0    : logic ;
    var mtime    : UInt64;
    var mtimecmp0: UInt64;
</pre>
</div>
<div id="aclint_memory.veryl.mtime.reset" class="caption-code">
<span class="caption">リスト7.50: リスト7.50:  (aclint_memory.veryl)</span>
<pre class="list language-reset">    always_ff {
        if_reset {
            membus.rvalid = 0;
            membus.rdata  = 0;
            msip0         = 0;
            <b>mtime         = 0;</b>
            <b>mtimecmp0     = 0;</b>
</pre>
</div>
<div id="aclint_memory.veryl.mtime.rw" class="caption-code">
<span class="caption">リスト7.51: リスト7.51:  (aclint_memory.veryl)</span>
<pre class="list language-rw">    if membus.wen {
        let M: logic&lt;MEMBUS_DATA_WIDTH&gt; = membus.wmask_expand();
        let D: logic&lt;MEMBUS_DATA_WIDTH&gt; = membus.wdata &amp; M;
        case addr {
            MMAP_ACLINT_MSIP    : msip0     = D[0] | msip0 &amp; ~M[0];
            <b>MMAP_ACLINT_MTIME   : mtime     = D | mtime &amp; ~M;</b>
            <b>MMAP_ACLINT_MTIMECMP: mtimecmp0 = D | mtimecmp0 &amp; ~M;</b>
            default             : {}
        }
    } else {
        membus.rdata = case addr {
            MMAP_ACLINT_MSIP    : {63'b0, msip0},
            <b>MMAP_ACLINT_MTIME   : mtime,</b>
            <b>MMAP_ACLINT_MTIMECMP: mtimecmp0,</b>
            default             : 0,
        };
    }
</pre>
</div>
<p>aclint_ifインターフェースに<code class="inline-code">mtip</code>を作成し、タイマ割り込みが発生する条件を設定します()。</p>
<div id="aclint_if.veryl.mtime.mtip" class="caption-code">
<span class="caption">リスト7.52: リスト7.52:  (aclint_if.veryl)</span>
<pre class="list language-mtip">    var msip: logic;
    <b>var mtip: logic;</b>
    modport master {
        msip: output,
        <b>mtip: output,</b>
    }
</pre>
</div>
<div id="aclint_memory.veryl.mtime.comb" class="caption-code">
<span class="caption">リスト7.53: リスト7.53:  (aclint_memory.veryl)</span>
<pre class="list language-comb">    always_comb {
        aclint.msip = msip0;
        <b>aclint.mtip = mtime &gt;= mtimecmp0;</b>
    }
</pre>
</div>

<h3 class="none"><a id="h7-6-3"></a><span class="secno">7.6.3</span> mip.MTIP、割り込み原因を設定する</h3>
<p>mipレジスタのMTIPビットにaclint_ifインターフェースの<code class="inline-code">mtip</code>を接続します。</p>
<div id="csrunit.veryl.mtime.mip" class="caption-code">
<span class="caption">リスト7.54: リスト7.54:  (csrunit.veryl)</span>
<pre class="list language-mip">    let mip: UIntX = {
        1'b0 repeat XLEN - 12, // 0, LCOFIP
        1'b0, // MEIP
        1'b0, // 0
        1'b0, // SEIP
        1'b0, // 0
        <b>aclint.mtip</b>, // MTIP
        1'b0, // 0
        1'b0, // STIP
        1'b0, // 0
        aclint.msip, // MSIP
        1'b0, // 0
        1'b0, // SSIP
        1'b0, // 0
    };
</pre>
</div>
<p>割り込み原因を優先順位に応じて設定します。タイマ割り込みはソフトウェア割り込みよりも優先順位が低いため、ソフトウェア割り込みの下で原因を設定します()。</p>
<div id="csrunit.veryl.mtime.intr" class="caption-code">
<span class="caption">リスト7.55: リスト7.55:  (csrunit.veryl)</span>
<pre class="list language-intr">    <b>let interrupt_pending: UIntX = mip &amp; mie;</b>
    let raise_interrupt  : logic = valid &amp;&amp; can_intr &amp;&amp; mstatus_mie &amp;&amp; <b>interrupt_pending != 0</b>;
    let interrupt_cause  : <b>UIntX = switch {</b>
        <b>interrupt_pending[3]:</b> CsrCause::MACHINE_SOFTWARE_INTERRUPT<b>,</b>
        <b>interrupt_pending[7]: CsrCause::MACHINE_TIMER_INTERRUPT,</b>
        <b>default             : 0,</b>
    <b>}</b>;
    let interrupt_vector: Addr = if mtvec[0] == 0 ? {mtvec[msb:2], 2'b0} : // Direct
     {mtvec[msb:2] + interrupt_cause[msb - 2:0], 2'b0}; // Vectored
</pre>
</div>

<h3 class="none"><a id="h7-6-4"></a><span class="secno">7.6.4</span> タイマ割り込みをテストする</h3>
<p>タイマ割り込みが正しく動くことを確認します。</p>
<p><code class="inline-code">test/mtime.c</code>を作成し、次のように記述します()。</p>
<div id="mtime.c.mtime" class="caption-code">
<span class="caption">リスト7.56: リスト7.56:  (mtime.c)</span>
<pre class="list language-mtime">#define MTIMECMP0 ((volatile unsigned int *)0x2004000)
#define MTIME     ((volatile unsigned int *)0x2007ff8)
#define DEBUG_REG ((volatile unsigned long long*)0x40000000)
#define MIE_MTIE (1 &lt;&lt; 7)
#define MSTATUS_MIE (1 &lt;&lt; 3)

void interrupt_handler(void);

void w_mtvec(unsigned long long x) {
    asm volatile(&quot;csrw mtvec, %0&quot; : : &quot;r&quot; (x));
}

void w_mie(unsigned long long x) {
    asm volatile(&quot;csrw mie, %0&quot; : : &quot;r&quot; (x));
}

void w_mstatus(unsigned long long x) {
    asm volatile(&quot;csrw mstatus, %0&quot; : : &quot;r&quot; (x));
}

void main(void) {
    w_mtvec((unsigned long long)interrupt_handler);
    *MTIMECMP0 = *MTIME + 1000000; // この数値は適当に調整する
    w_mie(MIE_MTIE);
    w_mstatus(MSTATUS_MIE);
    while (1);
    *DEBUG_REG = 3; // fail
}

void interrupt_handler(void) {
    *DEBUG_REG = 1; // success
}
</pre>
</div>
<p>プログラムでは、mtvecにinterrupt_handler関数のアドレスを設定し、mtimeに<code class="inline-code">10000000</code>を足した値をmtimecmp0に設定した後、mstatus.MIE、mie.MTIEを<code class="inline-code">1</code>に設定して割り込みを許可しています。タイマ割り込みが発生するまでwhile文で無限ループします。</p>
<p>プログラムをコンパイルして実行すると、時間経過によってmain関数からinterrupt_handler関数にトラップしてテストが終了します。mtimecmp0に設定する値を変えることで、タイマ割り込みが発生するまでの時間が変わることを確認してください。</p>

<h2 class="numbox"><a id="h7-7"></a><span class="secno">7.7</span> WFI命令の実装</h2>
<p>WFI命令は、割り込みが発生するまでCPUをストールさせる命令です。ただし、グローバル割り込みイネーブルビットは考慮せず、ある割り込みの待機(pending)ビットと許可(enable)ビットの両方が立っているときに実行を再開します。また、それ以外の自由な理由で実行を再開させてもいいです。WFI命令で割り込みが発生するとき、WFI命令の次のアドレスの命令で割り込みが起こったことにします。</p>
<p>本書ではWFI命令を何もしない命令として実装します。</p>
<p>inst_decoderモジュールでWFI命令をデコードできるようにします()。</p>
<div id="inst_decoder.veryl.wfi.wfi" class="caption-code">
<span class="caption">リスト7.57: リスト7.57:  (inst_decoder.veryl)</span>
<pre class="list language-wfi">    OP_SYSTEM: f3 != 3'b000 &amp;&amp; f3 != 3'b100 || // CSRR(W|S|C)[I]
     bits == 32'h00000073 || // ECALL
     bits == 32'h00100073 || // EBREAK
     bits == 32'h30200073 <b>||</b> //MRET
     <b>bits == 32'h10500073</b>, <b>// WFI</b>
    OP_MISC_MEM: T, // FENCE
</pre>
</div>
<p>WFI命令で割り込みが発生するとき、mepcレジスタに<code class="inline-code">pc + 4</code>を書き込むようにします()。</p>
<div id="csrunit.veryl.wfi.is_wfi" class="caption-code">
<span class="caption">リスト7.58: リスト7.58:  (csrunit.veryl)</span>
<pre class="list language-is_wfi">    let is_wfi: logic = inst_bits == 32'h10500073;
</pre>
</div>
<div id="csrunit.veryl.wfi.expt" class="caption-code">
<span class="caption">リスト7.59: リスト7.59:  (csrunit.veryl)</span>
<pre class="list language-expt">    if raise_expt || raise_interrupt {
        mepc = <b>if raise_expt ? pc : // exception</b>
         <b>if raise_interrupt &amp;&amp; is_wfi ? pc + 4 : pc; // interrupt when wfi / interrupt</b>
        mcause = trap_cause;
</pre>
</div>

<h2 class="numbox"><a id="h7-8"></a><span class="secno">7.8</span> time、instret、cycleレジスタの実装</h2>
<p>RISC-Vにはtime、instret、cycleという読み込み専用のCSRが定義されており、それぞれmtime、minstret、mcycleレジスタと同じ値をとります<sup><a id="fnb-hpmcounter" href="#fn-hpmcounter" class="noteref" epub:type="noteref">*2</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-hpmcounter" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>mhpmcounterレジスタと同じ値をとるhpmcounterレジスタもありますが、mhpmcounterレジスタを実装していないので実装しません。</p></div>
</div><!--/.footnote-list-->
<p><code class="inline-code">CsrAddr</code>型にレジスタのアドレスを追加します()。</p>
<div id="eei.veryl.zicntr.CsrAddr" class="caption-code">
<span class="caption">リスト7.60: リスト7.60:  (eei.veryl)</span>
<pre class="list language-CsrAddr">    // Unprivileged Counter/Timers
    CYCLE = 12'hC00,
    TIME = 12'hC01,
    INSTRET = 12'hC02,
</pre>
</div>
<p>mtimeレジスタの値をACLINTモジュールからcsrunitに渡します()。</p>
<div id="aclint_if.veryl.zicntr.mtime" class="caption-code">
<span class="caption">リスト7.61: リスト7.61:  (aclint_if.veryl)</span>
<pre class="list language-mtime"><b>import eei::*;</b>

interface aclint_if {
    var msip : logic ;
    var mtip : logic ;
    <b>var mtime: UInt64;</b>
    modport master {
        msip : output,
        mtip : output,
        <b>mtime: output,</b>
    }
</pre>
</div>
<div id="aclint_memory.veryl.zicntr.comb" class="caption-code">
<span class="caption">リスト7.62: リスト7.62:  (aclint_memory.veryl)</span>
<pre class="list language-comb">    always_comb {
        aclint.msip  = msip0;
        aclint.mtip  = mtime &gt;= mtimecmp0;
        <b>aclint.mtime = mtime;</b>
    }
</pre>
</div>
<p>time、instret、cycleレジスタを読み込めるようにします()。</p>
<div id="csrunit.veryl.zicntr.rdata" class="caption-code">
<span class="caption">リスト7.63: リスト7.63:  (csrunit.veryl)</span>
<pre class="list language-rdata">    CsrAddr::CYCLE   : mcycle,
    CsrAddr::TIME    : aclint.mtime,
    CsrAddr::INSTRET : minstret,
</pre>
</div>
        </main>
        <nav class="page-navi">
          <a href="20-mmode-csr.html" class="page-prev">&#9664;</a>
          <a href="22-umode-csr.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
