<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    
    <title>C拡張の実装 | Verylで作るCPU</title>

    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/webstyle.css" />
    <link rel="next" title="M-modeの実装 (1. CSRの実装)" href="20-mmode-csr.html">
    <link rel="prev" title="A拡張の実装" href="13-impl-a.html">
    <meta name="generator" content="Re:VIEW Starter">

    <script async defer src="https://buttons.github.io/buttons.js"></script>

  </head>
  <body style="background-color:#eff4ff">
    <div class="page-outer" style="background-color:white">
      <div class="side-content">
                <a class="nav-title" href="index.html">Verylで作るCPU</a>

        <div style="display:flex; gap:10px; align-items: center;">
          <a class="github-button" href="https://github.com/nananapo/veryl-riscv-book" data-color-scheme="no-preference: light_high_contrast; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star nananapo/veryl-riscv-book on GitHub">Star</a>
          <div style="">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
          </div>
          <div style="margin-bottom: 14px;" id="share-facebook" class="fb-share-button" data-href="" data-layout="" data-size=""><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Finvalid.invalid%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Facebookでシェアする</a></div>
        </div>
        <ul class="toc toc-1">
    <li class="toc-chapter"><a href="./00-preface.html">まえがき</a></li>
<li class="toc-part">第I部 RV64IMACの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./10-impl-m.html">1 M拡張の実装</a></li>
    <li class="toc-chapter"><a href="./11-impl-exception.html">2 例外の実装</a></li>
    <li class="toc-chapter"><a href="./12-impl-mmio.html">3 Memory-mapped I/Oの実装</a></li>
    <li class="toc-chapter"><a href="./13-impl-a.html">4 A拡張の実装</a></li>
    <li class="toc-chapter"><a href="./14-impl-c.html">5 C拡張の実装</a>
      <ul class="toc toc-3">
        <li class="toc-section"><a href="./14-impl-c.html#h5-1">5.1 概要</a></li>
        <li class="toc-section"><a href="./14-impl-c.html#h5-2">5.2 IALIGNの変更</a></li>
        <li class="toc-section"><a href="./14-impl-c.html#h5-3">5.3 実装方針</a></li>
        <li class="toc-section"><a href="./14-impl-c.html#h5-4">5.4 命令フェッチモジュールの実装</a></li>
        <li class="toc-section"><a href="./14-impl-c.html#h5-5">5.5 16ビット境界に配置された32ビット幅の命令のサポート</a></li>
        <li class="toc-section"><a href="./14-impl-c.html#h5-6">5.6 RVC命令の変換</a></li>
      </ul>
    </li>
  </ul>
</li>
<li class="toc-part">第II部 特権/割り込みの実装
  <ul class="toc toc-2">
    <li class="toc-chapter"><a href="./20-mmode-csr.html">6 M-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./21-impl-interrupt.html">7 M-modeの実装 (2. 割り込みの実装)</a></li>
    <li class="toc-chapter"><a href="./22-umode-csr.html">8 U-modeの実装</a></li>
    <li class="toc-chapter"><a href="./23-smode-csr.html">9 S-modeの実装 (1. CSRの実装)</a></li>
    <li class="toc-chapter"><a href="./24-impl-paging.html">10 S-modeの実装 (2. 仮想記憶システム)</a></li>
    <li class="toc-chapter"><a href="./25-impl-plic.html">11 PLICの実装</a></li>
    <li class="toc-chapter"><a href="./26-run-linux.html">12 Linuxを動かす</a></li>
  </ul>
</li>
    <li class="toc-chapter"><a href="./99b-postface.html">あとがき</a></li>
</ul>
      </div>
      <div class="page-inner">
        <header class="page-header">
        </header>
        <main class="page-main">
  <h1 class="boldlines center twolines"><a id="h5"></a><span class="secno">第5章</span> <br/>C拡張の実装</h1>

<h2 class="numbox"><a id="h5-1"></a><span class="secno">5.1</span> 概要</h2>
<p>これまでに実装した命令はすべて32ビット幅のものでした。RISC-Vには32ビット幅以外の命令が定義されており、それぞれ命令の下位ビットで何ビット幅の命令か判断できます(TODO 図)。</p>
<p>TODO 図</p>
<p>C拡張は16ビット幅の命令を定義する拡張です。よく使われる命令の幅を16ビットに圧縮できるようにすることでコードサイズを削減できます。これ以降、C拡張によって導入される16ビット幅の命令のことをRVC命令と呼びます。</p>
<p>全てのRVC命令には同じ操作をする32ビット幅の命令が存在します<sup><a id="fnb-zc-pseudo" href="#fn-zc-pseudo" class="noteref" epub:type="noteref">*1</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-zc-pseudo" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*1] </span>Zc*拡張の一部の命令は複数の命令になります</p></div>
</div><!--/.footnote-list-->
<p>RVC命令は表TODOの9つのフォーマットが定義されています。</p>
<p>表TODO</p>
<p><code class="inline-code">rs1'</code>、<code class="inline-code">rs2'</code>、<code class="inline-code">rd'</code>は3ビットのフィールドで、よく使われる8番(x8)から15番(x15)のレジスタを指定します。即値の並び方やそれぞれの命令の具体的なフォーマットについては、仕様書か「<a href="14-impl-c.html#h5-6-2">5.6.2 32ビット幅の命令に変換する</a>」を参照してください。</p>
<p>RV32IのCPUに実装されるC拡張には表TODOのRVC命令が定義されています。RV64IのCPUに実装されるC拡張には表TODOに加えて表TODOのRVC命令が定義されています。一部のRV32IのRVC命令はRV64Iで別の命令に置き換わっていることに注意してください。</p>
<p>表TODO reservedとHINTについても書く表TODO reservedとHINTについても書く</p>
<p>C拡張は浮動小数点命令をサポートするF、D拡張が実装されている場合に他の命令を定義しますが、基本編ではF、D拡張を実装しないため解説しません。</p>

<h2 class="numbox"><a id="h5-2"></a><span class="secno">5.2</span> IALIGNの変更</h2>
<p>TODO 図</p>
<p>「<a href="11-impl-exception.html#h2-5">2.5 命令アドレスのミスアライン例外</a>」で解説したように、命令はIALIGNビットに整列したアドレスに配置されます。C拡張はIALIGNによる制限を16ビットに緩め、全ての命令が16ビットに整列されたアドレスに配置されるように変更します。これにより、RVC命令と32ビット幅の命令の組み合わせがあったとしても効果的にコードサイズを削減できます(TODO 図)。</p>
<p>eeiパッケージに定数<code class="inline-code">IALIGN</code>を定義します()。</p>
<div id="eei.veryl.ialign.IALIGN" class="caption-code">
<span class="caption">リスト5.1: リスト5.1:  (eei.veryl)</span>
<pre class="list language-IALIGN">    const IALIGN: u32 = 16;
</pre>
</div>
<p>mepcレジスタの書き込みマスクを変更して、トラップ時のジャンプ先アドレスに16ビットに整列されたアドレスを指定できるようにします()。mtvecレジスタの下位2ビットはアドレスではない情報を指定するために使用されているため、変更の必要はありません。</p>
<div id="csrunit.veryl.ialign.mepc" class="caption-code">
<span class="caption">リスト5.2: リスト5.2:  (eei.veryl)</span>
<pre class="list language-mepc">    const MEPC_WMASK  : UIntX = 'hffff_ffff_ffff_fff<b>e</b>;
</pre>
</div>
<p>命令アドレスのミスアライン例外の判定を変更します。IALIGNが16の場合は例外が発生しないようにします()。ジャンプ、分岐命令は2バイト単位のアドレスしか指定できないため、C拡張が実装されている場合には例外が発生しません。</p>
<div id="core.veryl.ialign.exception" class="caption-code">
<span class="caption">リスト5.3: リスト5.3:  (core.veryl)</span>
<pre class="list language-exception">        let instruction_address_misaligned: logic = <b>IALIGN == 32 &amp;&amp;</b> memq_wdata.br_taken &amp;&amp; memq_wdata.jump_addr[1:0] != 2'b00;
</pre>
</div>

<h2 class="numbox"><a id="h5-3"></a><span class="secno">5.3</span> 実装方針</h2>
<p>本章では次の順序でC拡張を実装します。</p>
<ol start="1" type="1">
<li>命令フェッチ処理(IFステージ)をcoreモジュールから分離する</li>
<li>16ビットに整列されたアドレスに配置された32ビット幅の命令を処理できるようにする</li>
<li>RVC命令を32ビット幅の命令に変換するモジュールを作成する</li>
<li>RVC命令を32ビット幅の命令に変換してcoreモジュールに供給する</li>
</ol>
<p>最終的な命令フェッチ処理の構成は図TODOのようになります。</p>
<p>TODO core &lt;-&gt; inst_fetcher &lt;-&gt; memの図</p>

<h2 class="numbox"><a id="h5-4"></a><span class="secno">5.4</span> 命令フェッチモジュールの実装</h2>

<h3 class="none"><a id="h5-4-1"></a><span class="secno">5.4.1</span> インターフェースを作成する</h3>
<p>まず、命令フェッチを行うモジュールとcoreモジュールのインターフェースを定義します。</p>
<p><code class="inline-code">src/core_inst_if.veryl</code>を作成し、次のように記述します()。</p>
<div id="core_inst_if.veryl.if" class="caption-code">
<span class="caption">リスト5.4: リスト5.4:  (core_inst_if.veryl)</span>
<pre class="list language-if">import eei::*;

interface core_inst_if {
    var rvalid   : logic;
    var rready   : logic;
    var raddr    : Addr ;
    var rdata    : Inst ;
    var is_hazard: logic;
    var next_pc  : Addr ;

    modport master {
        rvalid   : input ,
        rready   : output,
        raddr    : input ,
        rdata    : input ,
        is_hazard: output, // control hazard
        next_pc  : output, // actual next pc
    }

    modport slave {
        ..converse(master)
    }
}
</pre>
</div>
<p><code class="inline-code">rvalid</code>、<code class="inline-code">rready</code>、<code class="inline-code">raddr</code>、<code class="inline-code">rdata</code>は、coreモジュールのFIFO(<code class="inline-code">if_fifo</code>)の<code class="inline-code">wvalid</code>、<code class="inline-code">wready</code>、<code class="inline-code">wdata.addr</code>、<code class="inline-code">wdata.bits</code>と同じ役割を果たします。<code class="inline-code">is_hazard</code>、<code class="inline-code">next_pc</code>は制御ハザードの情報を伝えるための変数です。</p>

<h3 class="none"><a id="h5-4-2"></a><span class="secno">5.4.2</span> coreモジュールのIFステージを削除する</h3>
<p>coreモジュールのIFステージを削除し、core_inst_ifインターフェースで代替します<sup><a id="fnb-no-del" href="#fn-no-del" class="noteref" epub:type="noteref">*2</a></sup>。</p>
<div class="footnote-list">
<div class="footnote" id="fn-no-del" epub:type="footnote"><p class="footnote"><span class="footnote-mark">[*2] </span>ここで削除するコードは次の「<a href="14-impl-c.html#h5-4-3">5.4.3 inst_fetcherモジュールを作成する</a>」で実装するコードと似通っているため、削除せずにコメントアウトしておくと少し楽に実装できます。</p></div>
</div><!--/.footnote-list-->
<p>coreモジュールの<code class="inline-code">i_membus</code>の型を<code class="inline-code">core_inst_if::master</code>に変更します()。</p>
<div id="core.veryl.if.port" class="caption-code">
<span class="caption">リスト5.5: リスト5.5:  (core.veryl)</span>
<pre class="list language-port">    i_membus: modport <b>core_inst_if</b>::master,
</pre>
</div>
<p>IFステージ部分のコードを次のように変更します()。</p>
<div id="core.veryl.if.if" class="caption-code">
<span class="caption">リスト5.6: リスト5.6:  (core.veryl)</span>
<pre class="list language-if">    ///////////////////////////////// IF Stage /////////////////////////////////

    var control_hazard        : logic;
    var control_hazard_pc_next: Addr ;

    always_comb {
        i_membus.is_hazard = control_hazard;
        i_membus.next_pc = control_hazard_pc_next;
    }
</pre>
</div>
<p>coreモジュールの新しいIFステージ部分は、制御ハザードの情報をインターフェースに割り当てるだけの簡単なコードになっています。<code class="inline-code">if_fifo_type</code>型、<code class="inline-code">if_fifo_</code>から始まる変数は使わないため削除してください。</p>
<p>IDステージとcore_inst_ifインターフェースを接続します()。もともと<code class="inline-code">if_fifo</code>の<code class="inline-code">rvalid</code>、<code class="inline-code">rready</code>、<code class="inline-code">rdata</code>だった部分をインターフェースに変更しています。</p>
<div id="core.veryl.if.idvar" class="caption-code">
<span class="caption">リスト5.7: リスト5.7:  (core.veryl)</span>
<pre class="list language-idvar">    let ids_valid     : logic    = <b>i_membus.rvalid</b>;
    let ids_pc        : Addr     = <b>i_membus.raddr</b>;
    let ids_inst_bits : Inst     = <b>i_membus.rdata</b>;
</pre>
</div>
<div id="core.veryl.if.idex" class="caption-code">
<span class="caption">リスト5.8: リスト5.8:  (core.veryl)</span>
<pre class="list language-idex">    always_comb {
        // ID -&gt; EX
        <b>i_membus.</b>rready = exq_wready;
        exq_wvalid      = <b>i_membus.</b>rvalid;
        exq_wdata.addr  = <b>i_membus.</b>raddr;
        exq_wdata.bits  = <b>i_membus.</b>rdata;
        exq_wdata.ctrl  = ids_ctrl;
        exq_wdata.imm   = ids_imm;
</pre>
</div>

<h3 id="impl_fetcher" class="none"><a id="h5-4-3"></a><span class="secno">5.4.3</span> inst_fetcherモジュールを作成する</h3>
<p>coreモジュールのIFステージの代わりに命令フェッチをするinst_fetcherモジュールを作成します。inst_fetcherモジュールでは命令フェッチ処理をfetch、issueの2段階で行います。</p>
<dl>
<dt>fetch</dt>
<dd>
    メモリから64ビットの値を読み込み、issueとの間のFIFOに格納する。
    PCを8進めて、次の64ビットを読み込む。
</dd>
<dt>issue</dt>
<dd>
    fetchとの間のFIFOから64ビットを読み込み、
    32ビットずつcoreモジュールとの間のFIFOに格納する。
</dd>
</dl>
<p>fetchとissueは並列に独立して動かします。</p>
<p>inst_fetcherモジュールのポートを定義します。<code class="inline-code">src/inst_fetcher.veryl</code>を作成し、次のように記述します()。</p>
<div id="inst_fetcher.veryl.if.port" class="caption-code">
<span class="caption">リスト5.9: リスト5.9:  (inst_fetcher.veryl)</span>
<pre class="list language-port">module inst_fetcher (
    clk    : input   clock              ,
    rst    : input   reset              ,
    core_if: modport core_inst_if::slave,
    mem_if : modport Membus::master     ,
) {
</pre>
</div>
<p><code class="inline-code">core_if</code>はcoreモジュールとのインターフェース、<code class="inline-code">mem_if</code>はメモリとのインターフェースです。</p>
<p>fetchとissue、issueとcore_ifとの間のFIFOを作成します()。</p>
<div id="inst_fetcher.veryl.if.fetch_fifo" class="caption-code">
<span class="caption">リスト5.10: リスト5.10:  (inst_fetcher.veryl)</span>
<pre class="list language-fetch_fifo">    struct fetch_fifo_type {
        addr: Addr                    ,
        bits: logic&lt;MEMBUS_DATA_WIDTH&gt;,
    }

    var fetch_fifo_flush : logic          ;
    var fetch_fifo_wvalid: logic          ;
    var fetch_fifo_wready: logic          ;
    var fetch_fifo_wdata : fetch_fifo_type;
    var fetch_fifo_rdata : fetch_fifo_type;
    var fetch_fifo_rready: logic          ;
    var fetch_fifo_rvalid: logic          ;

    inst fetch_fifo: fifo #(
        DATA_TYPE: fetch_fifo_type,
        WIDTH    : 3              ,
    ) (
        clk                          ,
        rst                          ,
        flush     : fetch_fifo_flush ,
        wready    : _                ,
        wready_two: fetch_fifo_wready,
        wvalid    : fetch_fifo_wvalid,
        wdata     : fetch_fifo_wdata ,
        rready    : fetch_fifo_rready,
        rvalid    : fetch_fifo_rvalid,
        rdata     : fetch_fifo_rdata ,
    );
</pre>
</div>
<div id="inst_fetcher.veryl.if.issue_fifo" class="caption-code">
<span class="caption">リスト5.11: リスト5.11:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_fifo">    struct issue_fifo_type {
        addr: Addr,
        bits: Inst,
    }

    var issue_fifo_flush : logic          ;
    var issue_fifo_wvalid: logic          ;
    var issue_fifo_wready: logic          ;
    var issue_fifo_wdata : issue_fifo_type;
    var issue_fifo_rdata : issue_fifo_type;
    var issue_fifo_rready: logic          ;
    var issue_fifo_rvalid: logic          ;

    inst issue_fifo: fifo #(
        DATA_TYPE: issue_fifo_type,
        WIDTH    : 3              ,
    ) (
        clk                      ,
        rst                      ,
        flush : issue_fifo_flush ,
        wready: issue_fifo_wready,
        wvalid: issue_fifo_wvalid,
        wdata : issue_fifo_wdata ,
        rready: issue_fifo_rready,
        rvalid: issue_fifo_rvalid,
        rdata : issue_fifo_rdata ,
    );
</pre>
</div>
<p>メモリへのアクセス処理(fetch)を実装します。FIFOに空きがあるとき、64ビットの値を読み込んでPCを8進めます()。この処理はcoreモジュールの元のIFステージとほとんど同じです。</p>
<div id="inst_fetcher.veryl.if.fetch_var" class="caption-code">
<span class="caption">リスト5.12: リスト5.12:  (inst_fetcher.veryl)</span>
<pre class="list language-fetch_var">    var fetch_pc          : Addr ;
    var fetch_requested   : logic;
    var fetch_pc_requested: Addr ;
</pre>
</div>
<div id="inst_fetcher.veryl.if.memory_assign" class="caption-code">
<span class="caption">リスト5.13: リスト5.13:  (inst_fetcher.veryl)</span>
<pre class="list language-memory_assign">    always_comb {
        mem_if.valid = 0;
        mem_if.addr  = 0;
        mem_if.wen   = 0;
        mem_if.wdata = 0;
        mem_if.wmask = 0;
        if !core_if.is_hazard {
            mem_if.valid = fetch_fifo_wready;
            if fetch_requested {
                mem_if.valid = mem_if.valid &amp;&amp; mem_if.rvalid;
            }
            mem_if.addr = fetch_pc;
        }
    }
</pre>
</div>
<div id="inst_fetcher.veryl.if.fetch_pc" class="caption-code">
<span class="caption">リスト5.14: リスト5.14:  (inst_fetcher.veryl)</span>
<pre class="list language-fetch_pc">    always_ff {
        if_reset {
            fetch_pc           = INITIAL_PC;
            fetch_requested    = 0;
            fetch_pc_requested = 0;
        } else {
            if core_if.is_hazard {
                fetch_pc           = {core_if.next_pc[XLEN - 1:3], 3'b0};
                fetch_requested    = 0;
                fetch_pc_requested = 0;
            } else {
                if fetch_requested {
                    if mem_if.rvalid {
                        fetch_requested = mem_if.ready &amp;&amp; mem_if.valid;
                        if mem_if.ready &amp;&amp; mem_if.valid {
                            fetch_pc_requested =  fetch_pc;
                            fetch_pc           += 8;
                        }
                    }
                } else {
                    if mem_if.ready &amp;&amp; mem_if.valid {
                        fetch_requested    =  1;
                        fetch_pc_requested =  fetch_pc;
                        fetch_pc           += 8;
                    }
                }
            }
        }
    }
</pre>
</div>
<p>メモリから読み込んだ値をissueとの間のFIFOに格納します()。</p>
<div id="inst_fetcher.veryl.if.memory_fetch" class="caption-code">
<span class="caption">リスト5.15: リスト5.15:  (inst_fetcher.veryl)</span>
<pre class="list language-memory_fetch">    // memory -&gt; fetch_fifo
    always_comb {
        fetch_fifo_flush      = core_if.is_hazard;
        fetch_fifo_wvalid     = fetch_requested &amp;&amp; mem_if.rvalid;
        fetch_fifo_wdata.addr = fetch_pc_requested;
        fetch_fifo_wdata.bits = mem_if.rdata;
    }
</pre>
</div>
<p>coreモジュールに命令を供給する処理(issue)を実装します。FIFOにデータが入っているとき、32ビットずつcoreモジュールとの間のFIFOに格納します。2つの32ビットの命令をFIFOに格納出来たら、fetchとの間のFIFOを読み進めます()。</p>
<div id="inst_fetcher.veryl.if.issue_offset" class="caption-code">
<span class="caption">リスト5.16: リスト5.16:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_offset">    var issue_pc_offset: logic&lt;3&gt;;

    always_ff {
        if_reset {
            issue_pc_offset = 0;
        } else {
            if core_if.is_hazard {
                issue_pc_offset = core_if.next_pc[2:0];
            } else {
                if issue_fifo_wready &amp;&amp; issue_fifo_wvalid {
                    issue_pc_offset += 4;
                }
            }
        }
    }
</pre>
</div>
<div id="inst_fetcher.veryl.if.fetch_issue" class="caption-code">
<span class="caption">リスト5.17: リスト5.17:  (inst_fetcher.veryl)</span>
<pre class="list language-fetch_issue">    // fetch_fifo &lt;-&gt; issue_fifo
    always_comb {
        let raddr : Addr                     = fetch_fifo_rdata.addr;
        let rdata : logic&lt;MEMBUS_DATA_WIDTH&gt; = fetch_fifo_rdata.bits;
        let offset: logic&lt;3&gt;                 = issue_pc_offset;

        fetch_fifo_rready = 0;
        issue_fifo_wvalid = 0;
        issue_fifo_wdata  = 0;

        if !core_if.is_hazard &amp;&amp; fetch_fifo_rvalid {
            if issue_fifo_wready {
                fetch_fifo_rready     = offset == 4;
                issue_fifo_wvalid     = 1;
                issue_fifo_wdata.addr = {raddr[msb:3], offset};
                issue_fifo_wdata.bits = case offset {
                    0      : rdata[31:0],
                    4      : rdata[63:32],
                    default: 0,
                };
            }
        }
    }
</pre>
</div>
<p><code class="inline-code">core_if</code>とFIFOを接続します()。</p>
<div id="inst_fetcher.veryl.if.issue_core" class="caption-code">
<span class="caption">リスト5.18: リスト5.18:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_core">    // issue_fifo &lt;-&gt; core
    always_comb {
        issue_fifo_flush  = core_if.is_hazard;
        issue_fifo_rready = core_if.rready;
        core_if.rvalid    = issue_fifo_rvalid;
        core_if.raddr     = issue_fifo_rdata.addr;
        core_if.rdata     = issue_fifo_rdata.bits;
    }
</pre>
</div>

<h3 class="none"><a id="h5-4-4"></a><span class="secno">5.4.4</span> inst_fetcherモジュールとcoreモジュールを接続する</h3>
<p>core_inst_ifをインスタンス化します。()。</p>
<div id="top.veryl.if.i_membus_core" class="caption-code">
<span class="caption">リスト5.19: リスト5.19:  (top.veryl)</span>
<pre class="list language-i_membus_core">    inst i_membus_core: core_inst_if;
</pre>
</div>
<p>inst_fetcherモジュールをインスタンス化し、coreモジュールと接続します。</p>
<div id="top.veryl.if.inst" class="caption-code">
<span class="caption">リスト5.20: リスト5.20:  (top.veryl)</span>
<pre class="list language-inst">    inst fetcher: inst_fetcher (
        clk                   ,
        rst                   ,
        core_if: i_membus_core,
        mem_if : i_membus     ,
    );
</pre>
</div>
<div id="top.veryl.if.core" class="caption-code">
<span class="caption">リスト5.21: リスト5.21:  (top.veryl)</span>
<pre class="list language-core">    inst c: core (
        clk                    ,
        rst                    ,
        <b>i_membus: i_membus_core,</b>
        d_membus: d_membus_core,
        led                    ,
    );
</pre>
</div>
<p>inst_fetcherモジュールが64ビットのデータを32ビットの命令の列に変換してくれるようになったので、<code class="inline-code">d_membus</code>との調停のところでアドレスを読んで32ビットずつ選択する処理が必要なくなりました。そのため、<code class="inline-code">memarb_last_iaddr</code>変数とビット選択処理をを削除します()。</p>
<div id="top.veryl.if.memarb_last_i_def" class="caption-code">
<span class="caption">リスト5.22: リスト5.22:  (top.veryl)</span>
<pre class="list language-memarb_last_i_def">    var memarb_last_i: logic;
    <del>var memarb_last_iaddr: Addr;</del>
</pre>
</div>
<div id="top.veryl.if.memarb_last_i_update" class="caption-code">
<span class="caption">リスト5.23: リスト5.23:  (top.veryl)</span>
<pre class="list language-memarb_last_i_update">    always_ff {
        if_reset {
            memarb_last_i = 0;
            <del>memarb_last_i = 0;</del>
        } else {
            if mmio_membus.ready {
                memarb_last_i = !d_membus.valid;
                <del>memarb_last_iaddr = i_membus.addr;</del>
            }
        }
    }
</pre>
</div>
<div id="top.veryl.if.memarb" class="caption-code">
<span class="caption">リスト5.24: リスト5.24:  (top.veryl)</span>
<pre class="list language-memarb">    always_comb {
        i_membus.ready  = mmio_membus.ready &amp;&amp; !d_membus.valid;
        i_membus.rvalid = mmio_membus.rvalid &amp;&amp; memarb_last_i;
        i_membus.rdata  = <b>mmio_membus.rdata</b>;
</pre>
</div>

<h2 class="numbox"><a id="h5-5"></a><span class="secno">5.5</span> 16ビット境界に配置された32ビット幅の命令のサポート</h2>
<p>inst_fetcherモジュールで、アドレスが2バイトの倍数な32ビット幅の命令をcoreモジュールに供給できるようにします。</p>
<p>アドレスの下位3ビット(<code class="inline-code">issue_pc_offset</code>)が<code class="inline-code">6</code>の場合、issueとcoreの間に供給する命令のビット列は<code class="inline-code">fetch_fifo_rdata</code>の上位16ビットと<code class="inline-code">fetch_fifo</code>に格納されている次のデータの下位16ビットを結合したものになります。このとき、<code class="inline-code">fetch_fifo_rdata</code>のデータの下位16ビットとアドレスを保存して、次のデータを読み出します。<code class="inline-code">fetch_fifo</code>から次のデータを読み出せたら、保存していたデータと結合し、アドレスとともに<code class="inline-code">issue_fifo</code>に書き込みます。<code class="inline-code">issue_pc_offset</code>が<code class="inline-code">0</code>、<code class="inline-code">2</code>、<code class="inline-code">4</code>の場合、既存の処理との変更点はありません。</p>
<p><code class="inline-code">fetch_fifo_rdata</code>のデータの下位16ビットとアドレスを保存するための変数を作成します()。</p>
<div id="inst_fetcher.veryl.232.var" class="caption-code">
<span class="caption">リスト5.25: リスト5.25:  (inst_fetcher.veryl)</span>
<pre class="list language-var">    var issue_is_rdata_saved: logic    ;
    var issue_saved_addr    : Addr     ;
    var issue_saved_bits    : logic&lt;16&gt;; // rdata[63:48]
</pre>
</div>
<p><code class="inline-code">issue_pc_offset</code>が<code class="inline-code">6</code>のとき、変数にデータを保存します()。</p>
<div id="inst_fetcher.veryl.232.issue_ff" class="caption-code">
<span class="caption">リスト5.26: リスト5.26:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_ff">    always_ff {
        if_reset {
            issue_pc_offset      = 0;
            <b>issue_is_rdata_saved = 0;</b>
            <b>issue_saved_addr     = 0;</b>
            <b>issue_saved_bits     = 0;</b>
        } else {
            if core_if.is_hazard {
                issue_pc_offset      = core_if.next_pc[2:0];
                <b>issue_is_rdata_saved = 0;</b>
            } else {
                <b>// offsetが6な32ビット命令の場合、</b>
                <b>// アドレスと上位16ビットを保存してFIFOを読み進める</b>
                <b>if issue_pc_offset == 6 &amp;&amp; !issue_is_rdata_saved {</b>
                <b>    if fetch_fifo_rvalid {</b>
                <b>        issue_is_rdata_saved = 1;</b>
                <b>        issue_saved_addr     = fetch_fifo_rdata.addr;</b>
                <b>        issue_saved_bits     = fetch_fifo_rdata.bits[63:48];</b>
                <b>    }</b>
                <b>} else {</b>
                    if issue_fifo_wready &amp;&amp; issue_fifo_wvalid {
                        issue_pc_offset      += 4;
                        <b>issue_is_rdata_saved =  0;</b>
                    }
                <b>}</b>
            }
        }
    }
</pre>
</div>
<p><code class="inline-code">issue_pc_offset</code>が<code class="inline-code">2</code>、<code class="inline-code">6</code>の場合の<code class="inline-code">issue_fifo</code>の書き込み処理を実装します()。<code class="inline-code">6</code>の場合、保存していた16ビットと新しく読みだした16ビットを結合した値、保存していたアドレスを書き込みます。</p>
<div id="inst_fetcher.veryl.232.issue_comb" class="caption-code">
<span class="caption">リスト5.27: リスト5.27:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_comb">        if !core_if.is_hazard &amp;&amp; fetch_fifo_rvalid {
            if issue_fifo_wready {
                <b>if offset == 6 {</b>
                <b>    // offsetが6な32ビット命令の場合、</b>
                <b>    // 命令は{rdata_next[15:0], rdata[63:48}になる</b>
                <b>    if issue_is_rdata_saved {</b>
                <b>        issue_fifo_wvalid     = 1;</b>
                <b>        issue_fifo_wdata.addr = {issue_saved_addr[msb:3], offset};</b>
                <b>        issue_fifo_wdata.bits = {rdata[15:0], issue_saved_bits};</b>
                <b>    } else {</b>
                <b>        // Read next 8 bytes</b>
                <b>        fetch_fifo_rready = 1;</b>
                <b>    }</b>
                <b>} else {</b>
                    fetch_fifo_rready     = offset == 4;
                    issue_fifo_wvalid     = 1;
                    issue_fifo_wdata.addr = {raddr[msb:3], offset};
                    issue_fifo_wdata.bits = case offset {
                        0      : rdata[31:0],
                        <b>2      : rdata[47:16],</b>
                        4      : rdata[63:32],
                        default: 0,
                    };
                <b>}</b>
            }
        }
</pre>
</div>
<p>32ビット幅の命令の下位16ビットが既に保存されている(<code class="inline-code">issue_is_rdata_saved</code>が<code class="inline-code">1</code>)とき、<code class="inline-code">fetch_fifo</code>から供給されるデータには、32ビット幅の命令の上位16ビットを除いた残りの48ビットが含まれているので<code class="inline-code">fetch_fifo_rready</code>を<code class="inline-code">1</code>に設定しないことに注意してください。</p>

<h2 class="numbox"><a id="h5-6"></a><span class="secno">5.6</span> RVC命令の変換</h2>

<h3 class="none"><a id="h5-6-1"></a><span class="secno">5.6.1</span> RVC命令フラグの実装</h3>
<p>RVC命令を32ビット幅の命令に変換するモジュールを作る前に、RVC命令かどうかを示すフラグを作成します。</p>
<p>まず、<code class="inline-code">core_inst_if</code>インターフェースと<code class="inline-code">InstCtrl</code>構造体に<code class="inline-code">is_rvc</code>フラグを追加します()。</p>
<div id="core_inst_if.veryl.is_rvc.var" class="caption-code">
<span class="caption">リスト5.28: リスト5.28:  (core_inst_if.veryl)</span>
<pre class="list language-var">    var rdata    : Inst ;
    <b>var is_rvc   : logic;</b>
    var is_hazard: logic;
</pre>
</div>
<div id="core_inst_if.veryl.is_rvc.master" class="caption-code">
<span class="caption">リスト5.29: リスト5.29:  (core_inst_if.veryl)</span>
<pre class="list language-master">    modport master {
        rvalid   : input ,
        rready   : output,
        raddr    : input ,
        rdata    : input ,
        <b>is_rvc   : input ,</b>
        is_hazard: output, // control hazard
        next_pc  : output, // actual next pc
    }
</pre>
</div>
<div id="corectrl.veryl.is_rvc.InstCtrl" class="caption-code">
<span class="caption">リスト5.30: リスト5.30:  (corectrl.veryl)</span>
<pre class="list language-InstCtrl">        is_amo   : logic      , // AMO instruction
        <b>is_rvc   : logic      , // RVC instruction</b>
        funct3   : logic   &lt;3&gt;, // 命令のfunct3フィールド
</pre>
</div>
<p>inst_fetcherモジュールで、<code class="inline-code">is_rvc</code>を<code class="inline-code">0</code>に設定してcoreモジュールに供給するようにします()。</p>
<div id="inst_fetcher.veryl.is_rvc.issue_fifo_type" class="caption-code">
<span class="caption">リスト5.31: リスト5.31:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_fifo_type">    struct issue_fifo_type {
        addr  : Addr ,
        bits  : Inst ,
        <b>is_rvc: logic,</b>
    }
</pre>
</div>
<div id="inst_fetcher.veryl.is_rvc.issue_comb" class="caption-code">
<span class="caption">リスト5.32: リスト5.32:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_comb">    if offset == 6 {
        // offsetが6な32ビット命令の場合、
        // 命令は{rdata_next[15:0], rdata[63:48}になる
        if issue_is_rdata_saved {
            issue_fifo_wvalid       = 1;
            issue_fifo_wdata.addr   = {issue_saved_addr[msb:3], offset};
            issue_fifo_wdata.bits   = {rdata[15:0], issue_saved_bits};
            <b>issue_fifo_wdata.is_rvc = 0;</b>
        } else {
            // Read next 8 bytes
            fetch_fifo_rready = 1;
        }
    } else {
        fetch_fifo_rready     = offset == 4;
        issue_fifo_wvalid     = 1;
        issue_fifo_wdata.addr = {raddr[msb:3], offset};
        issue_fifo_wdata.bits = case offset {
            0      : rdata[31:0],
            2      : rdata[47:16],
            4      : rdata[63:32],
            default: 0,
        };
        <b>issue_fifo_wdata.is_rvc = 0;</b>
    }
</pre>
</div>
<div id="inst_fetcher.veryl.is_rvc.issue_core" class="caption-code">
<span class="caption">リスト5.33: リスト5.33:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_core">    always_comb {
        issue_fifo_flush  = core_if.is_hazard;
        issue_fifo_rready = core_if.rready;
        core_if.rvalid    = issue_fifo_rvalid;
        core_if.raddr     = issue_fifo_rdata.addr;
        core_if.rdata     = issue_fifo_rdata.bits;
        <b>core_if.is_rvc    = issue_fifo_rdata.is_rvc;</b>
    }
</pre>
</div>
<p>inst_decoderモジュールで、<code class="inline-code">InstCtrl</code>構造体の<code class="inline-code">is_rvc</code>フラグを設定します()。また、C拡張が無効なのにRVC命令が供給されたら@&lt;code&gt;<code class="inline-code">valid</code>フラグを<code class="inline-code">0</code>に設定するようにします。</p>
<div id="inst_decoder.veryl.is_rvc.port" class="caption-code">
<span class="caption">リスト5.34: リスト5.34:  (inst_decoder.veryl)</span>
<pre class="list language-port">module inst_decoder (
    bits  : input  Inst    ,
    <b>is_rvc: input  logic   ,</b>
    valid : output logic   ,
    ctrl  : output InstCtrl,
    imm   : output UIntX   ,
) {
</pre>
</div>
<div id="inst_decoder.veryl.is_rvc.ctrl" class="caption-code">
<span class="caption">リスト5.35: リスト5.35:  (inst_decoder.veryl)</span>
<pre class="list language-ctrl">                default: {
                    InstType::X, F, F, F, F, F, F, F, F, F
                },
            }, <b>is_rvc,</b> f3, f7
        };
</pre>
</div>
<div id="inst_decoder.veryl.is_rvc.valid" class="caption-code">
<span class="caption">リスト5.36: リスト5.36:  (inst_decoder.veryl)</span>
<pre class="list language-valid">            OP_AMO     : f3 == 3'b010 || f3 == 3'b011, // AMO
            default    : F,
        } <b>&amp;&amp; (IALIGN == 16 || !is_rvc)</b>; <b>// IALIGN == 32のとき、C拡張は無効</b>
</pre>
</div>
<p>coreモジュールで、inst_decoderモジュールに<code class="inline-code">is_rvc</code>フラグを設定します()。</p>
<div id="core.veryl.is_rvc.inst_decoder" class="caption-code">
<span class="caption">リスト5.37: リスト5.37:  (core.veryl)</span>
<pre class="list language-inst_decoder">    inst decoder: inst_decoder (
        bits  : ids_inst_bits  ,
        <b>is_rvc: i_membus.is_rvc,</b>
        valid : ids_inst_valid ,
        ctrl  : ids_ctrl       ,
        imm   : ids_imm        ,
    );
</pre>
</div>
<p>ジャンプ命令でライトバックする値は次の命令のアドレスであるため、RVC命令の場合はPCに<code class="inline-code">2</code>を足した値を設定します()。</p>
<div id="core.veryl.is_rvc.wb_data" class="caption-code">
<span class="caption">リスト5.38: リスト5.38:  (core.veryl)</span>
<pre class="list language-wb_data">    let wbs_wb_data: UIntX    = if wbs_ctrl.is_lui ?
        wbs_imm
    : if wbs_ctrl.is_jump ?
        wbs_pc + <b>(if wbs_ctrl.is_rvc ? 2 : </b>4<b>)</b>
    : if wbs_ctrl.is_load || wbs_ctrl.is_amo ?
</pre>
</div>

<h3 id="impl-converter-all" class="none"><a id="h5-6-2"></a><span class="secno">5.6.2</span> 32ビット幅の命令に変換する</h3>
<p>RVC命令のopcode、functなどのフィールドを読んで、32ビット幅の命令を生成するrvc_converterモジュールを実装します。</p>
<p>その前に、命令のフィールドを引数に32ビット幅の命令を生成する関数群を実装します。<code class="inline-code">src/inst_gen_pkg.veryl</code>を作成し、次のように記述します()。</p>
<div id="inst_gen_pkg.veryl.rvcc" class="caption-code">
<span class="caption">リスト5.39: リスト5.39:  (inst_gen_pkg.veryl)</span>
<pre class="list language-rvcc">import eei::*;

package inst_gen_pkg {
    function add (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0000000, rs2, rs1, 3'b000, rd, OP_OP};
    }

    function addw (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0000000, rs2, rs1, 3'b000, rd, OP_OP_32};
    }

    function addi (rd : input logic&lt;5&gt; , rs1: input logic&lt;5&gt; , imm: input logic&lt;12&gt;) -&gt; Inst {
        return {imm, rs1, 3'b000, rd, OP_OP_IMM};
    }

    function addiw (rd: input logic&lt;5&gt; ,rs1: input logic&lt;5&gt;, imm: input logic&lt;12&gt;) -&gt; Inst {
        return {imm, rs1, 3'b000, rd, OP_OP_IMM_32};
    }

    function sub (rd: input logic&lt;5&gt;,rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0100000, rs2, rs1, 3'b000, rd, OP_OP};
    }

    function subw (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0100000, rs2, rs1, 3'b000, rd, OP_OP_32};
    }

    function inst_xor (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0000000, rs2, rs1, 3'b100, rd, OP_OP};
    }

    function inst_or (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0000000, rs2, rs1, 3'b110, rd, OP_OP};
    }

    function inst_and (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;) -&gt; Inst {
        return {7'b0000000, rs2, rs1, 3'b111, rd, OP_OP};
    }

    function andi (rd: input logic&lt;5&gt; , rs1: input logic&lt;5&gt;, imm: input logic&lt;12&gt;) -&gt; Inst {
        return {imm, rs1, 3'b111, rd, OP_OP_IMM};
    }

    function slli (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, shamt: input logic&lt;6&gt;) -&gt; Inst {
        return {6'b000000, shamt, rs1, 3'b001, rd, OP_OP_IMM};
    }

    function srli (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, shamt: input logic&lt;6&gt;) -&gt; Inst {
        return {6'b000000, shamt, rs1, 3'b101, rd, OP_OP_IMM};
    }

    function srai (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, shamt: input logic&lt;6&gt;) -&gt; Inst {
        return {6'b010000, shamt, rs1, 3'b101, rd, OP_OP_IMM};
    }

    function lui (rd: input logic&lt;5&gt;, imm: input logic&lt;20&gt;) -&gt; Inst {
        return {imm, rd, OP_LUI};
    }

    function load (rd: input logic&lt;5&gt; ,rs1: input logic&lt;5&gt;, imm: input logic&lt;12&gt;, funct3: input logic&lt;3&gt;) -&gt; Inst {
        return {imm, rs1, funct3, rd, OP_LOAD};
    }

    function store (rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;, imm: input logic&lt;12&gt;, funct3: input logic&lt;3&gt;) -&gt; Inst {
        return {imm[11:5], rs2, rs1, funct3, imm[4:0], OP_STORE};
    }

    function jal (rd : input logic&lt;5&gt;, imm: input logic&lt;20&gt;) -&gt; Inst {
        return {imm[19], imm[9:0], imm[10], imm[18:11], rd, OP_JAL};
    }

    function jalr (rd: input logic&lt;5&gt;, rs1: input logic&lt;5&gt;, imm: input logic&lt;12&gt;) -&gt; Inst {
        return {imm, rs1, 3'b000, rd, OP_JALR};
    }

    function beq (rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;, imm: input logic&lt;12&gt;) -&gt; Inst {
        return {imm[11], imm[9:4], rs2, rs1, 3'b000, imm[3:0], imm[10], OP_BRANCH};
    }

    function bne (rs1: input logic&lt;5&gt;, rs2: input logic&lt;5&gt;, imm: input logic&lt;12&gt;) -&gt; Inst {
        return {imm[11], imm[9:4], rs2, rs1, 3'b001, imm[3:0], imm[10], OP_BRANCH};
    }

    function ebreak () -&gt; Inst {
        return 32'h00100073;
    }
}
</pre>
</div>
<p>rvc_conveterモジュールのポートを定義します。<code class="inline-code">src/rvc_converter.veryl</code>を作成し、次のように記述します()。</p>
<div id="rvc_converter.veryl.rvcc.port" class="caption-code">
<span class="caption">リスト5.40: リスト5.40:  (rvc_converter.veryl)</span>
<pre class="list language-port">import eei::*;
import inst_gen_pkg::*;

module rvc_converter (
    inst16: input  logic&lt;16&gt;,
    is_rvc: output logic    ,
    inst32: output Inst     ,
) {
</pre>
</div>
<p>rvc_converterモジュールは、<code class="inline-code">inst16</code>で16ビットの値を受け取り、それがRVC命令なら<code class="inline-code">is_rvc</code>を<code class="inline-code">1</code>にして、<code class="inline-code">inst32</code>に同じ意味の32ビット幅の命令を出力する組み合わせ回路です。</p>
<p><code class="inline-code">inst16</code>からソースレジスタ番号を生成します()。<code class="inline-code">rs1d</code>、<code class="inline-code">rs2d</code>の番号の範囲は<code class="inline-code">x8</code>から<code class="inline-code">x15</code>です。</p>
<div id="rvc_converter.veryl.rvcc.rs" class="caption-code">
<span class="caption">リスト5.41: リスト5.41:  (rvc_converter.veryl)</span>
<pre class="list language-rs">    let rs1 : logic&lt;5&gt; = inst16[11:7];
    let rs2 : logic&lt;5&gt; = inst16[6:2];
    let rs1d: logic&lt;5&gt; = {2'b01, inst16[9:7]};
    let rs2d: logic&lt;5&gt; = {2'b01, inst16[4:2]};
</pre>
</div>
<p><code class="inline-code">inst16</code>から即値を生成します()。</p>
<div id="rvc_converter.veryl.rvcc.imm" class="caption-code">
<span class="caption">リスト5.42: リスト5.42:  (rvc_converter.veryl)</span>
<pre class="list language-imm">    let imm_i    : logic&lt;12&gt; = {inst16[12] repeat 7, inst16[6:2]};
    let imm_shamt: logic&lt;6&gt;  = {inst16[12], inst16[6:2]};
    let imm_j    : logic&lt;20&gt; = {inst16[12] repeat 10, inst16[8], inst16[10:9], inst16[6], inst16[7], inst16[2], inst16[11], inst16[5:3]};
    let imm_br   : logic&lt;12&gt; = {inst16[12] repeat 5, inst16[6:5], inst16[2], inst16[11:10], inst16[4:3]};
    let c0_mem_w : logic&lt;12&gt; = {5'b0, inst16[5], inst16[12:10], inst16[6], 2'b0}; // C.LW, C.SW
    let c0_mem_d : logic&lt;12&gt; = {4'b0, inst16[6:5], inst16[12:10], 3'b0}; // C.LD, C.SD
</pre>
</div>
<p><code class="inline-code">inst16</code>から32ビット幅の命令を生成します()。opcode(<code class="inline-code">inst16[1:0]</code>)が<code class="inline-code">2'b11</code>以外なら16ビット幅の命令なので、<code class="inline-code">is_rvc</code>に<code class="inline-code">1</code>を割り当てます。<code class="inline-code">inst32</code>には、初期値として右に<code class="inline-code">inst16</code>を詰めてゼロで拡張した値を割り当てます。</p>
<p>32ビット幅の命令への変換はopcode、funct、ソースレジスタで分岐して地道に実装します。32ビット幅の命令に変換できないとき<code class="inline-code">inst32</code>の値を更新しません。</p>
<p>これにより、<code class="inline-code">inst16</code>が不正なRVC命令のとき、inst_decoderモジュールでデコードできない命令をcoreモジュールに供給してIllegal instruction例外を発生させ、tvalに16ビット幅の不正な命令が設定されます。</p>
<div id="rvc_converter.veryl.rvcc.always_comb" class="caption-code">
<span class="caption">リスト5.43: リスト5.43:  (rvc_converter.veryl)</span>
<pre class="list language-always_comb">    always_comb {
        is_rvc = inst16[1:0] != 2'b11;
        inst32 = {16'b0, inst16};

        let funct3: logic&lt;3&gt; = inst16[15:13];
        case inst16[1:0] { // opcode
            2'b00: case funct3 { // C0
                3'b000: if inst16 != 0 { // C.ADDI4SPN
                    let nzuimm: logic&lt;10&gt; = {inst16[10:7], inst16[12:11], inst16[5], inst16[6], 2'b0};
                    inst32 = addi(rs2d, 2, {2'b0, nzuimm});
                }
                3'b010: inst32 = load(rs2d, rs1d, c0_mem_w, 3'b010); // C.LW
                3'b011: if XLEN &gt;= 64 { // C.LD
                    inst32 = load(rs2d, rs1d, c0_mem_d, 3'b011);
                }
                3'b110: inst32 = store(rs1d, rs2d, c0_mem_w, 3'b010); // C.SW
                3'b111: if XLEN &gt;= 64 { // C.SD
                    inst32 = store(rs1d, rs2d, c0_mem_d, 3'b011);
                }
                default: {}
            }
            2'b01: case funct3 { // C1
                3'b000: inst32 = addi(rs1, rs1, imm_i); // C.ADDI
                3'b001: inst32 = if XLEN == 32 ? jal(1, imm_j) : addiw(rs1, rs1, imm_i); // C.JAL / C.ADDIW
                3'b010: inst32 = addi(rs1, 0, imm_i); // C.LI
                3'b011: if rs1 == 2 { // C.ADDI16SP
                    let imm   : logic&lt;10&gt; = {inst16[12], inst16[4:3], inst16[5], inst16[2], inst16[6], 4'b0};
                    inst32 = addi(2, 2, {imm[msb] repeat 2, imm});
                } else { // C.LUI
                    inst32 = lui(rs1, {imm_i[msb] repeat 8, imm_i});
                }
                3'b100: case inst16[11:10] { // funct2 or funct6[1:0]
                    2'b00: if !(XLEN == 32 &amp;&amp; imm_shamt[msb] == 1) {
                        inst32 = srli(rs1d, rs1d, imm_shamt); // C.SRLI
                    }
                    2'b01: if !(XLEN == 32 &amp;&amp; imm_shamt[msb] == 1) {
                        inst32 = srai(rs1d, rs1d, imm_shamt); // C.SRAI
                    }
                    2'b10: inst32 = andi(rs1d, rs1d, imm_i); // C.ADNI
                    2'b11: if inst16[12] == 0 {
                        case inst16[6:5] {
                            2'b00  : inst32 = sub(rs1d, rs1d, rs2d); // C.SUB
                            2'b01  : inst32 = inst_xor(rs1d, rs1d, rs2d); // C.XOR
                            2'b10  : inst32 = inst_or(rs1d, rs1d, rs2d); // C.OR
                            2'b11  : inst32 = inst_and(rs1d, rs1d, rs2d); // C.AND
                            default: {}
                        }
                    } else {
                        if XLEN &gt;= 64 {
                            if inst16[6:5] == 2'b00 {
                                inst32 = subw(rs1d, rs1d, rs2d); // C.SUBW
                            } else if inst16[6:5] == 2'b01 {
                                inst32 = addw(rs1d, rs1d, rs2d); // C.ADDW
                            }
                        }
                    }
                    default: {}
                }
                3'b101 : inst32 = jal(0, imm_j); // C.J
                3'b110 : inst32 = beq(rs1d, 0, imm_br); // C.BEQZ
                3'b111 : inst32 = bne(rs1d, 0, imm_br); // C.BNEZ
                default: {}
            }
            2'b10: case funct3 { // C2
                3'b000: if !(XLEN == 32 &amp;&amp; imm_shamt[msb] == 1) {
                    inst32 = slli(rs1, rs1, imm_shamt); // C.SLLI
                }
                3'b010: if rs1 != 0 { // C.LWSP
                    let offset: logic&lt;8&gt; = {inst16[3:2], inst16[12], inst16[6:4], 2'b0};
                    inst32 = load(rs1, 2, {4'b0, offset}, 3'b010);
                }
                3'b011: if XLEN &gt;= 64 &amp;&amp; rs1 != 0 { // C.LDSP
                    let offset: logic&lt;9&gt; = {inst16[4:2], inst16[12], inst16[6:5], 3'b0};
                    inst32 = load(rs1, 2, {3'b0, offset}, 3'b011);
                }
                3'b100: if inst16[12] == 0 {
                    inst32 = if rs2 == 0 ? jalr(0, rs1, 0) : addi(rs1, rs2, 0); // C.JR / C.MV
                } else {
                    if rs2 == 0 {
                        inst32 = if rs1 == 0 ? ebreak() : jalr(1, rs1, 0); // C.EBREAK : C.JALR
                    } else {
                        inst32 = add(rs1, rs1, rs2); // C.ADD
                    }
                }
                3'b110: { // C.SWSP
                    let offset: logic&lt;8&gt; = {inst16[8:7], inst16[12:9], 2'b0};
                    inst32 = store(2, rs2, {4'b0, offset}, 3'b010);
                }
                3'b111: if XLEN &gt;= 64 { // C.SDSP
                    let offset: logic&lt;9&gt; = {inst16[9:7], inst16[12:10], 3'b0};
                    inst32 = store(2, rs2, {3'b0, offset}, 3'b011);
                }
                default: {}
            }
            default: {}
        }
    }
</pre>
</div>

<h3 class="none"><a id="h5-6-3"></a><span class="secno">5.6.3</span> RVC命令を発行する</h3>
<p>inst_fetcherモジュールでrvc_converterモジュールをインスタンス化し、RVC命令をcoreモジュールに供給します。</p>
<p>まず、rvc_converterモジュールをインスタンス化します()。</p>
<div id="inst_fetcher.veryl.rvcc.inst" class="caption-code">
<span class="caption">リスト5.44: リスト5.44:  (inst_fetcher.veryl)</span>
<pre class="list language-inst">    // instruction converter
    var rvcc_inst16: logic&lt;16&gt;;
    var rvcc_is_rvc: logic    ;
    var rvcc_inst32: Inst     ;

    inst rvcc: rvc_converter (
        inst16: case issue_pc_offset {
            0      : fetch_fifo_rdata.bits[15:0],
            2      : fetch_fifo_rdata.bits[31:16],
            4      : fetch_fifo_rdata.bits[47:32],
            6      : fetch_fifo_rdata.bits[63:48],
            default: 0,
        },
        is_rvc: rvcc_is_rvc,
        inst32: rvcc_inst32,
    );
</pre>
</div>
<p>RVC命令のとき、変換された32ビット幅の命令を<code class="inline-code">issue_fifo</code>に書き込み、<code class="inline-code">issue_pc_offset</code>を<code class="inline-code">4</code>ではなく<code class="inline-code">2</code>増やすようにします()。</p>
<div id="inst_fetcher.veryl.rvcc.issue_ff" class="caption-code">
<span class="caption">リスト5.45: リスト5.45:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_ff">// offsetが6な32ビット命令の場合、
// アドレスと上位16ビットを保存してFIFOを読み進める
if issue_pc_offset == 6 &amp;&amp; <b>!rvcc_is_rvc &amp;&amp;</b> !issue_is_rdata_saved {
    if fetch_fifo_rvalid {
        issue_is_rdata_saved = 1;
        issue_saved_addr     = fetch_fifo_rdata.addr;
        issue_saved_bits     = fetch_fifo_rdata.bits[63:48];
    }
} else {
    if issue_fifo_wready &amp;&amp; issue_fifo_wvalid {
        issue_pc_offset      += <b>if issue_is_rdata_saved || !rvcc_is_rvc ?</b> 4 <b>: 2</b>;
        issue_is_rdata_saved =  0;
    }
}
</pre>
</div>
<div id="inst_fetcher.veryl.rvcc.issue_comb" class="caption-code">
<span class="caption">リスト5.46: リスト5.46:  (inst_fetcher.veryl)</span>
<pre class="list language-issue_comb">if !core_if.is_hazard &amp;&amp; fetch_fifo_rvalid {
    if issue_fifo_wready {
        if offset == 6 {
            // offsetが6な32ビット命令の場合、
            // 命令は{rdata_next[15:0], rdata[63:48}になる
            if issue_is_rdata_saved {
                issue_fifo_wvalid       = 1;
                issue_fifo_wdata.addr   = {issue_saved_addr[msb:3], offset};
                issue_fifo_wdata.bits   = {rdata[15:0], issue_saved_bits};
                issue_fifo_wdata.is_rvc = 0;
            } else {
                fetch_fifo_rready = 1;
                <b>if rvcc_is_rvc {</b>
                <b>    issue_fifo_wvalid       = 1;</b>
                <b>    issue_fifo_wdata.addr   = {raddr[msb:3], offset};</b>
                <b>    issue_fifo_wdata.is_rvc = 1;</b>
                <b>    issue_fifo_wdata.bits   = rvcc_inst32;</b>
                <b>} else {</b>
                    // Read next 8 bytes
                <b>}</b>
            }
        } else {
            fetch_fifo_rready     = <b>!rvcc_is_rvc &amp;&amp;</b> offset == 4;
            issue_fifo_wvalid     = 1;
            issue_fifo_wdata.addr = {raddr[msb:3], offset};
            <b>if rvcc_is_rvc {</b>
            <b>    issue_fifo_wdata.bits = rvcc_inst32;</b>
            <b>} else {</b>
                issue_fifo_wdata.bits = case offset {
                    0      : rdata[31:0],
                    2      : rdata[47:16],
                    4      : rdata[63:32],
                    default: 0,
                };
            <b>}</b>
            issue_fifo_wdata.is_rvc = <b>rvcc_is_rvc</b>;
        }
    }
}
</pre>
</div>
<p>riscv-testsの<code class="inline-code">rv64uc-p-</code>から始まるテストを実行し、成功することを確認してください。</p>
        </main>
        <nav class="page-navi">
          <a href="13-impl-a.html" class="page-prev">&#9664;</a>
          <a href="20-mmode-csr.html" class="page-next">&#9654;</a>
        </nav>
        <br>
        <br>
        <footer style="background:#dddddd">
      <div style="padding: 20px 20px 20px 20px;">
          <div style="font-size:1.4rem"><b>コンピュータは、CPUを書けば理解できる！</b></div><br>
          コンピュータアーキテクチャはCPUを作れば理解できます。
          「Verylで作るCPU」は、ハードウェア記述言語VerylでRISC-VのCPUを自作する方法を解説するプロジェクトです。<br>
          「Verylで作るCPU 基本編」では、ハードウェア記述言語の基礎から、OSを実行できる程度のCPUの実装方法までを解説します。<br>
          <br>
          キーワード: 自作CPU , RISC-V , Veryl , FPGA<br>
      <div>
        </footer>
      </div>
    </div>
    
    <script>
      let url = window.location.href;
      let encoded_url = encodeURI(url);
      let fb = document.getElementById("share-facebook");
      fb["data-href"] = url;
      console.log(fb);
    </script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v21.0"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  </body>
</html>
<!-- layout.html5.erb -->
